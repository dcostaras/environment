#+author: Donavan-Ross Costaras
#+email: d.costaras@gmail.com

* license

This file is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

This file is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Emacs; see the file COPYING.  If not, write to
the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.

* Stuff to do

** Repos to explore
https://github.com/noctuid?tab=repositories
** papers
http://erikclarke.net/2014/10/21/keeping-a-lab-notebook-with-org-mode-git-papers-and-pandoc-part-ii/
** ztree
Tree style directory browsing and diffing
[[https://github.com/fourier/ztree][ztree github]]
** avy
ace-jump replacement, maybe worth looking at.
[[http://oremacs.com/2015/05/08/avy-0.1.0/][avy blog post]]
** org pomodoro not allowing me to carry on... check by removing sound hooks
** file headers
http://emacswiki.org/emacs/AutomaticFileHeaders
** add global header args to this file
Like with a hash char:
+PROPERTY: header-args:emacs-list
** For Jane: org-mode improvements from sacha
http://sachachua.com/blog/2015/02/learn-take-notes-efficiently-org-mode/
** eshell cd ... etc to show which level of dir down in the prompt
** Move secrets to secret file
http://emacs-fu.blogspot.com/2011/02/keeping-your-secrets-secret.html
** SES mode
[[http://web.archive.org/web/20050308193719/http://home.comcast.net/~jyavner/ses/ses-example.ses][SES mode example]]
** These are good .emacsen to peruse
http://nhoffman.github.io/.emacs.d/
http://www.srid.ca/emacs/#sec-1
https://github.com/snosov1/dot-emacs#terminal-emulator-and-ssh
** Emms tagging from discogs
[[https://github.com/jesseward/discogstagger][cli discogs tagger]]
** yas helm integration for snippet insertions
  [[file:~/src/org/emacs.init.org::*hippie-expand][hippie-expand]]
** Vimperator <-> mozprepl <-> emacs ... wow, would be nice
http://www.emacswiki.org/emacs/Mozilla
** Yas leader key
make <space> y (key) work like other leader keys
** Project system
maybe dir local var
needs
- namespace (award)
- date started for gpl snippet
** autopair php make [] also pad
** linum relative current line number var buffer local not file local
** req package
[[https://github.com/edvorg/req-package][req package]]
Disclaimer: Uses lots of code from many places.
* profiles

#+begin_src emacs-lisp :tangle ~/.emacs-profiles.el
(("emacs" . ((user-emacs-directory . "~/.emacs.d")))
 ("spacemacs" . ((user-emacs-directory . "~/.emacs.d.spacemacs"))))
#+end_src

* Load time

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(defvar shit-load-time-start (float-time))
(message "Start::::: %.2f s" (- (float-time) shit-load-time-start))
;;(setq debug-on-error t)
#+end_src

* Package systems

** package

Setup Emacs' package archives

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start package::::: %.2f s" (- (float-time) shit-load-time-start))
(setq package-archives '(("org" . "http://orgmode.org/elpa/")
                         ("gnu" . "http://elpa.gnu.org/packages/")
                         ("melpa-stable" . "https://stable.melpa.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")))

(require 'package)
(package-initialize)
#+end_src

** use-package

Deferred loading using John Wiegley's use-package. use-package needs to be installed manually.

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start use-package::::: %.2f s" (- (float-time) shit-load-time-start))

(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(require 'use-package)

(use-package diminish
  :ensure t)
#+end_src

* bug-hunter

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el2
(message "Start bug-hunter:::: %.2fs" (- (float-time) shit-load-time-start))
(use-package bug-hunter
  :defer t)
#+end_src

* emacs lisp APIs
** m-buffer

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (message "Start m-buffer:::: %.2fs" (- (float-time) shit-load-time-start))

  ;; (use-package m-buffer)
#+end_src

** dash

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start dash:::: %.2fs" (- (float-time) shit-load-time-start))

(use-package dash
  :defer t)
#+end_src

** s

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start s:::: %.2fs" (- (float-time) shit-load-time-start))

(use-package s
  :defer t)
#+end_src

** f

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(use-package f
  :commands (f-entries)
  :defer t)
#+end_src

* Macros

#+begin_src emacs-lisp
(message "Start Macros:::: %.2fs" (- (float-time) shit-load-time-start))
#+end_src

** Macrostep

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start Macros/Macrostep:::: %.2fs" (- (float-time) shit-load-time-start))

(use-package macrostep
  :defer t)
#+end_src

** Names

#+begin_src emacs-lisp
(use-package names
  :defer t)
#+end_src

** after

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(defmacro after (feature &rest body)
  "After FEATURE is loaded, evaluate BODY."
  (declare (indent defun))
  `(eval-after-load ,feature
     '(progn ,@body)))
#+end_src

** hook-into-modes

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
;;; Utility macro al la John Wiegley
(defmacro hook-into-modes (func modes)
  `(dolist (mode-hook ,modes)
     (add-hook mode-hook ,func)))
#+end_src

* cl-lib

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(use-package cl
  :defer t)
#+end_src

* Setup

** kill ring

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(setq kill-ring-max 1000)
#+end_src

** Enable commands

#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/init.el
(put 'downcase-region             'disabled nil)   ; Let downcasing work
(put 'erase-buffer                'disabled nil)
(put 'eval-expression             'disabled nil)   ; Let ESC-ESC work
(put 'narrow-to-page              'disabled nil)   ; Let narrowing work
(put 'narrow-to-region            'disabled nil)   ; Let narrowing work
(put 'set-goal-column             'disabled nil)
(put 'upcase-region               'disabled nil)   ; Let upcasing work
(put 'company-coq-fold            'disabled nil)
(put 'TeX-narrow-to-group         'disabled nil)
(put 'LaTeX-narrow-to-environment 'disabled nil)
#+END_SRC

** User Directories

Set user directories as constants for use in init script

*** create-directory-if-needed

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(defun create-directory-if-needed (dir-name)
  (if (not (file-directory-p dir-name))
      (shell-command (concat "mkdir " dir-name))))
#+end_src

*** create-user-directory

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(defmacro create-user-directory (name)
  (let* ((directory (concat user-emacs-directory name "/")))
    `(progn
       (defconst ,(intern (concat "user-" name "-directory")) ,directory)
       (create-directory-if-needed ,directory))))
#+end_src

*** create directories

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "User Directories:::: %.2f s" (- (float-time) shit-load-time-start))
(create-user-directory "elpa")
(create-user-directory "elisp")
(create-user-directory "lib")
(create-user-directory "usr")
(create-user-directory "var")
#+end_src

** Custom file settings

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
;;; Set and load the custom file
(let ((custom-el-file (concat user-usr-directory "emacs-custom.el")))
  (if (file-exists-p custom-el-file)
      (load-file custom-el-file)
    (shell-command (concat "touch " custom-el-file)))
  (setq custom-file custom-el-file))
#+end_src

** Env variables

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (setq user-mail-address "d.costaras@gmail.com";; (getenv "EMAIL")
        user-full-name "Donavan-Ross Costaras" ;; (getenv "NAME")
        )
#+end_src

** Font size

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(set-frame-font "Inconsolata 16" nil t)
#+end_src

** Auto-save and backup

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start Auto Save::::: %.2f s" (- (float-time) shit-load-time-start))

(defvar autosave-dir (concat user-var-directory "emacs_autosaves/"))

(make-directory autosave-dir t)

(defvar backup-dir (concat user-var-directory "emacs_backups/" (user-login-name) "/"))
(setq backup-directory-alist (list (cons "." backup-dir)))

(defun auto-save-file-name-p (filename)
  (string-match "^#.*#$" (file-name-nondirectory filename)))

(defun make-auto-save-file-name ()
  (concat autosave-dir
          (if buffer-file-name
              (concat "#" (file-name-nondirectory buffer-file-name) "#")
            (expand-file-name
             (concat "#%" (buffer-name) "#")))))

(setenv "HISTFILE" (concat user-var-directory ".history"))

(defun save-all ()
    (interactive)
    (do-auto-save t))
 (add-hook 'focus-out-hook 'save-all)

(setq
 ;;backups
 make-backup-files t ;; do make backups
 auto-save-interval 50
 auto-save-timeout 10
 backup-by-copying t ;; and copy them here
 version-control t
 kept-new-versions 10
 kept-old-versions 10
 delete-old-versions t
 )
#+end_src

** History
#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start History:::: %.2fs" (- (float-time) shit-load-time-start))

(setq savehist-file (concat user-var-directory "savehist"))
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))

#+end_src
** Load path

 #+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
 (message "Start Load Path::::: %.2f s" (- (float-time) shit-load-time-start))

 (defun add-to-load-path (path &optional dir)
   (setq load-path
         (cons (expand-file-name path (or dir user-emacs-directory)) load-path)))

 (add-to-load-path user-elisp-directory)
 (add-to-load-path user-lib-directory)
#+end_src

** Generic
*** Setq defaults

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (message "Generic:::: %.2fs" (- (float-time) shit-load-time-start))

  (setq auto-compression-mode 1
        auto-revert-verbose nil
        backup-by-copying-when-linked t
        backup-by-copying-when-mismatch t
        bookmark-default-file "~/.emacs.d/var/bookmarks"
        bookmark-save-flag 1
        create-lockfiles nil
        debug-on-error t
        display-time-24hr-format t
        display-time-day-and-date t
        frame-title-7format '(buffer-file-name "%f" ("%b"))
        gamegrid-user-score-file-directory (locate-user-emacs-file "_games/")
        global-auto-revert-non-file-buffers t
        global-font-lock-mode 1
        indent-tabs-mode nil
        inhibit-startup-screen t
        mouse-drag-copy-region t
        next-line-add-newlines t
        recentf-max-saved-items 100
        resize-minibuffer-mode t
        save-interprogram-paste-before-kill t
        save-place t
        save-place-file "~/.emacs.d/var/saveplace"
        sentence-end-double-space nil
        standard-indent 4
        transient-mark-mode t
        undo-outer-limit 40000000 ; For big cider error buffers
        vc-diff-switches diff-switches
        vc-initial-comment t
        version-control t
        visible-bell t)

  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

  (menu-bar-mode t)

  (display-time)
   #+end_src

*** Other generic
    #+begin_src emacs-lisp :tangle ~/.emacs.d/init.el

      (blink-cursor-mode 0)

      (global-hl-line-mode)
      ;; Auto refresh buffers
      (global-auto-revert-mode 1)

      ;; Also auto refresh dired, but be quiet about it
      (put 'overwrite-mode 'disabled t)

      (column-number-mode t)                                                                              ; Column number mode

      (add-hook 'comint-output-filter-functions 'comint-watch-for-password-prompt) ;; Watch for password prompt

      ;; overrride the default function....
      (defun emacs-session-filename (SESSION-ID)
        (concat "~/.emacs.d/var/session." SESSION-ID))

      ;; filecache: http://www.emacswiki.org/cgi-bin/wiki/FileNameCache
      (eval-after-load "filecache"
        '(progn (message "Loading file cache...")
                (file-cache-add-directory "~/")
                (file-cache-add-directory-list '("~/Desktop" "~/Documents"))))

      (use-package saveplace)
      (use-package savehist
        :config
        (progn
          (savehist-mode t)
          (setq savehist-additional-variables '(search ring regexp-search-ring)
           savehist-autosave-interval 60
           savehist-file "~/.emacs.d/var/savehist")))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; key board / input method settings
      (setq locale-coding-system 'utf-8)
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (set-selection-coding-system 'utf-8)
      (prefer-coding-system 'utf-8)
      (set-language-environment "UTF-8")
      (set-input-method nil)
      (setq read-quoted-char-radix 10)

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; the modeline
      (line-number-mode t)
      (column-number-mode t)
      (size-indication-mode t)

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; safe locals
      ;; we mark these as 'safe', so emacs22+ won't give us annoying
      ;; warnings
      (setq safe-local-variable-values
            (quote ((auto-recompile . t)
                    (my-org-tangle-switch . t)
                    (folding-mode . t)
                    (outline-minor-mode . t)
                    auto-recompile outline-minor-mode)))


      ;; ignore byte-compile warnings
      (setq warnings-to-ignore '())
      (add-to-list 'warnings-to-ignore '(free-vars))
      (add-to-list 'warnings-to-ignore '(nresolved))
      (add-to-list 'warnings-to-ignore '(callargs))
      (add-to-list 'warnings-to-ignore '(redefine))
      (add-to-list 'warnings-to-ignore '(obsolete))
      (add-to-list 'warnings-to-ignore '(noruntine))
      (add-to-list 'warnings-to-ignore '(cl-functions))
      (add-to-list 'warnings-to-ignore '(interactive-only))

      (setq byte-compile-warnings warnings-to-ignore)

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; the minibuffer
      ;;
      (setq
       enable-recursive-minibuffers nil         ;;  allow mb cmds in the mb
       max-mini-window-height .25             ;;  max 2 lines
       minibuffer-scroll-window nil
       resize-mini-windows nil)

      (icomplete-mode t)                       ;; completion in minibuffer
      (setq
       icomplete-prospects-height 1           ;; don't spam my minibuffer
       icomplete-compute-delay 0)             ;; don't wait
      (require 'icomplete+ nil 'noerror)      ;; drew adams' extras

      (setq cua-enable-cua-keys nil)           ;; only for rectangles
      (cua-mode t)

                                              ;(setq ;; scrolling
                                              ;scroll-margin 0                        ;; do smooth scrolling, ...
                                              ;scroll-conservatively 100000           ;; ... the defaults ...
                                              ;scroll-up-aggressively 0               ;; ... are very ...
                                              ;scroll-down-aggressively 0             ;; ... annoying
                                              ;scroll-preserve-screen-position t)     ;; preserve screen pos with C-v/M-v

      (setq fringe-mode '(1 . 0))              ;; emacs 22+
      (delete-selection-mode 1)                ;; delete the sel with a keyp

      (if (eq window-system 'x)
          (setq x-select-enable-clipboard t        ;; copy-paste should work ...
                interprogram-paste-function            ;; ...with...
                'x-cut-buffer-or-selection-value))      ;; ...other X clients

      (setq search-highlight t                 ;; highlight when searching...
            query-replace-highlight t)             ;; ...and replacing
      (fset 'yes-or-no-p 'y-or-n-p)            ;; enable y/n answers to yes/no

      (setq completion-ignore-case t           ;; ignore case when completing...
            read-file-name-completion-ignore-case t) ;; ...filenames too


      (setq initial-scratch-message
            ";; Hello Neo ")

      ;; put fortune in scratch buffer
      ;; (setq initial-scratch-message
      ;;       (format
      ;;        ";; %s\n\n"
      ;;        (replace-regexp-in-string
      ;;         "\n" "\n;; " ; comment each line
      ;;         (replace-regexp-in-string
      ;;          "\n$" ""    ; remove trailing linebreak
      ;;          (shell-command-to-string "fortune")))))

      (put 'narrow-to-region 'disabled nil)    ;; enable...
      (put 'erase-buffer 'disabled nil)        ;; ... useful things
      (file-name-shadow-mode t)                ;; be smart about filenames in mbuf

      ;; only start emacs server when it's not started, I hate warnings.
      ;; (setq server-socket-file "~/tmp/emacs1000/server")
      ;; (unless (file-exists-p server-socket-file)
      ;;   (server-start))

                                              ;(require 'edit-server)
                                              ;(edit-server-start)
      ;; Initail file load
      ;; (if (not (boundp 'loaded))
      ;;     (progn
      ;;       (find-file "~/lsdev.org")
      ;;       (switch-to-buffer "lsdev.org")))
      ;; (setq loaded 1)

#+end_src

** saving and quitting

#+begin_src emacs-lisp
(message "Setup/Start saving and quitting:::: %.2fs" (- (float-time) shit-load-time-start))

(defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
           (flet ((process-list ())) ad-do-it))

;; (defun save-all ()
;;   (interactive)
;;   (save-some-buffers t))
;; (add-hook 'focus-out-hook 'save-all)
#+end_src

** line numbers

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(setq display-line-numbers-type 'relative
      display-line-numbers-grow-only t
      display-line-numbers-current-absolute nil)
(add-hook 'org-mode-hook
	  (lambda ()
	    (setq-local display-line-numbers-type 'visual)))
(global-display-line-numbers-mode)
#+end_src

** whitespace

  #+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
    (use-package ethan-wspace
      :init (setq-default
	     require-final-newline nil
	     mode-require-final-newline nil)
      :config (global-ethan-wspace-mode 1)
      :ensure t)
  #+end_src

**** fix whitespace in dir

  #+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (defconst my-f-entries-whitespace-ignore-rx
    '(or "/."
         "node_modules"
	 "target"
         (seq (* any) ".gpg" string-end))
    "An `rx' sexp regexp form used by `my-fix-whitespace-in-dir'.")

  (defconst my-f-entries-file-types '("html" "clj" "cljc" "cljs")
    "A list of file types used by `my-fix-whitespace-in-dir'.")

  (defun my-f-entries-whitespace-ignore? (path)
    "Returns t if PATH is not to be ignored by `my-fix-whitespace-in-dir'."
    (if (not (s-matches? (rx-to-string my-f-entries-whitespace-ignore-rx)
                         path))
        (-contains? my-f-entries-file-types (f-ext path))))

  (defun my-ethan-clean-all-in-file (path)
    "Calls `ethan-wspace-clean-all' on PATH and saves the file."
    (let ((buffer (find-file path)))
      (set-buffer buffer)
      (ethan-wspace-clean-all)
      (save-buffer)
      (kill-buffer buffer)))

  (defun my-fix-whitespace-in-dir (path)
    "Recurse down from PATH, cleaning whitespace in selected files.

  Recurse down from PATH running `ethan-wspace-clean-all' on each
  file if the file or directory is not ignored by the regexp
  `my-f-entries-whitespace-ignore-rx' and is of the file types defined
  by `my-f-entries-file-types'."
    (interactive "DDirectory to start walk from: ")
    (mapc 'my-ethan-clean-all-in-file
          (f-entries path 'my-f-entries-whitespace-ignore? t)))
  #+end_src

** scrolling

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(setq scroll-conservatively 101)
#+end_src

** mouse

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (use-package disable-mouse
    :ensure t)

  (after 'evil
    (mapc #'disable-mouse-in-keymap
	  (list evil-motion-state-map
		evil-normal-state-map
		evil-visual-state-map
		evil-insert-state-map)))
#+end_src

* Mac OSX only

#+begin_src emacs-lisp :noweb yes :tangle ~/.emacs.d/init.el
(message "Osx only:::: %.2fs" (- (float-time) shit-load-time-start))
(if (or (eq window-system 'ns) (eq window-system 'mac))
    (progn
      <<osx-body>>
      <<osx-server>>
      <<osx-shells>>))
#+end_src

** body

#+name: osx-body
#+begin_src emacs-lisp
  (message "Osx only/body:::: %.2fs" (- (float-time) shit-load-time-start))

  (setq mac-option-modifier 'super)
  (setq mac-command-modifier 'meta)

  (setq locate-command "mdfind -name %s %s")
  (setq helm-locate-command "mdfind -name %s %s")

  (add-hook 'term-mode-hook (lambda() (setq yas-dont-activate t)))


  (add-hook 'term-mode-hook
            (lambda ()
              (add-to-list 'term-bind-key-alist '("M-[" . multi-term-prev))
              (add-to-list 'term-bind-key-alist '("M-]" . multi-term-next))))

  ;; DOESN"T WORK
  ;; (setenv "ESHELL" (expand-file-name "~/bin/eshell"))
  ;; (setq multi-term-program "~/bin/eshell")

  ;; (add-hook 'term-mode-hook
  ;;           (lambda ()
  ;;             (define-key term-raw-map (kbd "C-y") 'term-paste)))

  ;; (use-package todochiku
  ;;   :ensure t)

  ;; (setq todochiku-command "/usr/local/bin/growlnotify")
  ;; (setq todochiku-icons-directory (expand-file-name "~/.emacs.d/usr/todochiku-icons/"))


  ;;----------------------------------------------------------------------------
  ;; Use terminal-notifier in OS X Mountain Lion
  ;; https://github.com/alloy/terminal-notifier (Install in /Applications)
  ;;----------------------------------------------------------------------------
  ;; (setq terminal-notifier-path
  ;;       "/Applications/terminal-notifier.app/Contents/MacOS/terminal-notifier")

  ;; (defadvice todochiku-get-arguments (around todochiku-nc)
  ;;   (setq ad-return-value
  ;;         (list "-title" title "-message" message "-activate" "org.gnu.Emacs")))

  ;; (when (file-executable-p terminal-notifier-path)
  ;;   (setq todochiku-command terminal-notifier-path)
  ;;   (ad-activate 'todochiku-get-arguments))


  (if (eq window-system 'ns)
      (global-set-key (kbd "C-M-f") 'ns-toggle-fullscreen))

  (if (eq window-system 'mac)
      (progn
        ;; Fullscreen that's not OSX 'fullscreen'
        (defun toggle-fullscreen ()
          "Toggle full screen"
          (interactive)
          (set-frame-parameter
           nil 'fullscreen
           (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))
        (set-frame-parameter nil 'fullscreen 'fullboth)
        (global-set-key (kbd "C-M-f") 'toggle-fullscreen)))

  (require 'ls-lisp)
  (setq ls-lisp-use-insert-directory-program nil)


  (defun set-exec-path-from-shell-PATH ()
    "Set up Emacs' `exec-path' and PATH environment variable to match that used by the user's shell.
  This is particularly useful under Mac OSX, where GUI apps are not started from a shell."
    (interactive)
    (let ((path-from-shell (replace-regexp-in-string "[ \t\n]*$" "" (shell-command-to-string "$SHELL --login -i -c 'echo $PATH'"))))
      (setenv "PATH" path-from-shell)
      (setq exec-path (split-string path-from-shell path-separator))))
  (set-exec-path-from-shell-PATH)


  ;; (use-package defshell
  ;; :bind ("C-. d" . my-multi-shell)
  ;; :config
  ;; (progn
  ;;   (defvar multi-shell-initialized nil)
  ;;   (defun my-multi-shell ()
  ;;     (interactive)
  ;;     (unless multi-shell-initialized
  ;;       (message "...Setting up multi-shell")

  ;;       (setq explicit-rails-args '("server"))
  ;;       (defshell "rails" "Rails")

  ;;       (setq explicit-zsh-args '())
  ;;       (defshell "zsh" "zsh")))))


#+end_src

** server

#+name: osx-server
#+begin_src emacs-lisp
(message "Start server:::: %.2fs" (- (float-time) shit-load-time-start))

;; (server-force-delete)
;; (server-start)
#+end_src

** Shells

#+name: osx-shells
#+begin_src emacs-lisp

;; (setq
;;    comint-scroll-to-bottom-on-input t  ; always insert at the bottom
;;    comint-scroll-to-bottom-on-output t ; always add output at the bottom
;;    comint-scroll-show-maximum-output t ; scroll to show max possible output
;;    comint-completion-autolist t        ; show completion list when ambiguous
;;    comint-input-ignoredups t           ; no duplicates in command history
;;    comint-completion-addsuffix t       ; insert space/slash after file completion
;;    )

;;   ; interpret and use ansi color codes in shell output windows
;;   (ansi-color-for-comint-mode-on)



  ;; C-5, 6, 7 to switch to shells
  ;; (global-set-key [(control \5)]
  ;;                 (lambda () (interactive) (switch-to-buffer "shell 1")))
  ;; (global-set-key [(control \6)]
  ;;                 (lambda () (interactive) (switch-to-buffer "shell 2")))
  ;; (global-set-key [(control \7)]
  ;;                 (lambda () (interactive) (switch-to-buffer "shell 3")))
  ;; (global-set-key [(control \8)]
  ;;                 (lambda () (interactive) (switch-to-buffer "shell 4")))

 ; (require 'tramp)
  ; (setq tramp-default-method "ssh")


    ;; (require 'em-smart)
    ;; (setq eshell-where-to-jump 'begin)
    ;; (setq eshell-review-quick-commands nil)
    ;; (setq eshell-smart-space-goes-to-end t)


#+end_src

* packages
** general

 #+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
 (use-package general
   :ensure t
   :pin melpa-stable
   :config
   (progn

     (general-create-definer leader-define
       :states 'normal
       :keymaps '(override global)
       :prefix "SPC")

     (leader-define
       "j" 'hydra-window/body
       "k" 'avy-goto-char-2)

     (general-create-definer my-local-leader-def
       :prefix "SPC m")

     (leader-define
       :keymaps 'normal
       "a" 'org-agenda
       "b" 'counsel-bookmark
       "c" 'org-capture)))
 #+end_src

** hydra

 #+begin_src emacs-lisp :noweb yes :tangle ~/.emacs.d/init.el
 (use-package hydra
   :ensure t)
 #+end_src

** isearch+

 #+begin_src emacs-lisp :noweb yes :tangle ~/.emacs.d/init.el
 (use-package isearch+
   :config
   (setq isearchp-highlight-regexp-group-levels-flag t))
 #+end_src

* evil

#+begin_src emacs-lisp :noweb yes :tangle ~/.emacs.d/init.el
  (message "Evil:::: %.2fs" (- (float-time) shit-load-time-start))

  (use-package evil
    :ensure t
    :init
    (progn
      (setq evil-default-state 'normal
	    evil-respect-visual-line-mode t
	    evil-want-C-u-scroll t
	    evil-want-keybinding nil))
    :config
    (progn
      (evil-mode 1)
      <<evil-keys>>
      <<evil-escape>>
      <<evil-exchange>>
      <<evil-collection>>
      ;;<<evil-leader>>
      ;;<<evil-plugins>>
      ;;<<evil-main>>
      ;;<<evil-motions>>
      ;;<<evil-operators>>
      ;;<<evil-functions>>
      ;;<<evil-integration>>
      ))
#+end_src

** evil-exchange

#+name: evil-exchange
#+begin_src emacs-lisp
(use-package evil-exchange
  :ensure t
  :config
  (evil-exchange-install))
#+end_src

** evil-keys

#+name: evil-keys
#+begin_src emacs-lisp
  (general-define-key
   "C-h" 'evil-delete-backward-word)

  (general-define-key
   :states 'insert
   :keymaps 'cider-repl-mode-map
   "C-d" 'evil-scroll-down
   "C-u" 'evil-scroll-up)
#+end_src

** evil-collection

#+name: evil-collection
#+begin_src emacs-lisp
  (use-package evil-collection
    :ensure t
    :config (evil-collection-init))
#+end_src

** evil-escape

#+name: evil-escape
#+begin_src emacs-lisp
(use-package evil-escape
  :ensure t
  :config
  (progn
    (setq evil-escape-key-sequence "jk"
          evil-escape-unordered-key-sequence t)
    (evil-escape-mode)))
#+end_src

** plugins

#+name: evil-plugins
#+begin_src emacs-lisp
  (message "Start evil/plugins:::: %.2fs" (- (float-time) shit-load-time-start))

  ;; (use-package evil-args
  ;;   :ensure t)
  ;; (use-package evil-quickscope
  ;;   :ensure t)
  ;; (use-package evil-org
  ;;   :ensure t)
  ;; (use-package evil-extra-operator
  ;;   :ensure t
  ;;   :config
  ;;   (global-evil-extra-operator-mode 1))
  ;; (use-package evil-indent-plus
  ;;   :ensure t
  ;;   :config (evil-indent-plus-default-bindings))

  ;; (use-package evil-extra-operator
  ;;   :ensure t
  ;;   :config
  ;;   (define-key evil-motion-state-map "gr" 'evil-operator-eval))

  ;; (use-package evil-exchange
  ;;   :ensure t)

  ;; (use-package evil-multiedit
  ;;   :ensure t
  ;;   :config
  ;;   ;; Highlights all matches of the selection in the buffer.
  ;;   (define-key evil-visual-state-map "R" 'evil-multiedit-match-all)

  ;;   ;; Match the word under cursor (i.e. make it an edit region). Consecutive presses will
  ;;   ;; incrementally add the next unmatched match.
  ;;   (define-key evil-normal-state-map (kbd "M-d") 'evil-multiedit-match-and-next)
  ;;   ;; Match selected region.
  ;;   (define-key evil-visual-state-map (kbd "M-d") 'evil-multiedit-match-and-next)

  ;;   ;; Same as M-d but in reverse.
  ;;   (define-key evil-normal-state-map (kbd "M-D") 'evil-multiedit-match-and-prev)
  ;;   (define-key evil-visual-state-map (kbd "M-D") 'evil-multiedit-match-and-prev)

  ;;   ;; Restore the last group of multiedit regions.
  ;;   (define-key evil-visual-state-map (kbd "C-M-D") 'evil-multiedit-restore)

  ;;   ;; RET will toggle the region under the cursor
  ;;   (define-key evil-multiedit-state-map (kbd "RET") 'evil-multiedit-toggle-or-restrict-region)

  ;;   ;; ...and in visual mode, RET will disable all fields outside the selected region
  ;;   (define-key evil-visual-state-map (kbd "RET") 'evil-multiedit-toggle-or-restrict-region)

  ;;   ;; For moving between edit regions
  ;;   (define-key evil-multiedit-state-map (kbd "C-n") 'evil-multiedit-next)
  ;;   (define-key evil-multiedit-state-map (kbd "C-p") 'evil-multiedit-prev)
  ;;   (define-key evil-multiedit-insert-state-map (kbd "C-n") 'evil-multiedit-next)
  ;;   (define-key evil-multiedit-insert-state-map (kbd "C-p") 'evil-multiedit-prev))

  ;; (use-package evil-escape
  ;;   :ensure t)

  ;; (use-package evil-matchit
  ;;   :ensure t)

  ;; (use-package evil-surround
  ;;   :ensure t
  ;;   :config (global-evil-surround-mode 1))

  ;(use-package evil-jumper
  ;  :ensure t)

  ;; (use-package evil-snipe
  ;;   :ensure t)

  ;; (use-package evil-anzu
  ;;   :ensure t)

  ;; (use-package evil-visual-mark-mode
  ;;   :ensure t)

  ;; (use-package evil-smartparens
  ;;   :ensure t
  ;;   :config
  ;;   (progn
  ;;     (add-hook 'smartparens-enabled-hook #'evil-smartparens-mode)))

  ;; (use-package evil-paredit
  ;;   :ensure t)
#+end_src

#+RESULTS: evil-plugins

** test packages

https://github.com/tarao/evil-plugins/blob/master/README.rdoc
https://github.com/Dewdrops/evil-extra-operator
evil-god-state   h 20141116… available  melpa       29  use god-mode keybindings in evil-mode
evil-lisp-state  h 20150328… available  melpa       19  An evil state to edit Lisp code
evil-search-highl… 20150216… available  melpa        4  Persistent highlights after search
evil-terminal-cur… 20150403… available  melpa        3  Change cursor shape by evil state on terminal.
evil-visualstar  h 20150301… available  melpa       16  Starts a * or # search from the visual selection

** TODO learn how to use vim marks
** TODO see if evil-space works with evil-leader as it doesn't work with my leader map

#+begin_src emacs-lisp
;;; Conflicts with my leader implementation, check if works with evil-leader lib
;; (use-package evil-space
;;   :ensure t
;;   :config
;;   (progn
;;     (evil-space-default-setup)))
#+end_src

** Leader

#+name: evil-leader
#+begin_src emacs-lisp
  (define-prefix-command 'my-leader-map)
  (evil-define-key 'normal global-map (kbd "SPC") 'my-leader-map)
  (evil-define-key 'visual global-map (kbd "SPC") 'my-leader-map)

  (defun define-keys (map key def &rest bindings)
    (while key
      (define-key map (read-kbd-macro key) def)
      (setq key (pop bindings)
            def (pop bindings))))

  (defun define-leader-keys (map prefix key def &rest bindings)
    (define-prefix-command  map)
    (define-key my-leader-map prefix map)
    (apply 'define-keys map key def bindings))
#+end_src

** main

#+name: evil-main
#+begin_src emacs-lisp
  (message "Start evil/main:::: %.2fs" (- (float-time) shit-load-time-start))

  ;;(global-surround-mode 1)
  ;;--------------------------------------------------
  ;; Make sure escape gets back to normal state and quits things.
  (add-hook 'help-mode-hook (lambda () (key-chord-define help-mode-map "jk" 'quit-window)))

  (key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
  (key-chord-define evil-visual-state-map "jk" 'evil-normal-state)
  (key-chord-define evil-emacs-state-map "jk" 'evil-normal-state)

  (key-chord-define minibuffer-local-map "jk" 'minibuffer-keyboard-quit)
  (key-chord-define minibuffer-local-ns-map "jk" 'minibuffer-keyboard-quit)
  (key-chord-define minibuffer-local-completion-map "jk" 'minibuffer-keyboard-quit)
  (key-chord-define minibuffer-local-must-match-map "jk" 'minibuffer-keyboard-quit)
  (key-chord-define minibuffer-local-isearch-map "jk" 'minibuffer-keyboard-quit)

  (key-chord-define minibuffer-local-map "jk" 'abort-recursive-edit)
  (key-chord-define minibuffer-local-ns-map "jk" 'abort-recursive-edit)
  (key-chord-define minibuffer-local-completion-map "jk" 'abort-recursive-edit)
  (key-chord-define minibuffer-local-must-match-map "jk" 'abort-recursive-edit)
  (key-chord-define minibuffer-local-isearch-map "jk" 'abort-recursive-edit)

  (key-chord-define isearch-mode-map "jk" 'abort-recursive-edit)
  (key-chord-define isearch-mode-map "jk" 'minibuffer-keyboard-quit)
  (key-chord-define isearch-mode-map "jk" 'isearch-cancel)

  (define-key evil-visual-state-map (kbd ">") 'djoyner/evil-shift-right-visual)
  (define-key evil-visual-state-map (kbd "<") 'djoyner/evil-shift-left-visual)

  (defun djoyner/evil-shift-left-visual ()
    (interactive)
    (evil-shift-left (region-beginning) (region-end))
    (evil-normal-state)
    (evil-visual-restore))

  (defun djoyner/evil-shift-right-visual ()
    (interactive)
    (evil-shift-right (region-beginning) (region-end))
    (evil-normal-state)
    (evil-visual-restore))
  ;;--------------------------------------------------
                                          ;(setq evil-snipe-auto-disable-substitute nil)
                                          ;(require 'evil-snipe)
                                          ;(global-evil-snipe-mode 1)

  ;;--------------------------------------------------
  (require 'evil-args)
  ;; bind evil-args text objects
  (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
  (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)

  ;; bind evil-forward/backward-args
  (define-key evil-normal-state-map "L" 'evil-forward-arg)
  (define-key evil-normal-state-map "H" 'evil-backward-arg)
  (define-key evil-motion-state-map "L" 'evil-forward-arg)
  (define-key evil-motion-state-map "H" 'evil-backward-arg)

  ;; bind evil-jump-out-args
  (define-key evil-normal-state-map "K" 'evil-jump-out-args)
  ;;--------------------------------------------------

  (loop for (mode . state) in '((inferior-emacs-lisp-mode . emacs)
                                (emms-playlist-mode . normal)
                                (emms-browser-mode . normal)
                                (nrepl-mode . insert)
                                (pylookup-mode . emacs)
                                (comint-mode . normal)
                                (shell-mode . insert)
                                (git-commit-mode . insert)
                                (git-rebase-mode . emacs)
                                (term-mode . emacs)
                                (help-mode . emacs)
                                (helm-grep-mode . emacs)
                                (grep-mode . emacs)
                                (bc-menu-mode . emacs)
                                (magit-branch-manager-mode . emacs)
                                (rdictcc-buffer-mode . emacs)
                                (dired-mode . emacs)
                                          ;(process-menu-mode . Emacs)
                                (wdired-mode . normal))
        do (evil-set-initial-state mode state))
                                          ;;--------------------------------------------------
  (evil-define-key 'visual global-map (kbd "v") 'er/expand-region)
  (evil-define-key 'visual global-map (kbd "<esc>") 'evil-normal-state)

  (global-set-key (kbd "C-h") 'evil-delete-backward-word)

  (advice-add 'evil-ex-search-next :after
              (lambda (&rest x) (evil-scroll-line-to-center (line-number-at-pos))))
  (advice-add 'evil-ex-search-previous :after
              (lambda (&rest x) (evil-scroll-line-to-center (line-number-at-pos))))
  (advice-add 'evil-scroll-up :after
              (lambda (&rest x) (evil-scroll-line-to-center (line-number-at-pos))))
  (advice-add 'evil-scroll-down :after
              (lambda (&rest x) (evil-scroll-line-to-center (line-number-at-pos))))

  (define-leader-keys 'global-map "f"
    "f" 'helm-find-files
    "p" 'helm-projectile-find-file)

  (define-key my-leader-map " " 'helm-M-x)
  (define-key global-map (kbd "C-x C-f") nil)

  (define-key my-leader-map "s" 'save-buffer)
  (define-key global-map (kbd "C-x C-s") nil)

  ;; (evil-define-key 'normal global-map " ji" 'helm-swoop)
  ;; (evil-define-key 'normal global-map " jl" 'my-helm-locate)
  ;; (evil-define-key 'normal global-map "f" 'helm-find-files)
  ;; (evil-define-key 'normal global-map " jj" 'helm-mini)
  ;; (evil-define-key 'normal global-map " jd" 'find-file-dev)
  ;; (evil-define-key 'normal global-map " ja" 'my-switch-to-other-buffer)
  ;; (evil-define-key 'normal global-map " jo" 'helm-occur)
  ;; (evil-define-key 'normal global-map " jg" 'helm-google)
  ;; (evil-define-key 'normal global-map " js" 'helm-surfraw)

  (defadvice evil-ex-search-next (after advice-for-evil-ex-search-next activate)
    (evil-scroll-line-to-center (line-number-at-pos)))

  (require 'evil-matchit)
  (global-evil-matchit-mode 1)

  (defadvice evil-search-next (after advice-for-evil-ex-search-next activate)
    (evil-scroll-line-to-center (line-number-at-pos)))

  (setq-default evil-cross-lines t)

  ;; Normal movement keys disabled in lieu of Evil mode
  ;; (global-set-key (kbd "C-b") nil)
  ;; (global-set-key (kbd "C-f") nil)
  ;; (global-set-key (kbd "C-n") nil)
  ;; (global-set-key (kbd "C-p") nil)
  ;; (global-set-key (kbd "C-k") nil)
  ;; (global-set-key (kbd "C-a") nil)
  ;; (global-set-key (kbd "M-<") nil)
  ;; (global-set-key (kbd "M->") nil)

  ;; Remove set mark
  ;; (global-set-key (kbd "C-SPC") nil)

  (define-keys my-leader-map
    ";" 'helm-M-x
    " " 'ace-jump-mode
    "k" 'ace-jump-char-mode
    "l" 'ace-jump-line-mode)

  ;; (define-leader-keys 'x-leader-map "x"
  ;;   "h" 'mark-whole-buffer
  ;;   "e" 'eval-defun
  ;;   "w" 'eval-defun-and-replace
  ;;   "r" 'rename-current-buffer-file)

  (evil-define-key 'normal global-map (kbd "C-j") 'evil-scroll-page-down)
  (evil-define-key 'normal global-map (kbd "C-k") 'evil-scroll-page-up)

  ;;        (setq expand-region-contract-fast-key "z")
  ;;       (evil-leader/set-key "xx" 'er/expand-region)

  ;; (evil-leader/set-key
  ;;  "k" 'kill-buffer)

  ;; (global-evil-leader-mode)

  ;; change mode-line color by evil state
  (lexical-let ((default-color (cons (face-background 'mode-line)
                                     (face-foreground 'mode-line))))
    (add-hook 'post-command-hook
              (lambda ()
                (let ((color (cond ((minibufferp) default-color)
                                   ((evil-insert-state-p) '("#000000" . "#f5666d"))
                                   ((evil-emacs-state-p)  '("#000000" . "#9cd4fc"))
                                   ((buffer-modified-p)   '("#000000" . "#a3beff"))
                                   (t default-color))))
                  (set-face-background 'mode-line (car color))
                  (set-face-foreground 'mode-line (cdr color))))))

                                          ;(use-package evil-visual-replace
                                          ;  :ensure t)
                                          ;(evil-visual-replace-visual-bindings)

  ;; (evil-define-operator evil-destroy (beg end type register yank-handler)
  ;;   (evil-delete beg end type ?_ yank-handler))

  ;; (defun whitespace-only-p (string)
  ;;   (equal "" (replace-regexp-in-string "[ \t\n]" "" string)))

  ;; (defadvice evil-delete (around evil-delete-yank activate)
  ;;   (if (whitespace-only-p (buffer-substring beg end))
  ;;           (evil-destroy beg end type register yank-handler)
  ;;         ad-do-it))

  ;;(global-evil-matchit-mode nil)

                                          ;(define-key evil-normal-state-map "c" nil)
                                          ;(define-key evil-motion-state-map "cu" 'universal-argument)

                                          ;(key-chord-define evil-insert-state-map "jk" 'evil-normal-state)

#+end_src

** Magnars integration
#+name: evil-integration
#+begin_src emacs-lisp
  ;;;; Integrate Evil with other modules

  ;; (require 'evil-core)
  ;; (require 'evil-motions)
  ;; (require 'evil-repeat)

  (mapc 'evil-declare-motion evil-motions)
  (mapc 'evil-declare-not-repeat
        '(digit-argument
          negative-argument
          save-buffer
          universal-argument
          universal-argument-minus
          universal-argument-other-key))
  (mapc 'evil-declare-change-repeat
        '(dabbrev-expand
          hippie-expand))
  (mapc 'evil-declare-abort-repeat
        '(eval-expression
          execute-extended-command
          compile
          recompile))

  (dolist (map evil-overriding-maps)
    (eval-after-load (cdr map)
      `(evil-make-overriding-map ,(car map))))

  (dolist (map evil-intercept-maps)
    (eval-after-load (cdr map)
      `(evil-make-intercept-map ,(car map))))

  ;;; Buffer-menu

  (evil-declare-key 'motion Buffer-menu-mode-map
    "h" 'evil-backward-char
    "j" 'evil-next-line
    "k" 'evil-previous-line
    "l" 'evil-forward-char)

  ;;; Dired

  (eval-after-load 'dired
    '(progn
       ;; use the standard Dired bindings as a base
       (evil-make-overriding-map dired-mode-map 'normal t)
       (evil-define-key 'normal dired-mode-map
         "h" 'evil-backward-char
         "j" 'evil-next-line
         "k" 'evil-previous-line
         "l" 'evil-forward-char
         "J" 'dired-goto-file       ; "j"
         "K" 'dired-do-kill-lines   ; "k"
         "r" 'dired-do-redisplay))) ; "l"

  (eval-after-load 'wdired
    '(progn
       (add-hook 'wdired-mode-hook 'evil-change-to-initial-state)
       (defadvice wdired-change-to-dired-mode (after evil activate)
         (evil-change-to-initial-state nil t))))

  ;;; ELP

  (eval-after-load 'elp
    '(defadvice elp-results (after evil activate)
       (evil-motion-state)))

  ;;; Folding

  (eval-after-load 'hideshow
    '(progn
       (defun evil-za ()
         (interactive)
         (hs-toggle-hiding)
         (hs-hide-level evil-fold-level))
       (defun evil-hs-setup ()
         (define-key evil-normal-state-map "za" 'evil-za)
         (define-key evil-normal-state-map "zm" 'hs-hide-all)
         (define-key evil-normal-state-map "zr" 'hs-show-all)
         (define-key evil-normal-state-map "zo" 'hs-show-block)
         (define-key evil-normal-state-map "zc" 'hs-hide-block))
       (add-hook 'hs-minor-mode-hook 'evil-hs-setup)))

  ;; load goto-chg.el if available
  (condition-case nil
      (require 'goto-chg)
    (error nil))

  ;;; Info

  (evil-declare-key 'motion Info-mode-map
    (kbd "\M-h") 'Info-help   ; "h"
    "\C-t" 'Info-history-back ; "l"
    "\C-o" 'Info-history-back
    " " 'Info-scroll-up
    (kbd "RET") 'Info-follow-nearest-node
    "\C-]" 'Info-follow-nearest-node
    (kbd "DEL") 'Info-scroll-down)

  ;;; Parentheses

  ;; (defadvice show-paren-function (around evil)
  ;;   "Match parentheses in Normal state."
  ;;   (if (or (evil-insert-state-p)
  ;;           (evil-replace-state-p)
  ;;           (evil-emacs-state-p))
  ;;       ad-do-it
  ;;     (let ((pos (point)) syntax)
  ;;       (setq pos
  ;;             (catch 'end
  ;;               (dotimes (var (1+ (* 2 evil-show-paren-range)))
  ;;                 (if (evenp var)
  ;;                     (setq pos (+ pos var))
  ;;                   (setq pos (- pos var)))
  ;;                 (setq syntax (syntax-class (syntax-after pos)))
  ;;                 (cond
  ;;                  ((eq syntax 4)
  ;;                   (throw 'end pos))
  ;;                  ((eq syntax 5)
  ;;                   (throw 'end (1+ pos)))))))
  ;;       (if pos
  ;;           (save-excursion
  ;;             (goto-char pos)
  ;;             ad-do-it)
  ;;         ;; prevent the preceding pair from being highlighted
  ;;         (when (overlayp show-paren-overlay)
  ;;           (delete-overlay show-paren-overlay))
  ;;         (when (overlayp show-paren-overlay-1)
  ;;           (delete-overlay show-paren-overlay-1))))))

  ;;; Speedbar

  (evil-declare-key 'motion speedbar-key-map
    "h" 'backward-char
    "j" 'speedbar-next
    "k" 'speedbar-prev
    "l" 'forward-char
    "i" 'speedbar-item-info
    "r" 'speedbar-refresh
    "u" 'speedbar-up-directory
    "o" 'speedbar-toggle-line-expansion
    (kbd "RET") 'speedbar-edit-line)

  ;;; Undo tree visualizer

  ;; (defadvice undo-tree-visualize (after evil activate)
  ;;   "Initialize Evil in the visualization buffer."
  ;;   (when evil-local-mode
  ;;     (evil-initialize-state)))

  ;; (when (boundp 'undo-tree-visualizer-map)
  ;;   (define-key undo-tree-visualizer-map [remap evil-backward-char]
  ;;     'undo-tree-visualize-switch-branch-left)
  ;;   (define-key undo-tree-visualizer-map [remap evil-forward-char]
  ;;     'undo-tree-visualize-switch-branch-right)
  ;;   (define-key undo-tree-visualizer-map [remap evil-next-line]
  ;;     'undo-tree-visualize-redo)
  ;;   (define-key undo-tree-visualizer-map [remap evil-previous-line]
  ;;     'undo-tree-visualize-undo))

  ;;; Auto-complete
  (eval-after-load 'auto-complete
    '(progn
       (evil-set-command-properties 'ac-complete :repeat 'evil-ac-repeat)
       (evil-set-command-properties 'ac-expand :repeat 'evil-ac-repeat)
       (evil-set-command-properties 'ac-next :repeat 'ignore)
       (evil-set-command-properties 'ac-previous :repeat 'ignore)

       (defvar evil-ac-prefix-len nil
         "The length of the prefix of the current item to be completed.")

       (defun evil-ac-repeat (flag)
         "Record the changes for auto-completion."
         (cond
          ((eq flag 'pre)
           (setq evil-ac-prefix-len (length ac-prefix))
           (evil-repeat-start-record-changes))
          ((eq flag 'post)
           ;; Add change to remove the prefix
           (evil-repeat-record-change (- evil-ac-prefix-len)
                                      ""
                                      evil-ac-prefix-len)
           ;; Add change to insert the full completed text
           (evil-repeat-record-change
            (- evil-ac-prefix-len)
            (buffer-substring-no-properties (- evil-repeat-pos
                                               evil-ac-prefix-len)
                                            (point))
            0)
           ;; Finish repeation
           (evil-repeat-finish-record-changes))))))

  ;; Eval last sexp
  (defadvice preceding-sexp (around evil activate)
    "In normal-state, last sexp ends at point."
    (if (evil-normal-state-p)
        (save-excursion
          (unless (or (eobp) (eolp)) (forward-char))
          ad-do-it)
      ad-do-it))

  (defadvice pp-last-sexp (around evil activate)
    "In normal-state, last sexp ends at point."
    (if (evil-normal-state-p)
        (save-excursion
          (unless (or (eobp) (eolp)) (forward-char))
          ad-do-it)
      ad-do-it))


  ;;; evil-integration.el ends here
#+end_src

** Motions

#+name: evil-motions
#+begin_src emacs-lisp
(message "Start Evil/Motions:::: %.2fs" (- (float-time) shit-load-time-start))

(evil-define-motion evil-little-word (count)
  :type exclusive
  (let* ((case-fold-search nil)
                 (count (if count count 1)))
        (while (> count 0)
          (forward-char)
          (search-forward-regexp "[_A-Z]\\|\\W" nil t)
          (backward-char)
          (decf count))))

(define-key evil-operator-state-map (kbd "lw") 'evil-little-word)
#+end_src

** operators

#+name: evil-operators
#+begin_src emacs-lisp
(message "Start evil/operators:::: %.2fs" (- (float-time) shit-load-time-start))

(evil-define-operator evil-destroy (beg end type register yank-handler)
  (evil-delete beg end type ?_ yank-handler))

;; (evil-define-operator evil-inflect-singularize (beg end type register yank-handler)
;;   (cake-singularize (buffer-substring beg end)))
;; (define-key evil-visual-state-map "gs" 'evil-inflect-singularize)

(evil-define-operator evil-inflect-snake (beg end type register yank-handler)
  (evil-yank beg end type register yank-handler)
  (evil-destroy beg end type register yank-handler)
  (insert (cake-snake (car kill-ring))))

(define-key evil-visual-state-map "gS" 'evil-inflect-snake)

(evil-define-operator evil-destroy-replace (beg end type register yank-handler)
  (evil-destroy beg end type register yank-handler)
  (evil-paste-before 1 register))

(defmacro define-and-bind-text-object (key start-regex end-regex)
  (let ((inner-name (make-symbol "inner-name"))
        (outer-name (make-symbol "outer-name")))
    `(progn
       (evil-define-text-object ,inner-name (count &optional beg end type)
         (evil-select-paren ,start-regex ,end-regex beg end type count nil))
       (evil-define-text-object ,outer-name (count &optional beg end type)
         (evil-select-paren ,start-regex ,end-regex beg end type count t))
       (define-key evil-inner-text-objects-map ,key (quote ,inner-name))
       (define-key evil-outer-text-objects-map ,key (quote ,outer-name)))))


;; create "il"/"al" (inside/around) line text objects:
(define-and-bind-text-object "l" "^\\s-*" "\\s-*$")
;; create "ie"/"ae" (inside/around) entire buffer text objects:
(define-and-bind-text-object "e" "\\`\\s-*" "\\s-*\\'")

#+end_src

** functions

#+name: evil-functions
#+begin_src emacs-lisp
(message "Start evil/functions:::: %.2fs" (- (float-time) shit-load-time-start))

(defun vilify-key (map shift-key key command)
  (let ((binding (lookup-key map shift-key)))
    (if binding
        (progn
          (define-key map (kbd (concat "s-" key)) binding)
          (define-key map key command))
      (progn
        (define-key map shift-key binding)
        (define-key map key command)))))

(defun vilify (map)
  (vilify-key map "J" "j" 'next-line)
  (vilify-key map "K" "k" 'previous-line)
  (vilify-key map "L" "l" 'forward-char)
  (vilify-key map "h" "H" 'backward-char)
  (vilify-key map "/" "?" 'evil-search-forward)
  (vilify-key map "n" "N" (lookup-key evil-motion-state-map "n"))
  (vilify-key map "v" "V" 'evil-visual-char)
  (vilify-key map "V" "v" 'evil-visual-line))

(define-key evil-visual-state-map ">" (lambda ()
    (interactive)
    (when (> (mark) (point))
        (exchange-point-and-mark))
    (evil-normal-state)
    (evil-shift-right (mark) (point))
    (evil-visual-restore)))

(define-key evil-visual-state-map "<" (lambda ()
    (interactive)
    (when (> (mark) (point))
        (exchange-point-and-mark))
    (evil-normal-state)
    (evil-shift-left (mark) (point))
    (evil-visual-restore)))
#+end_src

** advice

#+name: evil-advice
#+begin_src emacs-lisp
(message "Start evil/advice:::: %.2fs" (- (float-time) shit-load-time-start))

(defadvice evil-delete (around evil-delete-yank activate)
  (if (s-whitespace? (buffer-substring beg end))
          (evil-destroy beg end type register yank-handler)
        ad-do-it))
#+end_src

* helm
** Notes
*** TODO Find a better way to run the next and previous line funcs repeatedly.
** Main

#+begin_src emacs-lisp :noweb yes :tangle ~/.emacs.d/init.el
  (message "Helm:::: %.2fs" (- (float-time) shit-load-time-start))

  (use-package helm
    :diminish helm-mode "h"
    :ensure t
    :commands (my-helm-locate
               helm-find-files)
    :bind (("M-x" . helm-M-x)
           ("M-y" . helm-show-kill-ring))
    :config (progn
              (message "helm-config")
              <<helm-config>>
              ))
#+end_src

** Config

#+name: helm-config
#+begin_src emacs-lisp :noweb yes
  (setq helm-input-idle-delay 0)
  (setq helm-exit-idle-delay 0)
  (setq helm-split-window-in-side-p t)
  (setq helm-google-search-function 'helm-google-api-search)
  (setq helm-echo-input-in-header-line t)
  (setq helm-quick-update t
	helm-M-x-requires-pattern nil
	helm-ff-skip-boring-files t)
  (setq helm-mini-default-sources
	'(helm-source-buffers-list
	  helm-source-projectile-files-list
	  helm-source-recentf
	  helm-source-buffer-not-found))

  ;; Would be nice!
  ;; (general-define-key :keymaps '(helm-map helm-find-files-map helm-generic-files-map helm-read-file-map)
  ;;                     (general-chord "jk") 'helm-keyboard-quit
  ;;                     (general-chord "kj") 'helm-keyboard-quit)
  ;; (key-chord-define helm-map "fd" 'helm-keyboard-quit)
  ;; (key-chord-define helm-find-files-map "fd" 'helm-keyboard-quit)

  ;; (defun spacemacs//hide-cursor-in-helm-buffer ()
  ;;   "Hide the cursor in helm buffers."
  ;;   (with-helm-buffer
  ;;     (setq cursor-in-non-selected-windows nil)))
  ;; (add-hook 'helm-after-initialize-hook
  ;;           'spacemacs//hide-cursor-in-helm-buffer)

  ;; (define-key helm-map (kbd "C-S-j") 'helm-next-source)
  ;; (define-key helm-map (kbd "C-S-h") 'describe-key)

  ;; (use-package helm-descbinds
  ;;   :defer t
  ;;   :bind (("C-h b" . helm-descbinds)
  ;;          ("C-h w" . helm-descbinds)))

  ;; (defun my-insert-file-name (filename &optional args)
  ;;   "Insert name of file FILENAME into buffer after point.

  ;;  Prefixed with \\[universal-argument], expand the file name to
  ;;  its fully canocalized path. See `expand-file-name'.

  ;;  Prefixed with \\[negative-argument], use relative path to file
  ;;  name from current directory, `default-directory'. See
  ;;  `file-relative-name'.

  ;;  The default with no prefix is to insert the file name exactly as
  ;;  it appears in the minibuffer prompt."
  ;;   ;; Based on insert-file in Emacs -- ashawley 20080926
  ;;   (interactive "*fInsert file name: \nP")
  ;;   (cond ((eq '- args)
  ;;          (insert (expand-file-name filename)))
  ;;         ((not (null args))
  ;;          (insert (filename)))
  ;;         (t
  ;;          (insert (file-relative-name filename)))))

  ;; bind it
  ;; (global-set-key (kbd "C-c f i") 'my-insert-file-name)

  ;; (use-package helm-descbinds
  ;;   :ensure t)
  ;; (helm-descbinds-mode)
  ;; (require 'helm-w3m)
  ;; (use-package helm-swoop
  ;;   :ensure t)
  ;; (use-package helm-org)
  ;; (use-package helm-eshell)
  ;; (use-package helm-config)
  ;; (use-package helm-files)
  ;; (use-package helm-ag
  ;;   :ensure t)
  ;; (use-package wgrep-helm
  ;;   :ensure t)
  ;; (after 'mu4e
  ;;   (use-package helm-mu
  ;;     :ensure t))

  (helm-mode 1)

  (after 'hydra
    (defhydra helm-like-unite ()
      "vim movement"
      ("?" helm-help "help")
      ("<escape>" keyboard-escape-quit "exit")
      ("<SPC>" helm-toggle-visible-mark "mark")
      ("a" helm-toggle-all-marks "(un)mark all")
      ;; not sure if there's a better way to do this
      ("/" (lambda ()
	     (interactive)
	     (execute-kbd-macro [?\C-s]))
       "search")
      ("C-j" helm-next-page "page down")
      ("C-k" helm-previous-page "page up")
      ("l" helm-execute-persistent-action "persistant action")
      ("v" helm-execute-persistent-action)
      ("g" helm-beginning-of-buffer "top")
      ("G" helm-end-of-buffer "bottom")
      ("j" helm-next-line "down")
      ("k" helm-previous-line "up")
      ("i" nil "cancel"))

    (key-chord-define helm-map "fd" 'helm-like-unite/body))

  ;; (defun my-helm-show-kill-ring ()
  ;;   "Preconfigured `helm' for `kill-ring'.
  ;; It is drop-in replacement of `yank-pop'.

  ;; First call open the kill-ring browser, next calls move to next line."
  ;;   (interactive)
  ;;   (helm :sources my-helm-source-kill-ring
  ;;         :buffer "*helm kill ring*"
  ;;         :resume 'noresume
  ;;         :allow-nest t))
  ;; (defvar my-helm-source-kill-ring
  ;;   `((name . "Kill Ring")
  ;;     (init . (lambda () (helm-attrset 'last-command last-command)))
  ;;     (candidates . helm-kill-ring-candidates)
  ;;     (filtered-candidate-transformer helm-kill-ring-transformer)
  ;;     (action . (("Yank" . my-helm-kill-ring-action)
  ;;                ("Delete" . (lambda (candidate)
  ;;                              (cl-loop for cand in (helm-marked-candidates)
  ;;                                    do (setq kill-ring
  ;;                                             (delete cand kill-ring)))))))
  ;;     (persistent-action . (lambda (_candidate) (ignore)))
  ;;     (persistent-help . "DoNothing")
  ;;     (keymap . ,helm-kill-ring-map)
  ;;     (last-command)
  ;;     (migemo)
  ;;     (multiline))
  ;;   "Source for browse and insert contents of kill-ring.")
  ;; (defun my-helm-kill-ring-action (str)
  ;;   "Insert STR in `kill-ring' and set STR to the head.
  ;; If this action is executed just after `yank',
  ;; replace with STR as yanked string."
  ;;   (with-helm-current-buffer
  ;;     (setq kill-ring (delete str kill-ring))
  ;;     (if (not (eq (helm-attr 'last-command helm-source-kill-ring) 'yank))
  ;;         (run-with-timer 0.01 nil `(lambda () (insert-for-yank ,str)))
  ;;       ;; from `yank-pop'
  ;;       (let ((inhibit-read-only t)
  ;;             (before (< (point) (mark t))))
  ;;         (if before
  ;;             (funcall (or yank-undo-function 'delete-region) (point) (mark t))
  ;;           (funcall (or yank-undo-function 'delete-region) (mark t) (point)))
  ;;         (setq yank-undo-function nil)
  ;;         (set-marker (mark-marker) (point) helm-current-buffer)
  ;;         (run-with-timer 0.01 nil `(lambda () (progn
  ;;                                                (message "foo")
  ;;                                                (evil-forward-char)
  ;;                                                (insert-for-yank ,str)
  ;;                                                (evil-backward-char))))
  ;;         ;; Set the window start back where it was in the yank command,
  ;;         ;; if possible.
  ;;         (set-window-start (selected-window) yank-window-start t)
  ;;         (when before
  ;;           ;; This is like exchange-point-and-mark, but doesn't activate the mark.
  ;;           ;; It is cleaner to avoid activation, even though the command
  ;;           ;; loop would deactivate the mark because we inserted text.
  ;;           (goto-char (prog1 (mark t)
  ;;                        (set-marker (mark-marker) (point) helm-current-buffer))))))
  ;;     (kill-new str)))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; helm mu

  ;; (defvar my-helm-source-mu-contacts
  ;;   '((name . "Search contacts with mu")
  ;;     (candidates . helm-mu-contacts-init)
  ;;     (filtered-candidate-transformer . helm-mu-contacts-transformer)
  ;;     (nohighlight)
  ;;     (action . (("insert" . my-helm-mu-insert-address)
  ;;                ("Compose email addressed to this contact" . helm-mu-compose-mail)))))

  ;; (defun my-helm-mu-insert-address (candidate)
  ;;   "Compose a new email directed to the selected contacts."
  ;;   (let* ((cand (split-string candidate "\t"))
  ;;          (name (cadr cand))
  ;;          (address (car cand)))
  ;;     (insert (concat name " <" address ">"))))

  ;; (defun my-helm-mu-contacts ()
  ;;   "Search for contacts."
  ;;   (interactive)
  ;;   (helm :sources 'my-helm-source-mu-contacts
  ;;         :buffer "*helm mu contacts*"))

  ;; end helm mu
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defun my-switch-to-other-buffer ()
    "Switch to other buffer"
    (interactive)
    (switch-to-buffer (other-buffer)))


  (defun my-helm-mini ()
    (interactive)
    (require 'helm-files)
    (helm-other-buffer '(helm-source-buffers-list
			 helm-source-recentf
			 helm-source-buffer-not-found
			 )
		       "*helm mini*"))

  (defun my-helm-locate ()
    (interactive)
    (require 'helm-files)
    (helm-other-buffer '(helm-source-locate)
		       "*helm locate*"))

  ;; (defun find-file-dev ()
  ;;   (interactive)
  ;;   (helm-find-files-1 "/ssh:dev|ssh:root@development:/" ))

  ;; (defun find-file-root-hupu-linode()
  ;;   (interactive)
  ;;   (helm-find-files-1 "/ssh:donavan@hupu-linode|ssh:root@hupu-linode:/" ))

  (defun my-helm-define-key (binding command)
    (interactive)
    (define-key helm-map (kbd binding) command)
    (define-key helm-find-files-map (kbd binding) command))

  (define-key global-map (kbd "M-m") 'helm-all-mark-rings)

  (my-helm-define-key "C-." nil)
  (my-helm-define-key "C-h" nil)

  (my-helm-define-key "C-h" 'backward-kill-word)
  (my-helm-define-key "C-j" 'helm-next-line)
  (my-helm-define-key "C-k" 'helm-previous-line)
  (my-helm-define-key "C-l" 'helm-execute-persistent-action)

  (my-helm-define-key "M-k"
		      (lambda ()
			(interactive)
			(helm-previous-line)(helm-previous-line)(helm-previous-line)(helm-previous-line)(helm-previous-line)))

  (my-helm-define-key "M-j"
		      (lambda ()
			(interactive)
			(helm-next-line)(helm-next-line)(helm-next-line)(helm-next-line)(helm-next-line)))



#+end_src

** helm-mu

#+begin_src emacs-lisp
;;; helm-mu.el --- Helm sources for searching emails and contacts

;; Copyright (C) 2013 Titus von der Malsburg <malsburg@posteo.de>

;; Author: Titus von der Malsburg <malsburg@posteo.de>
;; Maintainer: Titus von der Malsburg <malsburg@posteo.de>
;; URL: https://github.com/emacs-helm/helm-mu
;; Version: 1.0.0
;; Package-Requires: ((helm "1.5.5"))

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Helm sources for searching emails and contacts using mu and
;; mu4e. Mu is an indexer for maildirs and mu4e is a mutt-like MUA for
;; Emacs build on top of mu. Mu is highly efficient making it possible
;; to get instant results even for huge maildirs. It also provides
;; search operators similar to Google mail, e.g:
;;
;;     from:Peter to:Anne flag:attach search term

;;; Install:

;; Helm-mu requires a fully configured mu4e setup and the latest
;; version of mu (version from Sept 27 2013 or later).
;;
;; Copy helm-mu.el to a directory in your load-path.  And add the
;; following to your init file:
;;
;;     (require 'helm-mu)
;;
;; Alternatively, you can use the autoload facility:
;;
;;     (autoload 'helm-mu "helm-mu" "" t)
;;     (autoload 'helm-mu-contacts "helm-mu" "" t)
;;
;; To run mu, helm-mu uses the function `start-process-shell-command'.
;; It assumes that the shell called by that function is compatible
;; with the Bourne shell (e.g. bash).  If your shell is incompatible,
;; the mu command may not work.
;;
;; GNU sed is used to do some filtering of the results returned by
;; mu.  GNU sed is standard on Linux but OSX users may have to install
;; it since the pre-installed BSD sed has different command line
;; options.
;;
;; Some things that can be configured:
;;
;; - `helm-mu-default-search-string'
;; - `helm-mu-contacts-name-colwidth'
;; - `helm-mu-contacts-name-replace'
;; - `helm-mu-contacts-after'
;; - `helm-mu-contacts-personal'
;;
;; Consult the documentation in Emacs or the source code below for
;; explanations of these variables.

;;; Usage:

;; To search for emails use `helm-mu'.  When you would like to read an
;; email without finishing the helm session, you can select the email
;; and press Ctrl-z.  This will split the screen horizontally and show
;; the email in the new window while keeping the search results in the
;; other.  Alternatively, you can open the email using the enter key
;; and return to the helm session using the command `helm-resume'.
;;
;; To search for contacts use `helm-mu-contacts'.  Note that search
;; terms are interpreted differently by `helm-mu-contacts' than by
;; `helm-mu'.  `helm-mu' assumes that the search terms are complete
;; words, i.e., that they are surrounded by white spaces or
;; punctuation.  So if you search for "jo" it will only return emails
;; in which "jo" occurs as a word.  In contrast to that,
;; `helm-mu-contacts' will return all contacts in which "jo" occurs as
;; a substring.  `helm-mu-contacts' uses the grep tool for
;; searching.  That means that any regular expression supported by
;; grep can be used when searching for contacts.

;;; Code:

(require 'cl-lib)
(require 'helm)
(require 'mu4e)

(defgroup helm-mu nil
  "Helm completion for mu."
  :group 'mu4e)

(defcustom helm-mu-default-search-string ""
  "A default search string for new searches. By default mu
searches all maildirs.  That includes mails from trash and drafts
folders.  The default search string can be used to restrict the
search to only emails in a specific maildir.  For instance, in
order to restrict the search to the inbox, the following can be
used: maildir:/INBOX"
  :group 'helm-mu
  :type  'string)

(defcustom helm-mu-contacts-name-colwidth 22
  "The width of the column showing names when searching contacts."
  :group 'helm-mu
  :type  'integer)

(defcustom helm-mu-contacts-name-replace '("[\"']" "")
  "This can be used for basic transformations of the names.  The
default value removes quotation marks."
  :group 'helm-mu
  :type  '(list string string))

(defcustom helm-mu-contacts-after "01-Jan-1970 00:00:00"
  "Only show contacts from mails received after that time."
  :group 'helm-mu
  :type  'integer)

(defcustom helm-mu-contacts-personal nil
  "If non-nil, only show addresses seen in messages where one of
'my' e-mail addresses was seen in one of the address fields; this
is to exclude addresses only seen in mailing-list messages. See
the --my-address parameter in mu index."
  :group 'helm-mu
  :type  'integer)

(easy-menu-add-item nil '("Tools" "Helm" "Tools") ["Mu" helm-mu t])
(easy-menu-add-item nil '("Tools" "Helm" "Tools") ["Mu contacts" helm-mu-contacts t])


(defface helm-mu-contacts-name-face
  '((t :foreground "black"))
  "Face for names in contacts list."
  :group 'helm-mu-faces)

(defface helm-mu-contacts-address-face
  '((t :foreground "dim gray"))
  "Face for email addresses in contacts list."
  :group 'helm-mu-faces)


(defvar helm-mu-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map helm-map)
    (define-key map (kbd "C-c C-c") 'helm-mu-open-headers-view)
    (define-key map (kbd "S-<return>") 'helm-mu-open-headers-view)
    map)
  "Keymap used in helm-mu.")


(defvar helm-source-mu
  '((name . "Search email with mu")
    (candidates-process . helm-mu-init)
    (candidate-transformer . (helm-mu-candidate-parser
                              helm-mu-candidates-formatter))
    (delayed)
    (no-matchplugin)
    (nohighlight)
    (requires-pattern . 3)
    (persistent-action . helm-mu-persistent-action)
    (action . (("Display message in mu4e" . helm-mu-display-email)))))

(defvar helm-source-mu-contacts
  '((name . "Search contacts with mu")
    (candidates . helm-mu-contacts-init)
    (filtered-candidate-transformer . helm-mu-contacts-transformer)
    (nohighlight)
    (action . (("Compose email addressed to this contact" . helm-mu-compose-mail)))))


(defun helm-mu-init ()
  "Initialize async mu process for `helm-source-mu'."
  (let ((process-connection-type nil)
        (maxnum (helm-candidate-number-limit helm-source-mu))
        (mucmd "mu find -f $'i\td\tf\tt\ts' --sortfield=d --maxnum=%d --reverse --format=sexp ")
        (sedcmd "sed -e ':a;N;$!ba;s/\\n\\(\\t\\|\\()\\)\\)/ \\2/g'"))
    (prog1
      (start-process-shell-command "helm-mu" helm-buffer
        (concat (format mucmd maxnum)
                (mapconcat 'shell-quote-argument
                           (split-string helm-pattern " ")
                           " ")
                 " | " sedcmd))
      (set-process-sentinel
        (get-buffer-process helm-buffer)
        #'(lambda (process event)
            (if (string= event "finished\n")
                (with-helm-window
                  (setq mode-line-format
                        '(" " mode-line-buffer-identification " "
                          (line-number-mode "%l") " "
                          (:eval (propertize
                                  (format "[Mu Process Finish- (%s results)]"
                                          (max (1- (count-lines
                                                    (point-min) (point-max))) 0))
                                  'face 'helm-grep-finish))))
                  (force-mode-line-update))
                (helm-log "Error: Mu %s"
                          (replace-regexp-in-string "\n" "" event))))))))

(defun helm-mu-contacts-init ()
  "Retrieves contacts from mu."
  (let ((cmd (concat
              "mu cfind --format=mutt-ab"
              (if helm-mu-contacts-personal " --personal" "")
              (format
                " --after=%d"
                (truncate (float-time (date-to-time helm-mu-contacts-after)))))))
    (cdr (split-string (shell-command-to-string cmd) "\n"))))


(defun helm-mu-candidate-parser (candidates)
  "Parses the sexps obtained from mu find."
  (cl-loop for i in candidates
        if (string= i "mu: no matches for search expression")
          collect i
        else
          collect (car (read-from-string i))))

;; The following function recyles code from
;; mu4e~headers-header-handler in order to achieve the same formatting
;; as used in mu4e-headers-view.
(defun helm-mu-candidate-formatter (candidate)
  "Formats a candidate to look like entries in mu4e headers view."
  (let ((line " "))
    (dolist (f-w mu4e-headers-fields)
      (let ((field (car f-w))
            (width (cdr f-w))
            (val (mu4e-message-field candidate (car f-w))) (str))
        (setq str
          (case field
            (:subject
              (concat
                (mu4e~headers-thread-prefix (mu4e-message-field candidate :thread))
                val))
            ((:maildir :path) val)
            ((:to :from :cc :bcc) (mu4e~headers-contact-str val))
            (:from-or-to (mu4e~headers-from-or-to candidate))
            (:date (format-time-string mu4e-headers-date-format val))
            (:mailing-list (mu4e~headers-mailing-list val))
            (:human-date (mu4e~headers-human-date candidate))
            (:flags (propertize (mu4e~headers-flags-str val)
                      'help-echo (format "%S" val)))
            (:tags (propertize (mapconcat 'identity val ", ")))
            (:size (mu4e-display-size val))
            (t (mu4e-error "Unsupported header field (%S)" field))))
        (when str
          (setq line (concat line
              (if (not width) str
                (truncate-string-to-width str width 0 ?\s t)) " ")))))
    (propertize line 'face
      (let ((flags (mu4e-message-field candidate :flags)))
        (cond
          ((memq 'trashed flags) 'mu4e-trashed-face)
          ((memq 'draft flags)   'mu4e-draft-face)
          ((or
             (memq 'unread flags)
             (memq 'new flags))  'mu4e-unread-face)
          ((memq 'flagged flags) 'mu4e-flagged-face)
          ((memq 'replied flags) 'mu4e-replied-face)
          ((memq 'passed flags)  'mu4e-forwarded-face)
          (t                     'mu4e-header-face))))))

(defun helm-mu-candidates-formatter (candidates)
  "Formats the candidates to look like the entries in mu4e headers view."
  (if (equal candidates '("mu: no matches for search expression"))
      (list (propertize (car candidates) 'face 'mu4e-system-face))
    (cl-loop for i in candidates
          for width = (save-excursion (with-helm-window (window-width)))
          for line = (helm-mu-candidate-formatter i)
          collect (cons (truncate-string-to-width line width) i))))

(defun helm-mu-contacts-transformer (candidates source)
  "Formats the contacts to display in two columns, name and
address.  The name column has a predefined width."
  (cl-loop for i in candidates
        for contact = (split-string i "\t")
        for name = (replace-regexp-in-string
                     (car helm-mu-contacts-name-replace)
                     (cadr helm-mu-contacts-name-replace)
                     (cadr contact))
        for address = (car contact)
        for width = (save-excursion (with-helm-window (window-width)))
        collect
        (cons (concat
                (propertize
                  (truncate-string-to-width
                    name helm-mu-contacts-name-colwidth 0 ?\s)
                  'face 'helm-mu-contacts-name-face)
                " "
                (propertize
                  (truncate-string-to-width
                    address (- width helm-mu-contacts-name-colwidth 1) 0 ?\s)
                  'face 'helm-mu-contacts-address-face))
              i)))


(defun helm-mu-open-headers-view ()
  "Open current helm search in mu4e-headers-view."
  (interactive)
  (helm-run-after-quit 'mu4e-headers-search helm-pattern))

(defun helm-mu-display-email (candidate)
  "Open an email using mu4e."
  (mu4e-view-message-with-msgid (plist-get candidate :message-id)))

(defun helm-mu-compose-mail (candidate)
  "Compose a new email directed to the selected contacts."
  (let* ((cand (split-string candidate "\t"))
         (name (cadr cand))
         (address (car cand)))
    (mu4e~compose-mail (concat name " <" address ">"))))

(defun helm-mu-persistent-action (candidate)
  (save-selected-window
    (helm-mu-display-email candidate))
  ;; Redisplay.
  (sit-for 0.1))


;;;###autoload
(defun helm-mu ()
  "Search for emails.  If started in mu4e-headers-view, the
current query will be used to initialize the search.  Otherwise
`helm-mu-default-search-string' will be used."
  (interactive)
  (let ((input (if (eq major-mode 'mu4e-headers-mode)
                   (mu4e-last-query)
                 (concat helm-mu-default-search-string " "))))
    (helm :sources 'helm-source-mu
          :buffer "*helm mu*"
          :full-frame t
          :keymap helm-mu-map
          :input input
          :candidate-number-limit 500)))

;;;###autoload
(defun helm-mu-contacts ()
  "Search for contacts."
  (interactive)
  (helm :sources 'helm-source-mu-contacts
        :buffer "*helm mu contacts*"))

(provide 'helm-mu)

;; Local Variables:
;; byte-compile-warnings: (not cl-functions obsolete)
;; coding: utf-8
;; indent-tabs-mode: nil
;; End:

;;; helm-mu.el ends here

#+end_src

* magit

#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/init.el
(use-package magit
  :ensure t
  :defer t
  :general
  (leader-define
    "g" 'magit-status)
  (:states 'normal
           :keymaps 'magit-status-mode-map
           "TAB" 'magit-section-toggle)
  :init
  (progn
    (use-package evil-magit
      :ensure t
      :defer t))
  :config
  (progn
    (use-package magit-annex
      :ensure t)
    (use-package git-annex
      :ensure t)
    (define-key git-annex-dired-map "f"
      #'magit-annex-file-action)
    (require 'git-rebase)
    (require 'evil-magit)
    (evil-set-initial-state 'magit-status-mode 'normal)
    (define-key magit-minibuffer-local-ns-map "\s"
      (lambda ()
        (interactive)
        (insert "-")))))
#+END_SRC

* dired

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start dired:::: %.2fs" (- (float-time) shit-load-time-start))
(use-package dired
  :defer t
  :general
  (general-define-key
   :states 'normal
   "-" 'dired-jump)

  (general-define-key
   :states 'normal
   :keymaps 'dired-mode-map
   "SPC" 'dired-jump)


  )
 #+end_src

* electric pair

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(electric-pair-mode)
#+end_src

* buffer

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start ace-window:::: %.2fs" (- (float-time) shit-load-time-start))
(use-package winner
  :config (winner-mode 1))

(use-package ibuffer
  :general
  (general-define-key
   "C-x C-b" 'ibuffer))

(use-package ace-window
  :ensure t

  :general
  (leader-define
    :states '(normal)
    "j" 'hydra-window/body
    "k" 'avy-goto-char-2)

  :config
  (progn

    (defhydra hydra-window ()
      "
    Movement^^    ^Split^         ^Switch^     ^Resize^   ^Buffer actions^       ^window actions^
    ---------------------------------------------------------------------------------------------
    _h_ ←         _v_ertical      _b_uffer     _q_ X←     _y_ank buffer
    _j_ ↓         _x_ horizontal  i_B_uffer    _w_ X↓     _P_aste buffer
    _k_ ↑         _u_ndo          _f_ind files _e_ X↑     _s_ave buffer
    _l_ →         _C-r_ redo      _a_ce 1      _r_ X→     _f_ind-file
    _F_ollow      _D_lt Other     _s_wap       e_q_ualize _p_rojectile-find-file
    _SPC_ cancel  _o_nly this     _S_ave       _m_aximize
				  _d_elete
    "
      ("h" windmove-left)
      ("j" windmove-down)
      ("k" windmove-up)
      ("l" windmove-right)
      ("q" balance-windows)
      ("w" save-buffer)
      ("e" hydra-move-splitter-up)
      ("r" hydra-move-splitter-right)
      ("b" helm-mini)
      ("B" ibuffer)
      ("f" helm-find-files)
      ("p" helm-projectile-find-file)
      ("F" follow-mode)
      ("s" save-buffer)
      ("a" (lambda ()
	     (interactive)
	     (ace-window 1)
	     (add-hook 'ace-window-end-once-hook
		       'hydra-window/body)))
      ("v" (lambda ()
	     (interactive)
	     (split-window-right)
	     (windmove-right)))
      ("x" (lambda ()
	     (interactive)
	     (split-window-below)
	     (windmove-down)))
      ("s" (lambda ()
	     (interactive)
	     (ace-window 4)
	     (add-hook 'ace-window-end-once-hook
		       'hydra-window/body)))
      ("S" save-buffer)
      ("d" delete-window)
      ("D" (lambda ()
	     (interactive)
	     (ace-window 16)
	     (add-hook 'ace-window-end-once-hook
		       'hydra-window/body)))
      ("o" delete-other-windows)
      ("m" ace-maximize-window)
      ("y" (lambda ()
	     (interactive)
	     (clipboard-kill-ring-save (point-min) (point-max))))
      ("P" (lambda ()
	     (interactive)
	     (evil-paste-before 1)))
      ("c" (lambda ()
	     (interactive)
	     (erase-buffer)))
      ("z" (progn
	     (winner-undo)
	     (setq this-command 'winner-undo))
       )
      ("u" winner-undo)
      ("C-r" winner-redo)
      ("SPC" nil))

    ;; (after 'evil
    ;;   (define-key my-leader-map "j"

    ;;     ))

    (setq aw-keys '(?s ?d ?f ?g ?h ?j ?k ?l)
	  aw-dispatch-always t
	  aw-leading-char-style 'path)

    (ace-window-display-mode)

    ;; (custom-set-faces
    ;;  '(aw-leading-char-face
    ;;    ((t (:inherit ace-jump-face-foreground :height 3.0)))))

    (defvar aw-dispatch-alist
      '((?x aw-delete-window " Ace - Delete Window")
	(?m aw-swap-window " Ace - Swap Window")
	(?a aw-flip-window)
	(?v aw-split-window-vert " Ace - Split Vert Window")
	(?b aw-split-window-horz " Ace - Split Horz Window")
	(?i delete-other-windows " Ace - Maximize Window")
	(?o delete-other-windows))
      "List of actions for `aw-dispatch-default'.")

    ))

(use-package popwin
  :ensure t
  :config
  (progn
    (setq popwin:special-display-config
	  '(("*Miniedit Help*" :noselect t)
	    help-mode
	    (completion-list-mode :noselect t)
	    (compilation-mode :noselect t)
	    (grep-mode :noselect t)
	    ("*Pp Macroexpand Output*" :noselect t)
	    "*Shell Command Output*"
	    "*vc-diff*"
	    "*vc-change-log*"
	    (" *undo-tree*" :width 60 :position right)
	    "*cider-test-report*"))
    (popwin-mode 1)))

;; (use-package perspective
;;   :ensure t
;;   :config
;;   (progn
;;     (persp-mode)))

;; (use-package window-purpose
;;   :ensure t
;;   :config
;;   (progn
;;     (purpose-mode)
;;     (use-package window-purpose-x)
;;     (purpose-x-magit-single-on)
;;     (purpose-x-persp-setup)))
#+end_src

* themes
** Cool dark color theme

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(defvar cool-fg       "#ffffff")
(defvar cool-bg       "#18191B")
(defvar cool-green-0  "#95ff94")
(defvar cool-green-1  "#25492D")
(defvar cool-yellow-0 "#f9fe8a")
(defvar cool-yellow-1 "#fec952")
(defvar cool-red-0    "#f5666d")
(defvar cool-pink-0   "#F74D97")
(defvar cool-pink-1   "#FA519A")
(defvar cool-pink-2   "#FD8DBD")
(defvar cool-purple-0 "#a8799c")
(defvar cool-blue-0   "#a3beff")
(defvar cool-blue-1   "#9cd4fc")
(defvar cool-blue-2   "#8ca0fd")
(defvar cool-blue-3   "#acb3eF")

(defun color-theme-cool-dark ()
  "Cool Dark Theme"
  (interactive)
  (set-face-background 'region "#25492D")

  (color-theme-install
   (append
    (list 'color-theme-cool-dark
          `((background-color . ,cool-bg)
            (background-mode . light)
            (border-color . ,cool-bg)
            (cursor-color . ,cool-green-0)
            (foreground-color . ,cool-fg)
            (mouse-color . "black")
            )
          `(col-highlight ((t (:background "black"))))
          `(fringe ((t (:background ,cool-bg))))
          `(mode-line ((t (:foreground ,cool-pink-1 :background "black"))))
          `(mode-line-buffer-id ((t (:bold t :foreground ,cool-yellow-0))))
          `(mode-line-inactive ((t (:foreground ,cool-green-0 :background "black"))))
          `(minibuffer-prompt ((t (:foreground ,cool-blue-1 :bold t))))
          `(region ((t (:background ,cool-green-1))))
          `(mode-line-filename-face ((t (:bold t :foreground ,cool-yellow-0))))

          `(mode-line-mode-face ((t (:bold t :foreground ,cool-purple-0))))

          `(mode-line-folder-face ((t (:bold t :foreground ,cool-blue-1))))

          `(font-lock-builtin-face ((t (:bold t :foreground ,cool-red-0))))
          `(font-lock-comment-face ((t (:foreground ,cool-pink-2))))
          `(font-lock-constant-face ((t (:foreground ,cool-red-0))))
          `(font-lock-doc-face ((t (:foreground ,cool-yellow-0))))
          `(font-lock-function-name-face ((t (:foreground ,cool-blue-0))))
          `(font-lock-keyword-face ((t (:bold t :foreground ,cool-yellow-1))))
          `(font-lock-preprocessor-face ((t (:foreground ,cool-fg))))
          `(font-lock-string-face ((t (:foreground ,cool-yellow-0))))
          `(font-lock-type-face ((t (:foreground ,cool-pink-0 :bold t))))
          `(font-lock-variable-name-face ((t (:foreground ,cool-blue-2))))
          `(font-lock-warning-face ((t (:foreground ,cool-red-0 :bold t))))

          `(helm-candidate-number ((t (:background "black" :foreground "#95ff94"))))
          `(helm-ff-directory ((t (:background "#333" :foreground "#9cd4fc"))))
          `(helm-selection ((t (:background "#333" :foreground "#a3beff" :underline t))))
          `(helm-separator ((t (:foreground "#f5666d"))))
          `(helm-source-header ((t (:background "#333" :foreground "#f9fe8a" :underline t))))
          `(helm-visible-mark ((t (:background "#333" :foreground "#a8799c"))))
          `(helm-ff-prefix ((t (:background "black" :foreground "yellow"))))
          `(helm-match ((t (:background ,cool-purple-0))))
          `(helm-grep-match ((t (:background "black" :foreground "green"))))
          `(highlight ((t (:background "white" :foreground ,cool-green-0))))

          `(region ((t (:background "red"))))

          `(header-line ((t (:inherit mode-line :background ,"black" :foreground ,cool-pink-0 :box nil))))

          `(emms-playlist-selected-face ((t (:foreground ,cool-purple-0))))
          `(emms-playlist-track-face  ((t (:foreground ,cool-green-0))))

          `(hl-line ((t (:background, "black"))))

          `(sp-show-pair-match-face ((t (:background ,cool-purple-0))))
          `(sp-show-pair-mismatch-face ((t (:background ,cool-red-0))))
          `(sp-pair-overlay-face ((t (:background "black" ))))

          `(erc-action-face ((t (:foreground ,cool-red-0))))
          `(erc-button ((t (:foreground ,cool-purple-0))))
          `(erc-current-nick-face ((t (:foreground ,cool-pink-2))))
          `(erc-error-face ((t (:foreground ,cool-red-0 :bold t))))
          `(erc-input-face ((t (:foreground ,cool-fg))))
          `(erc-keyword-face ((t (:foreground ,cool-red-0))))
          `(erc-my-nick-face ((t (:foreground ,cool-blue-0))))
          `(erc-nick-default-face ((t (:bold t :foreground ,cool-pink-1))))
          `(erc-notice-face ((t (:foreground ,cool-blue-2))))
          `(erc-prompt-face ((t (:foreground ,cool-fg))))
          `(erc-timestamp-face ((t (:foreground ,cool-green-0))))

          ;; `(company-tooltip ((t (:inherit default :background ,(color-lighten-name bg 2)))))
          ;; `(company-scrollbar-bg ((t (:background ,cool-pink-1))))
          ;; `(company-scrollbar-fg ((t (:background ,cool-yellow-0))))
          ;; `(company-tooltip-selection ((t (:inherit font-lock-function-name-face))))
          ;; `(company-tooltip-common ((t (:inherit font-lock-constant-face))))

          `(magit-log-sha1 ((t (:foreground "#cf6a4c"))))
          `(magit-log-head-label-local ((t (:foreground "#3387cc"))))
          `(magit-log-head-label-remote ((t (:foreground "#65b042"))))
          `(magit-branch ((t (:bold t :foreground ,cool-yellow-1))))
          `(magit-section-title ((t (:bold t :foreground ,cool-pink-0))))
          `(magit-item-highlight ((t (:background "#1f1f1f"))))
          `(magit-diff-add ((t (:bold t :foreground ,cool-green-0))))
          `(magit-diff-del ((t (:bold nil :foreground ,cool-red-0))))

          `(gnus-group-mail-1-empty ((t (:foreground ,cool-pink-1))))
          `(gnus-group-mail-1 ((t (:bold t :foreground ,cool-pink-1))))
          `(gnus-group-mail-3-empty ((t (:foreground ,cool-blue-0))))
          `(gnus-group-mail-3 ((t (:bold t :foreground ,cool-pink-1))))
          `(gnus-group-news-3-empty ((t (:foreground ,cool-blue-2))))
          `(gnus-group-news-3 ((t (:bold t :foreground ,cool-green-0))))

          `(w3m-anchor ((t (:bold t :foreground ,cool-pink-1))))
          ))))

#+end_src

** Load my theme

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (message "Start theme:::: %.2fs" (- (float-time) shit-load-time-start))
  (use-package monokai-theme
    :ensure t)
  (load-theme 'monokai t)
#+end_src

** Load my theme

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(defun set-cursor-according-to-mode ()
  (cond
   (isearch-mode
    (set-cursor-color monokai-blue))
   (buffer-read-only
    (set-cursor-color monokai-red))
   (t
    (set-cursor-color monokai-orange))))

;; (add-hook 'post-command-hook 'set-cursor-according-to-mode)
#+end_src

* rx

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start rx forms:::: %.2fs" (- (float-time) shit-load-time-start))

(defconst whitespace-rx
  (rx (and string-start (* (or blank "\n")) string-end)))
#+end_src

* ediff

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-diff-options "-w")

  ;; (add-hook 'ediff-after-quit-hook-internal 'winner-undo)

  (add-hook 'ediff-load-hook
	    (lambda ()

	      (add-hook 'ediff-before-setup-hook
			(lambda ()
			  (setq ediff-saved-window-configuration (current-window-configuration))))

	      (let ((restore-window-configuration
		     (lambda ()
		       (set-window-configuration ediff-saved-window-configuration))))
		(add-hook 'ediff-quit-hook restore-window-configuration 'append)
		(add-hook 'ediff-suspend-hook restore-window-configuration 'append))))

  (add-hook 'ediff-startup-hook
	    (lambda ()
	      (shrink-window 40)))
#+end_src

* Avy

 #+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
   (message "Start avy:::: %.2fs" (- (float-time) shit-load-time-start))

   (use-package avy
     :ensure t
     :config
     (progn
       ;; (setq avy-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
       (setq avy-keys '(?a ?b ?c ?d ?e ?f ?g ?h ?i ?j ?k ?l ?m ?n ?o ?p ?q ?r ?s ?t ?u ?v ?w ?x ?y ?z)
	     avy-style 'at-full)))

   ;; (use-package counsel
   ;;   :ensure t)

   ;; (use-package swiper
   ;;   :ensure try
   ;;   :config
   ;;   (progn
   ;;     (ivy-mode 1)
   ;;     (setq ivy-use-virtual-buffers t)
   ;;     (global-set-key "\C-s" 'swiper)
   ;;     (global-set-key (kbd "C-c C-r") 'ivy-resume)
   ;;     (global-set-key (kbd "<f6>") 'ivy-resume)
   ;;     ;; (global-set-key (kbd "M-x") 'counsel-M-x)
   ;;     ;; (global-set-key (kbd "C-x C-f") 'counsel-find-file)
   ;;     ;; (global-set-key (kbd "<f1> f") 'counsel-describe-function)
   ;;     ;; (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
   ;;     ;; (global-set-key (kbd "<f1> l") 'counsel-load-library)
   ;;     ;; (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
   ;;     ;; (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
   ;;     (global-set-key (kbd "C-c g") 'counsel-git)
   ;;     (global-set-key (kbd "C-c j") 'counsel-git-grep)
   ;;     (global-set-key (kbd "C-c k") 'counsel-ag)
   ;;     (global-set-key (kbd "C-x l") 'counsel-locate)
   ;;     (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
   ;;     (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
   ;;     ))
 #+end_src

* buffer

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (message "Start ace-window:::: %.2fs" (- (float-time) shit-load-time-start))
  (use-package winner
    :config (winner-mode 1))

  (use-package ibuffer
    :general
    (general-define-key
     "C-x C-b" 'ibuffer))

  (use-package ace-window
    :ensure t

    :general
    (leader-define 'normal
      "j" 'hydra-window/body
      "k" 'avy-goto-char-2)

    :config
    (progn

      (defhydra hydra-window ()
	"
    Movement^^    ^Split^         ^Switch^     ^Resize^   ^Buffer actions^       ^window actions^
    ---------------------------------------------------------------------------------------------
    _h_ ←         _v_ertical      _b_uffer     _q_ X←     _y_ank buffer
    _j_ ↓         _x_ horizontal  i_B_uffer    _w_ X↓     _P_aste buffer
    _k_ ↑         _u_ndo          _f_ind files _e_ X↑     _s_ave buffer
    _l_ →         _C-r_ redo      _a_ce 1      _r_ X→     _f_ind-file
    _F_ollow      _D_lt Other     _s_wap       e_q_ualize _p_rojectile-find-file
    _SPC_ cancel  _o_nly this     _S_ave       _m_aximize
				  _d_elete
    "
	("h" windmove-left)
	("j" windmove-down)
	("k" windmove-up)
	("l" windmove-right)
	("q" balance-windows)
	("w" save-buffer)
	("e" hydra-move-splitter-up)
	("r" hydra-move-splitter-right)
	("b" helm-mini)
	("B" ibuffer)
	("f" helm-find-files)
	("p" helm-projectile-find-file)
	("F" follow-mode)
	("s" save-buffer)
	("a" (lambda ()
	       (interactive)
	       (ace-window 1)
	       (add-hook 'ace-window-end-once-hook
			 'hydra-window/body)))
	("v" (lambda ()
	       (interactive)
	       (split-window-right)
	       (windmove-right)))
	("x" (lambda ()
	       (interactive)
	       (split-window-below)
	       (windmove-down)))
	("s" (lambda ()
	       (interactive)
	       (ace-window 4)
	       (add-hook 'ace-window-end-once-hook
			 'hydra-window/body)))
	("S" save-buffer)
	("d" delete-window)
	("D" (lambda ()
	       (interactive)
	       (ace-window 16)
	       (add-hook 'ace-window-end-once-hook
			 'hydra-window/body)))
	("o" delete-other-windows)
	("m" ace-maximize-window)
	("y" (lambda ()
	       (interactive)
	       (clipboard-kill-ring-save (point-min) (point-max))))
	("P" (lambda ()
	       (interactive)
	       (evil-paste-before 1)))
	("c" (lambda ()
	       (interactive)
	       (erase-buffer)))
	("z" (progn
	       (winner-undo)
	       (setq this-command 'winner-undo))
	 )
	("u" winner-undo)
	("C-r" winner-redo)
	("SPC" nil))

      ;; (after 'evil
      ;;   (define-key my-leader-map "j"

      ;;     ))

      (setq aw-keys '(?s ?d ?f ?g ?h ?j ?k ?l)
	    aw-dispatch-always t
	    aw-leading-char-style 'path)

      (ace-window-display-mode)

      ;; (custom-set-faces
      ;;  '(aw-leading-char-face
      ;;    ((t (:inherit ace-jump-face-foreground :height 3.0)))))

      (defvar aw-dispatch-alist
	'((?x aw-delete-window " Ace - Delete Window")
	  (?m aw-swap-window " Ace - Swap Window")
	  (?a aw-flip-window)
	  (?v aw-split-window-vert " Ace - Split Vert Window")
	  (?b aw-split-window-horz " Ace - Split Horz Window")
	  (?i delete-other-windows " Ace - Maximize Window")
	  (?o delete-other-windows))
	"List of actions for `aw-dispatch-default'.")

      ))

  (use-package popwin
    :ensure t
    :config
    (progn
      (setq popwin:special-display-config
	    '(("*Miniedit Help*" :noselect t)
	      help-mode
	      (completion-list-mode :noselect t)
	      (compilation-mode :noselect t)
              (grep-mode :noselect t)
	      ("*Pp Macroexpand Output*" :noselect t)
	      "*Shell Command Output*"
	      "*vc-diff*"
	      "*vc-change-log*"
	      (" *undo-tree*" :width 60 :position right)
	      "*cider-test-report*"))
      (popwin-mode 1)))

  ;; (use-package perspective
  ;;   :ensure t
  ;;   :config
  ;;   (progn
  ;;     (persp-mode)))

  ;; (use-package window-purpose
  ;;   :ensure t
  ;;   :config
  ;;   (progn
  ;;     (purpose-mode)
  ;;     (use-package window-purpose-x)
  ;;     (purpose-x-magit-single-on)
  ;;     (purpose-x-persp-setup)))
#+end_src

* themes
** Cool dark color theme

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(defvar cool-fg       "#ffffff")
(defvar cool-bg       "#18191B")
(defvar cool-green-0  "#95ff94")
(defvar cool-green-1  "#25492D")
(defvar cool-yellow-0 "#f9fe8a")
(defvar cool-yellow-1 "#fec952")
(defvar cool-red-0    "#f5666d")
(defvar cool-pink-0   "#F74D97")
(defvar cool-pink-1   "#FA519A")
(defvar cool-pink-2   "#FD8DBD")
(defvar cool-purple-0 "#a8799c")
(defvar cool-blue-0   "#a3beff")
(defvar cool-blue-1   "#9cd4fc")
(defvar cool-blue-2   "#8ca0fd")
(defvar cool-blue-3   "#acb3eF")

(defun color-theme-cool-dark ()
  "Cool Dark Theme"
  (interactive)
  (set-face-background 'region "#25492D")

  (color-theme-install
   (append
    (list 'color-theme-cool-dark
          `((background-color . ,cool-bg)
            (background-mode . light)
            (border-color . ,cool-bg)
            (cursor-color . ,cool-green-0)
            (foreground-color . ,cool-fg)
            (mouse-color . "black")
            )
          `(col-highlight ((t (:background "black"))))
          `(fringe ((t (:background ,cool-bg))))
          `(mode-line ((t (:foreground ,cool-pink-1 :background "black"))))
          `(mode-line-buffer-id ((t (:bold t :foreground ,cool-yellow-0))))
          `(mode-line-inactive ((t (:foreground ,cool-green-0 :background "black"))))
          `(minibuffer-prompt ((t (:foreground ,cool-blue-1 :bold t))))
          `(region ((t (:background ,cool-green-1))))
          `(mode-line-filename-face ((t (:bold t :foreground ,cool-yellow-0))))

          `(mode-line-mode-face ((t (:bold t :foreground ,cool-purple-0))))

          `(mode-line-folder-face ((t (:bold t :foreground ,cool-blue-1))))

          `(font-lock-builtin-face ((t (:bold t :foreground ,cool-red-0))))
          `(font-lock-comment-face ((t (:foreground ,cool-pink-2))))
          `(font-lock-constant-face ((t (:foreground ,cool-red-0))))
          `(font-lock-doc-face ((t (:foreground ,cool-yellow-0))))
          `(font-lock-function-name-face ((t (:foreground ,cool-blue-0))))
          `(font-lock-keyword-face ((t (:bold t :foreground ,cool-yellow-1))))
          `(font-lock-preprocessor-face ((t (:foreground ,cool-fg))))
          `(font-lock-string-face ((t (:foreground ,cool-yellow-0))))
          `(font-lock-type-face ((t (:foreground ,cool-pink-0 :bold t))))
          `(font-lock-variable-name-face ((t (:foreground ,cool-blue-2))))
          `(font-lock-warning-face ((t (:foreground ,cool-red-0 :bold t))))

          `(helm-candidate-number ((t (:background "black" :foreground "#95ff94"))))
          `(helm-ff-directory ((t (:background "#333" :foreground "#9cd4fc"))))
          `(helm-selection ((t (:background "#333" :foreground "#a3beff" :underline t))))
          `(helm-separator ((t (:foreground "#f5666d"))))
          `(helm-source-header ((t (:background "#333" :foreground "#f9fe8a" :underline t))))
          `(helm-visible-mark ((t (:background "#333" :foreground "#a8799c"))))
          `(helm-ff-prefix ((t (:background "black" :foreground "yellow"))))
          `(helm-match ((t (:background ,cool-purple-0))))
          `(helm-grep-match ((t (:background "black" :foreground "green"))))
          `(highlight ((t (:background "white" :foreground ,cool-green-0))))

          `(region ((t (:background "red"))))

          `(header-line ((t (:inherit mode-line :background ,"black" :foreground ,cool-pink-0 :box nil))))

          `(emms-playlist-selected-face ((t (:foreground ,cool-purple-0))))
          `(emms-playlist-track-face  ((t (:foreground ,cool-green-0))))

          `(hl-line ((t (:background, "black"))))

          `(sp-show-pair-match-face ((t (:background ,cool-purple-0))))
          `(sp-show-pair-mismatch-face ((t (:background ,cool-red-0))))
          `(sp-pair-overlay-face ((t (:background "black" ))))

          `(erc-action-face ((t (:foreground ,cool-red-0))))
          `(erc-button ((t (:foreground ,cool-purple-0))))
          `(erc-current-nick-face ((t (:foreground ,cool-pink-2))))
          `(erc-error-face ((t (:foreground ,cool-red-0 :bold t))))
          `(erc-input-face ((t (:foreground ,cool-fg))))
          `(erc-keyword-face ((t (:foreground ,cool-red-0))))
          `(erc-my-nick-face ((t (:foreground ,cool-blue-0))))
          `(erc-nick-default-face ((t (:bold t :foreground ,cool-pink-1))))
          `(erc-notice-face ((t (:foreground ,cool-blue-2))))
          `(erc-prompt-face ((t (:foreground ,cool-fg))))
          `(erc-timestamp-face ((t (:foreground ,cool-green-0))))

          ;; `(company-tooltip ((t (:inherit default :background ,(color-lighten-name bg 2)))))
          ;; `(company-scrollbar-bg ((t (:background ,cool-pink-1))))
          ;; `(company-scrollbar-fg ((t (:background ,cool-yellow-0))))
          ;; `(company-tooltip-selection ((t (:inherit font-lock-function-name-face))))
          ;; `(company-tooltip-common ((t (:inherit font-lock-constant-face))))

          `(magit-log-sha1 ((t (:foreground "#cf6a4c"))))
          `(magit-log-head-label-local ((t (:foreground "#3387cc"))))
          `(magit-log-head-label-remote ((t (:foreground "#65b042"))))
          `(magit-branch ((t (:bold t :foreground ,cool-yellow-1))))
          `(magit-section-title ((t (:bold t :foreground ,cool-pink-0))))
          `(magit-item-highlight ((t (:background "#1f1f1f"))))
          `(magit-diff-add ((t (:bold t :foreground ,cool-green-0))))
          `(magit-diff-del ((t (:bold nil :foreground ,cool-red-0))))

          `(gnus-group-mail-1-empty ((t (:foreground ,cool-pink-1))))
          `(gnus-group-mail-1 ((t (:bold t :foreground ,cool-pink-1))))
          `(gnus-group-mail-3-empty ((t (:foreground ,cool-blue-0))))
          `(gnus-group-mail-3 ((t (:bold t :foreground ,cool-pink-1))))
          `(gnus-group-news-3-empty ((t (:foreground ,cool-blue-2))))
          `(gnus-group-news-3 ((t (:bold t :foreground ,cool-green-0))))

          `(w3m-anchor ((t (:bold t :foreground ,cool-pink-1))))
          ))))

#+end_src

** Load my theme

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (message "Start theme:::: %.2fs" (- (float-time) shit-load-time-start))
  (use-package monokai-theme
    :ensure t)
  (load-theme 'monokai t)
#+end_src

** Load my theme

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(defun set-cursor-according-to-mode ()
  (cond
   (isearch-mode
    (set-cursor-color monokai-blue))
   (buffer-read-only
    (set-cursor-color monokai-red))
   (t
    (set-cursor-color monokai-orange))))

;; (add-hook 'post-command-hook 'set-cursor-according-to-mode)
#+end_src

* rx

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start rx forms:::: %.2fs" (- (float-time) shit-load-time-start))

(defconst whitespace-rx
  (rx (and string-start (* (or blank "\n")) string-end)))
#+end_src

* ediff

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-diff-options "-w")

  ;; (add-hook 'ediff-after-quit-hook-internal 'winner-undo)

  (add-hook 'ediff-load-hook
	    (lambda ()

	      (add-hook 'ediff-before-setup-hook
			(lambda ()
			  (setq ediff-saved-window-configuration (current-window-configuration))))

	      (let ((restore-window-configuration
		     (lambda ()
		       (set-window-configuration ediff-saved-window-configuration))))
		(add-hook 'ediff-quit-hook restore-window-configuration 'append)
		(add-hook 'ediff-suspend-hook restore-window-configuration 'append))))

  (add-hook 'ediff-startup-hook
	    (lambda ()
	      (shrink-window 40)))
#+end_src

* paredit

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start paredit:::: %.2fs" (- (float-time) shit-load-time-start))
(use-package paredit
  :commands paredit-mode
  :config
  (progn
    (define-key paredit-mode-map (kbd ")")
      'paredit-close-round-and-newline)
    (define-key paredit-mode-map (kbd "M-)")
      'paredit-close-round)))

;; (use-package paredit
;;   :disabled t
;;   :init
;;   (progn
;;     (defun paredit-wrap-round-from-behind ()
;;       (interactive)
;;       (forward-sexp -1)
;;       (paredit-wrap-round)
;;       (insert " ")
;;       (forward-char -1))

;;     (defun paredit-wrap-square-from-behind ()
;;       (interactive)
;;       (forward-sexp -1)
;;       (paredit-wrap-square))

;;     (defun paredit-wrap-curly-from-behind ()
;;       (interactive)
;;       (forward-sexp -1)
;;       (paredit-wrap-curly))

;;     (defun paredit-kill-region-or-backward-word ()
;;       (interactive)
;;       (if (region-active-p)
;;           (kill-region (region-beginning) (region-end))
;;         (paredit-backward-kill-word)))

;;     (add-hook 'clojure-mode-hook (lambda () (paredit-mode 1)))
;;     (add-hook 'nrepl-mode-hook (lambda () (paredit-mode 1)))
;;     (add-hook 'emacs-lisp-mode-hook (lambda () (paredit-mode 1)))

;;     (define-key paredit-mode-map (kbd "M-(") 'paredit-wrap-round)
;;     (define-key paredit-mode-map (kbd "M-)") 'paredit-wrap-round-from-behind)
;;     (define-key paredit-mode-map (kbd "M-s-8") 'paredit-wrap-square)
;;     (define-key paredit-mode-map (kbd "M-s-9") 'paredit-wrap-square-from-behind)
;;     (define-key paredit-mode-map (kbd "M-s-(") 'paredit-wrap-curly)
;;     (define-key paredit-mode-map (kbd "M-s-)") 'paredit-wrap-curly-from-behind)

;;     (define-key paredit-mode-map (kbd "C-w") 'paredit-kill-region-or-backward-word)

;;     (defun live-paredit-next-top-level-form ()
;;       (interactive)
;;       (while (ignore-errors (paredit-backward-up) t))
;;       (live-paredit-forward))

;;     (defun live-paredit-previous-top-level-form ()
;;       (interactive)
;;       (if (ignore-errors (paredit-backward-up) t)
;;           (while (ignore-errors (paredit-backward-up) t))
;;         (paredit-backward)))

;;     (defun live-paredit-forward ()
;;       "Feels more natural to move to the beginning of the next item
;;    in the sexp, not the end of the current one."
;;       (interactive)
;;       (if (and (not (paredit-in-string-p))
;;                (save-excursion
;;                  (ignore-errors
;;                    (forward-sexp)
;;                    (forward-sexp)
;;                    t)))
;;           (progn
;;             (forward-sexp)
;;             (forward-sexp)
;;             (backward-sexp))
;;         (paredit-forward)))

;;     (defun live-paredit-forward-slurp-sexp-neatly ()
;;       (interactive)
;;       (save-excursion
;;         (cond ((or (paredit-in-comment-p)
;;                    (paredit-in-char-p))
;;                (error "Invalid context for slurping S-expressions."))
;;               ((paredit-in-string-p)
;;                (paredit-forward-slurp-into-string))
;;               (t

;;                (save-excursion
;;                  (paredit-forward-up)
;;                  (paredit-backward-down)
;;                  (paredit-forward-slurp-sexp)
;;                  (just-one-space)))))
;;       (when (not (save-excursion
;;                    (ignore-errors
;;                      (backward-sexp)
;;                      t)))
;;         (delete-horizontal-space)))



;;     (defun live-paredit-forward-kill-sexp (&optional arg)
;;       (interactive "p")
;;       (cond ((or (paredit-in-comment-p)
;;                  (paredit-in-string-p)) (kill-word (or arg 1)))
;;             (t (kill-sexp (or arg 1)))))

;;     (defun live-paredit-backward-kill-sexp (&optional arg)
;;       (interactive "p")
;;       (cond ((or (paredit-in-comment-p)
;;                  (paredit-in-string-p)) (backward-kill-word (or arg 1)))
;;             (t (backward-kill-sexp (or arg 1)))))

;;     (defun live-paredit-backward-kill ()
;;       (interactive)
;;       (let ((m (point-marker)))
;;         (paredit-backward-up)
;;         (forward-char)
;;         (delete-region (point) m)))

;;     (defun live-paredit-delete-horizontal-space ()
;;       (interactive)
;;       (just-one-space -1)
;;       (paredit-backward-delete))

;;     (defun live-paredit-tidy-trailing-parens ()
;;       (interactive)
;;       (save-excursion
;;         (while (ignore-errors (paredit-forward-up) t))
;;         (backward-char)
;;         (live-paredit-delete-horizontal-space)
;;         (while
;;             (or
;;              (eq (char-before) ?\))
;;              (eq (char-before) ?\})
;;              (eq (char-before) ?\]))
;;           (backward-char)
;;           (live-paredit-delete-horizontal-space))))

;;     (defun live-paredit-reindent-defun (&optional argument)
;;       "Reindent the definition that the point is on. If the point is
;;   in a string or a comment, fill the paragraph instead, and with
;;   a prefix argument, justify as well. Doesn't mess about with
;;   Clojure fn arglists when filling-paragraph in docstrings.

;;   Also tidies up trailing parens when in a lisp form"
;;       (interactive "P")
;;       (cond ((paredit-in-comment-p) (fill-paragraph argument))
;;             ((paredit-in-string-p) (progn
;;                                      (save-excursion
;;                                        (paredit-forward-up)
;;                                        (insert "\n"))
;;                                      (fill-paragraph argument)
;;                                      (save-excursion
;;                                        (paredit-forward-up)
;;                                        (delete-char 1))))
;;             (t (when (not (live-paredit-top-level-p))
;;                  (progn (save-excursion
;;                           (end-of-defun)
;;                           (beginning-of-defun)
;;                           (indent-sexp))
;;                         (live-paredit-tidy-trailing-parens))))))


;;     (defun live-paredit-forward-down ()
;;       "Doesn't freeze Emacs if attempted to be called at end of
;;    buffer. Otherwise similar to paredit-forward-down."
;;       (interactive)
;;       (if (save-excursion
;;             (forward-comment (buffer-size))
;;             (not (live-end-of-buffer-p)))
;;           (paredit-forward-down)
;;         (error "unexpected end of buffer")))

;;     (defun live-paredit-top-level-p ()
;;       "Returns true if point is not within a given form i.e. it's in
;;   toplevel 'whitespace'"
;;       (not
;;        (save-excursion
;;          (ignore-errors
;;            (paredit-forward-up)
;;            t))))

;;     ;; Change nasty paredit keybindings
;;     ;; (defvar my-nasty-paredit-keybindings-remappings
;;     ;;   '(("M-s" "s-s" paredit-splice-sexp)
;;     ;;     ("M-<up>" "s-<up>" paredit-splice-sexp-killing-backward)
;;     ;;     ("M-<down>" "s-<down>" paredit-splice-sexp-killing-forward)
;;     ;;     ("C-<right>" "s-<right>" paredit-forward-slurp-sexp)
;;     ;;     ("C-<left>" "s-<left>" paredit-forward-barf-sexp)
;;     ;;     ("C-M-<left>" "s-S-<left>" paredit-backward-slurp-sexp)
;;     ;;     ("C-M-<right>" "s-S-<right>" paredit-backward-barf-sexp)))

;;     ;; (define-key paredit-mode-map (kbd "s-r") 'paredit-raise-sexp)

;;     ;; (--each my-nasty-paredit-keybindings-remappings
;;     ;;   (let ((original (car it))
;;     ;;         (replacement (cadr it))
;;     ;;         (command (car (last it))))
;;     ;;     (define-key paredit-mode-map (read-kbd-macro original) nil)
;;     ;;     (define-key paredit-mode-map (read-kbd-macro replacement) command)))

;;     ;; don't hijack \ please
;;     (define-key paredit-mode-map (kbd "\\") nil)

;;     ;; Enable `paredit-mode' in the minibuffer, during `eval-expression'.
;;     (defun conditionally-enable-paredit-mode ()
;;       (if (eq this-command 'eval-expression)
;;           (paredit-mode 1)))

;;     (add-hook 'minibuffer-setup-hook 'conditionally-enable-paredit-mode)

;;     ;; making paredit work with delete-selection-mode
;;     (put 'paredit-forward-delete 'delete-selection 'supersede)
;;     (put 'paredit-backward-delete 'delete-selection 'supersede)
;;     (put 'paredit-newline 'delete-selection t)

;;     ;; functions in smartparens that do not have an equivalent in paredit - take a look at them
;;     (when nil
;;       '(sp-beginning-of-sexp
;;         sp-end-of-sexp
;;         sp-next-sexp
;;         sp-previous-sexp
;;         sp-kill-sexp
;;         sp-unwrap-sexp
;;         sp-backward-unwrap-sexp
;;         sp-select-next-thing-exchange
;;         sp-select-next-thing
;;         sp-forward-symbol
;;         sp-backward-symbol))

;;     ))

;; (defadvice paredit-mode (around disable-autopairs-around (arg))
;;   "Disable autopairs mode if paredit-mode is turned on"
;;   ad-do-it
;;   (if (null ad-return-value)
;;       (autopair-mode 1)
;;     (autopair-mode 0)
;;     ))

;; (ad-activate 'paredit-mode)

#+end_src

* projectile

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (message "projectile:::: %.2fs" (- (float-time) shit-load-time-start))

  (use-package projectile
    :ensure t
    :defer t
    :diminish projectile-mode "p"
    :init
    (setq projectile-completion-system 'helm
          projectile-cache-file (expand-file-name
                                 "projectile.cache"
                                 user-var-directory)
          projectile-known-projects-file (expand-file-name
                                          "projectile-bookmarks.eld"
                                          user-var-directory)
          projectile-indexing-method 'alien)
    :config
    (progn
      (projectile-global-mode)))

  (use-package helm-projectile
    :commands (helm-projectile-find-file)
    :defer t
    :ensure t)
#+end_src

* esup

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(use-package esup
  :defer t
  :ensure t)
#+end_src

* TODO company
** main

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "company:::: %.2fs" (- (float-time) shit-load-time-start))
;; (use-package company
;;   :ensure t
;;   :diminish t
;;   :general ("<tab>" 'company-complete)
;;   :init (global-company-mode)
;;   :config
;;   (progn

;;     (setq company-idle-delay nil)

;;     ;; (use-package company-quickhelp
;;     ;;   :ensure t
;;     ;;   :config (company-quickhelp-mode 1))

;;     ;;(push 'company-readline company-backends)
;;     ;;(add-hook 'rlc-no-readline-hook (lambda () (company-mode -1)))

;;     ))
#+end_src

* functions

** comment dwim

#+begin_src emacs-lisp
;; Original idea from
;; http://www.opensubscriber.com/message/emacs-devel@gnu.org/10971693.html
(defun comment-dwim-line (&optional arg)
  "Replacement for the comment-dwim command.
          If no region is selected and current line is not blank and we are not at the end of the line,
          then comment current line.
          Replaces default behaviour of comment-dwim, when it inserts comment at the end of the line."
  (interactive "*P")
  (comment-normalize-vars)
  (if (and (not (region-active-p)) (not (looking-at "[ \t]*$")))
      (comment-or-uncomment-region (line-beginning-position) (line-end-position))
    (comment-dwim arg)))
#+end_src

** mark kill eval

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start functions/kill:::: %.2fs" (- (float-time) shit-load-time-start))

(general-define-key
 :modes '(emacs-lisp-mode-map scheme-mode-map clojure-mode-map)
 :states '(normal)
 :prefix "SPC"
 "ec" 'eval-defun-and-replace
 "ex" 'my-eval-last-sexp
 "ee" 'my-eval-defun
 "ek" 'eval-current-kill)

(defun eval-defun-and-replace ()
  "Replace the current top level form with its value."
  (interactive)
  (mark-defun)
  (kill-region (point) (mark))
  (eval-current-kill)
  (insert "
"))

(defun my-eval-last-sexp ()
  "Eval the current top level form."
  (interactive)
  (cond
   ((eq major-mode 'emacs-lisp-mode) (eval-last-sexp))
   ((eq major-mode 'clojure-mode) (cider-eval-last-sexp))))

(defun my-eval-defun ()
  "Eval the current top level form."
  (interactive)
  (cond
   ((eq major-mode 'emacs-lisp-mode) (eval-defun nil))
   ((eq major-mode 'clojure-mode) (cider-eval-defun-at-point))))

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (eval-current-kill))

(defun eval-current-kill ()
  "Eval the current kill and insert it into the buffer."
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))



#+end_src

** jump to mark

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (defun jump-to-mark ()
    "Jumps to the local mark, respecting the 'mark-ring' order.
          This is the same as using \\[set-mark-command] with the prefix argument."
    (interactive)
    (set-mark-command 1))

  (defun push-mark-no-activate ()
    "Pushes 'point' to 'mark-ring' and does not activate the region
          Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
    (interactive)
    (push-mark (point) t nil)
    (message "Pushed mark to ring"))

  (defun exchange-point-and-mark-no-activate ()
    "Identical to \\[exchange-point-and-mark] but will not activate the region."
    (interactive)
    (exchange-point-and-mark)
    (deactivate-mark nil))
  (define-key global-map [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)

  (global-set-key (kbd "C-'") 'push-mark-no-activate)
  (global-set-key (kbd "M-'") 'jump-to-mark)

#+end_src

** Rename buffer

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
;; Rename current file
(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))
#+end_src

** generic funcs
#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "func:::: %.2fs" (- (float-time) shit-load-time-start))

(defun un-camelcase-word-at-point ()
  "un-camelcase the word at point, replacing uppercase chars with
the lowercase version preceded by an underscore.

The first char, if capitalized (eg, PascalCase) is just
downcased, no preceding underscore.
"
  (interactive)
  (save-excursion
    (let ((bounds (bounds-of-thing-at-point 'word)))
      (replace-regexp "\\([A-Z]\\)" "_\\1" nil
                      (1+ (car bounds)) (cdr bounds))
      (downcase-region (car bounds) (cdr bounds)))))

(defun really-kill-read-only ()
  (interactive)
  (let ((inhibit-read-only t)) (kill-this-buffer)))

(defun ediff-auto-save ()
  "Ediff current file and its auto-save pendant."
  (interactive)
  (let ((auto-file-name (make-auto-save-file-name))
        (file-major-mode major-mode))
    (ediff-files buffer-file-name auto-file-name)
    (switch-to-buffer-other-window (file-name-nondirectory auto-file-name))
    (apply file-major-mode '())
    (other-window 1))) ;; back to ediff panel


(defun smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))


;; Hides emacs instead of closing
(defun my-done ()
  (interactive)
  (server-edit)
  (make-frame-invisible nil t))

;; Byte-compile-init file
(defun my-init-compile ()
  (interactive)
  (org-babel-tangle))

(defun exit-emacs-client ()
  "consistent exit emacsclient.
         if not in emacs client, echo a message in minibuffer, don't exit emacs.
         if in server mode
            and editing file, do C-x # server-edit
            else do C-x 5 0 delete-frame"
  (interactive)
  (if server-buffer-clients
      (server-edit)
    (delete-frame)))

;; Auto complile a lisp buffer if one doesn't already exist
(defun auto-recompile-el-buffer ()
  (interactive)
  (when (and (eq major-mode 'emacs-lisp-mode)
             (file-exists-p (byte-compile-dest-file buffer-file-name)))
    (byte-compile-file buffer-file-name)))
(add-hook 'after-save-hook 'auto-recompile-el-buffer)

(defun emacs-process-p (pid)
  "If pid is the process ID of an emacs process, return t, else nil.
      Also returns nil if pid is nil."
  (when pid
    (let ((attributes (process-attributes pid)) (cmd))
      (dolist (attr attributes)
        (if (string= "comm" (car attr))
            (setq cmd (cdr attr))))
      (if (and cmd (or (string= "emacs" cmd) (string= "emacs.exe" cmd))) t))))


(defadvice desktop-owner (after pry-from-cold-dead-hands activate)
  "Don't allow dead emacsen to own the desktop file."
  (when (not (emacs-process-p ad-return-value))
    (setq ad-return-value nil)))

#+end_src

** Yank and Pop
#+begin_src emacs-lisp
(message "Yank and pop:::: %.2fs" (- (float-time) shit-load-time-start))

  (dolist (command '(yank yank-pop))
       (eval `(defadvice ,command (after indent-region activate)
                (and (not current-prefix-arg)
                     (member major-mode '(emacs-lisp-mode lisp-mode
                                                          clojure-mode    scheme-mode
                                                          haskell-mode    ruby-mode
                                                          rspec-mode      python-mode
                                                          c-mode          c++-mode
                                                          objc-mode       latex-mode
                                                          plain-tex-mode  php-mode))
                     (let ((mark-even-if-inactive transient-mark-mode))
                       (indent-region (region-beginning) (region-end) nil))))))

(defadvice kill-line (before check-position activate)
      (if (member major-mode
                  '(emacs-lisp-mode scheme-mode lisp-mode
                                    c-mode c++-mode objc-mode
                                    latex-mode plain-tex-mode
php-mode))
          (if (and (eolp) (not (bolp)))
              (progn (forward-char 1)
                     (just-one-space 0)
                     (backward-char 1)))))

  ;; slick-copy: make copy-past a bit more intelligent
  ;; from: http://www.emacswiki.org/emacs/SlickCopy
  (defadvice kill-ring-save (before slick-copy activate compile)
    "When called interactively with no active region, copy a single
    line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (message "Copied line")
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single
    line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))

#+end_src

** string

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Start functions/string:::: %.2fs" (- (float-time) shit-load-time-start))

(defun s-whitespace? (string)
  (s-matches? whitespace-rx string))
#+end_src

** buffer

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(defun parent-directory ()
  (let ((buffer (buffer-file-name)))
    (if buffer
        (cadr (reverse (split-string (file-name-directory buffer)
                                     "/"))))))
#+end_src

** execute file

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(defun xah-run-current-file ()
  "Execute the current file.
For example, if the current buffer is the file x.py, then it'll call 「python x.py」 in a shell.
The file can be Emacs Lisp, PHP, Perl, Python, Ruby, JavaScript, Bash, Ocaml, Visual Basic, TeX, Java, Clojure.
File suffix is used to determine what program to run.

If the file is modified or not saved, save it automatically before run.

URL `http://ergoemacs.org/emacs/elisp_run_current_file.html'
version 2015-10-08"
  (interactive)
  (let (
         (suffix-map
          ;; (‹extension› . ‹shell program name›)
          `(
            ("php" . "php")
            ("pl" . "perl")
            ("py" . "python")
            ("py3" . ,(if (string-equal system-type "windows-nt") "c:/Python32/python.exe" "python3"))
            ("rb" . "ruby")
            ("js" . "node") ; node.js
            ("sh" . "bash")
            ("clj" . "java -cp /home/xah/apps/clojure-1.6.0/clojure-1.6.0.jar clojure.main")
            ("rkt" . "racket")
            ("ml" . "ocaml")
            ("vbs" . "cscript")
            ("tex" . "pdflatex")
            ("latex" . "pdflatex")
            ("java" . "javac")
            ("ls"   . "lsc -cj")
            ;; ("pov" . "/usr/local/bin/povray +R2 +A0.1 +J1.2 +Am2 +Q9 +H480 +W640")
            ))

         fname
         fSuffix
         prog-name
         cmd-str)

    (when (null (buffer-file-name)) (save-buffer))
    (when (buffer-modified-p) (save-buffer))

    (setq fname (buffer-file-name))
    (setq fSuffix (file-name-extension fname))
    (setq prog-name (cdr (assoc fSuffix suffix-map)))
    (setq cmd-str (concat prog-name " \""   fname "\""))

    (cond
     ((string-equal fSuffix "el") (load fname))
     ((string-equal fSuffix "java")
      (progn
        (shell-command cmd-str "*xah-run-current-file output*" )
        (shell-command
         (format "java %s" (file-name-sans-extension (file-name-nondirectory fname))))))
     (t (if prog-name
            (progn
              (message "Running…")
              (shell-command cmd-str "*xah-run-current-file output*" ))
          (message "No recognized program file suffix for this file."))))))
#+end_src

** timestamp as time string

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(defun timestamp-as-time-string-font-lock ()
  (interactive)
  (font-lock-add-keywords
   nil
   '(("^[0-9]+"
      (0 `(face nil display
                ,(format-time-string "%F %T"
                                     (seconds-to-time
                                      (car (read-from-string
                                            (concat  (match-string 0) ".0")))))))))))
#+end_src

* tramp

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (message "tramp:::: %.2fs" (- (float-time) shit-load-time-start))

  (add-to-list 'backup-directory-alist
               (cons tramp-file-name-regexp nil))

  (setq max-specpdl-size 10000
        tramp-default-method "ssh"
        ange-ftp-auto-save nil
        ange-ftp-auto-save-remotely nil
        tramp-backup-directory-alist nil
        tramp-histfile-override (expand-file-name "tramp_history" user-var-directory )
        tramp-persistency-file-name (expand-file-name "tramp" user-var-directory))
#+end_src

* recentf

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (use-package recentf
    :config
    (setq recentf-save-file (expand-file-name "recentf" user-var-directory)))

#+end_src

* expand region

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (message "Expand Region:::: %.2fs" (- (float-time) shit-load-time-start))
  (use-package expand-region
    :ensure t
    :config (general-define-key
	     :states 'visual
	     "v" 'er/expand-region))
#+end_src

* Movement keys

#+begin_src emacs-lisp
(message "Movement:::: %.2fs" (- (float-time) shit-load-time-start))

  (global-set-key (kbd "s-h") 'help-command)
  (global-unset-key (kbd "C-h"))

  (add-hook 'paredit-mode-hook
            (lambda ()
              (define-key paredit-mode-map (kbd "C-j") nil)
              (define-key paredit-mode-map (kbd "C-k") nil)))

  (global-set-key (kbd "C-h") 'left-char)
  (global-set-key (kbd "C-l") 'right-char)
  (global-set-key (kbd "C-j") 'next-line)
  (global-set-key (kbd "C-k") 'previous-line)

  (define-key package-menu-mode-map "j" 'next-line)
  (define-key package-menu-mode-map "k" 'previous-line)
#+end_src

* Keyboard Macros

#+begin_src emacs-lisp
  (after 'evil
    (define-leader-keys 'my-misc-map "d"
      "s"         'kmacro-start-macro
      "e"         'kmacro-end-macro
      "l"         'call-last-kbd-macro
      "u" 'un-camelcase-word-at-point))
#+end_src

* Keys

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el2
  (message "Keys:::: %.2fs" (- (float-time) shit-load-time-start))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;;;Key triggers
  (global-set-key (kbd "C-x C-c") nil)
  (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)
  (global-set-key "\M-;" 'comment-dwim-line)
  (global-set-key "\C-a" 'smarter-move-beginning-of-line)
  ;;(global-set-key (kbd "C-c C-e") 'eval-and-replace)
                                          ;(global-set-key (kbd "M-i") ')
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  ;;(define-key emacs-lisp-mode-map (kbd "C-x f") 'eval-defun)

  (define-key ctl-x-map "F" 'find-function)
  (define-key ctl-x-map "V" 'find-variable)

  (global-set-key (kbd "C-c R") (lambda()(interactive)(find-file org-default-notes-file))) ;; remember.org


  ;; easy keys to split window. Key based on ErgoEmacs keybinding
  (global-set-key (kbd "M-1") 'delete-other-windows) ; expand current pane
  (global-set-key (kbd "M-2") 'split-window-horizontally) ; split pane top/bottom
  (global-set-key (kbd "M-3") 'split-window-vertically) ; split pane top/bottom
  (global-set-key (kbd "M-a") 'other-window) ; cursor to other pane
  (global-set-key (kbd "M-0") 'delete-window) ; close current pane


  ;; close current pane
  (global-set-key (kbd "M-<backspace>")
                  '(lambda () (interactive)
                     (let (kill-buffer-query-functions) (kill-buffer))))


  (global-set-key (kbd "C-'") 'push-mark-no-activate)
  (global-set-key (kbd "M-'") 'jump-to-mark)


                                          ; (global-set-key (kbd "M-s") 'other-window)

  (global-set-key (kbd "TAB") 'self-insert-command)
  (global-set-key (kbd "RET") 'newline-and-indent) ;; Makes return indent

  (global-set-key (kbd "\C-c r") 'replace-string)
  (global-set-key (kbd "\C-c R") 'replace-regex)

  (global-set-key (kbd "\C-c l") 'load-file)

  (global-set-key (kbd "M-g M-g") nil)
  (global-set-key (kbd "\C-c g") 'goto-line)


  (global-set-key (kbd "\C-c s") 'kill-ring-search)
  (setq delete-by-moving-to-trash t)

  ;; global key bindings
  (global-set-key (kbd "C-<f1>") 'wg-revert-workgroup)
  (global-set-key [f2] 'sunrise-cd)
  (global-set-key [f3] 'magit-status)
  (global-set-key [f4] 'shell)
  (global-set-key [f5] 'helm-projectile-ag)
  (global-set-key (kbd "C-<f5>") 'helm-ag)
  (global-set-key [f6] 'helm-do-grep-ag)
  (global-set-key [f6] 'multi-occur)

(global-set-key (kbd "s-<backspace>") 'evil-delete-backward-word)

  (global-set-key (kbd "<C-S-up>")     'buf-move-up)
  (global-set-key (kbd "<C-S-down>")   'buf-move-down)
  (global-set-key (kbd "<C-S-left>")   'buf-move-left)
  (global-set-key (kbd "<C-S-right>")  'buf-move-right)

  (global-set-key [delete]          'delete-char)

  (global-set-key [C-tab]       'other-window)
  (global-set-key [S-right]     'other-window)
  (global-set-key [S-left]      'other-window)

  (global-set-key "\M-u"        '(lambda () (interactive) (backward-word 1) (upcase-word 1)))  ; capitalize current word (for example, C constants)

  (global-set-key (kbd "C-c q") 'exit-emacs-client)


#+end_src

* org
** Notes
*** TODO how to set prefix key to a sparse key map
** Begin

#+begin_src emacs-lisp :noweb yes :tangle ~/.emacs.d/init.el
(message "org:::: %.2fs" (- (float-time) shit-load-time-start))

;; (use-package names
;; :ensure t)

(use-package org

  :bind
  (("C-c c" . org-capture)
   ("C-c t" . org-table-recalculate-buffer-tables)
   ("C-c a" . org-agenda)
   ("C-c S" . org-store-link)
   ("C-c l" . org-insert-link))

  :mode
  ("\\.org\\'" . org-mode)

  :config
  (progn

(add-to-list 'org-emphasis-alist
	     '("!"  (:foreground "red") "<mark>" "</mark>"
	       )
	     ;; '(
	     ;;  ("!"  (:foreground "red") )
	     ;;  ("/" italic "<i>" "</i>")
	     ;;  ("_" underline "<span style=\"text-decoration:underline;\">" "</span>")
	     ;;  ("-" (:overline t) "<span style=\"text-decoration:overline;\">" "</span>")

	     ;;  ("*" org-verbatim "<code>" "</code>" verbatim)
	     ;;  ("+" (:strike-through t) "<del>" "</del>"))
	     )
    (setq org-src-preserve-indentation nil
	  org-edit-src-content-indentation 0)
    ;; (define-namespace my-org-
    ;; <<org-functions>>)
    ;; <<org-setq>>
    ;; <<org-packages>>
    ;; <<org-jira>>
    ;; <<org-config>>
    ;; <<org-calendar>>
    ;; <<org-taskjuggler>>
    ;; <<org-pomodoro>>
    ;; <<org-agenda>>
    ;; <<org-pdf>>
    ;; <<org-contacts>>
    ;; <<org-evil>>
    ;; <<org-capture>>
    <<org-babel>>
    ;; <<org-bib>>

    ))
#+end_src

** Setq

#+name: org-setq
#+begin_src emacs-lisp :exports none :noweb yes
(setq org-directory "~/src/org/"
      org-goto-interface 'outline-path-completion
      org-goto-max-level 10
      org-hide-emphasis-markers t

      org-pretty-entities nil

      ;; Babel
      org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-edit-src-content-indentation 0
      org-confirm-babel-evaluate nil
      org-src-tab-acts-natively t
      org-src-fontify-natively t

      ;; latex
      org-latex-prefer-user-labels t

      ;; noweb
      org-babel-use-quick-and-dirty-noweb-expansion t

      ;; agenda
      org-enforce-todo-dependencies t
      org-agenda-dim-blocked-tasks t
      org-enforce-todo-checkbox-dependencies t

      ;; lists and checkboxes
      org-list-allow-alphabetical t
      ;; org-checkbox-hierarchical-statistics

      ;; Scheduling and time management
      org-log-done t)
(defun turn-on-org-show-all-inline-images ()
  (org-display-inline-images t t))

(add-hook 'org-mode-hook 'turn-on-org-show-all-inline-images)
#+end_src

** Packages

#+name: org-packages
#+begin_src emacs-lisp :exports none :noweb yes
;; (use-package org-plus-contrib
;;   :ensure t)
#+end_src

** Config

#+name: org-config
#+begin_src emacs-lisp :exports none :noweb yes

;;(setq org-goto-interface 'outline
;;org-goto-max-level 10)
;; (require 'imenu)
;; (setq org-startup-folded nil)
;; (bind-key "C-c J" 'org-clock-goto) ;; jump to current task from anywhere
;; (bind-key "C-c C-w" 'org-refile)
;;(setq org-cycle-include-plain-lists 'integrate)

;; Turn on visual-line-mode for Org-mode only
;; Also install "adaptive-wrap" from elpa
(add-hook 'org-mode-hook 'turn-on-visual-line-mode)

(define-key org-mode-map (kbd "C-'") nil)
(define-key org-mode-map (kbd "C-a") nil)
(define-key org-mode-map (kbd "C-'") 'push-mark-no-activate)

#+end_src

** calendar

#+name: org-calendar
#+begin_src emacs-lisp
(message "Start org/calendar:::: %.2fs" (- (float-time) shit-load-time-start))

(use-package org-gcal
  :ensure t)

(use-package calfw
  :ensure t)
(use-package calfw-org)

(defun my-open-calendar ()
  (interactive)
  (load-file "~/.gcal-settings")
  (cfw:open-calendar-buffer
   :contents-sources
   (list
    (cfw:org-create-source "Green")  ; orgmode source
   )))
#+end_src

** Evil
#+name: org-evil
#+begin_src emacs-lisp :exports none :noweb yes
(after 'evil

  ;; (define-leader-keys 'org-mode-map-leader "o"
  ;;   "u" 'my-org-cycle-current-headline
  ;;   "i" 'org-clock-in
  ;;   "o" 'org-clock-out
  ;;   "t" 'my-org-tangle
  ;;   "a" 'org-agenda
  ;;   "b" 'helm-bibtex
  ;;   )

  (add-hook 'org-agenda-mode-hook
            (lambda ()
              (define-key org-agenda-mode-map "j" 'next-line)
              (define-key org-agenda-mode-map "k" 'previous-line))))
#+end_src
** motion

#+begin_src emacs-lisp
(message "Start org/motion:::: %.2fs" (- (float-time) shit-load-time-start))

(defhydra hydra-org-motion (:hint nil)
"
_k_: previous visible heading   _h_:       previous level  _g_: goto heading        _w_: tangle
_j_: next visible heading       _<tab>_:   heading cycle   _p_: pop heading marker  _e_: export
_i_: clock in   _P_: pomodoro    _S-<tab>_: global cycle   _t_: todo
_o_: clock out
_q_: quit
"
      ("t" org-todo)
      ("k" outline-previous-visible-heading)
      ("j" outline-next-visible-heading)
      ("h" my-org-up-heading-and-cycle)
      ("<tab>" my-org-cycle-current-headline)
      ("S-<tab>" org-global-cycle)
      ("g" helm-org-headlines)
      ("e" org-export-dispatch :color blue)
      ("w" my-org-tangle :color blue)
      ("o" org-clock-out :color blue)
      ("i" org-clock-in :color blue)
      ("P" org-pomodoro :color blue)
      ("p" org-mark-ring-goto)
      ("q" nil :color blue))

(if (featurep 'evil)
    (evil-define-key 'normal org-mode-map " o" 'hydra-org-motion/body)
  (define-key org-mode-map (kbd "C-c o") 'hydra-org-motion/body))

#+end_src

** Contacts

#+name: org-contacts
#+begin_src emacs-lisp
(use-package org-contacts)
(setq org-contacts-files '("~/src/org/contacts.org"))
#+end_src

** Capture

#+name: org-capture
#+begin_src emacs-lisp

(use-package org-capture)
(setq org-capture-templates
      '(

        ("t" "todo" entry (file+headline "~/org/todo.org" "Tasks")
         "* TODO [#A] %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n%a\n")

        ;; ("t" "Todo" entry (file+headline "~/todo.org" "Tasks")
        ;;  "* TODO %?\n  %i\n  %u\n  %a")

        ("j" "Journal" entry (file+datetree "~/src/org/journal.org")
         "* %?\nEntered on %U\n  %i\n  %a")

        ("r" "Reading" entry (file+headline "~/src/org/bibliography.org" "Reading list")
         "** %^{Todo state|FIND|PRINT|READ|NOTES} [#%^{Priority|A|B|C}] %^{Description|Reading} %^g
   %^{TITLE}p %^{AUTHOR}p %^{AREA}p %?
   :PROPERTIES:
   :Entered: %U
   :END:
"
         :prepend t)
        ))

(setq org-capture-templates
      (append '(("l" "Ledger entries")
                ("lm" "MBNA" plain
                 (file "~/personal/ledger")
                 "%(org-read-date) %^{Payee}
  Liabilities:MBNA
  Expenses:%^{Account}  %^{Amount}
")
                ("lc" "Cash" plain
                 (file "~/personal/ledger")
                 "%(org-read-date) * %^{Payee}
  Expenses:Cash
  Expenses:%^{Account}  %^{Amount}
"))
              org-capture-templates))
  #+end_src

** pomodoro

#+name: org-pomodoro
#+begin_src emacs-lisp
(message "Start org/pomodoro:::: %.2fs" (- (float-time) shit-load-time-start))

(use-package org-pomodoro
  :ensure t
  :pin melpa-stable
  :init
  (progn
    (use-package alert
      :ensure t
      :pin melpa-stable))
  :config
  (progn
    (add-hook 'org-pomodoro-break-finished-hook (lambda () (todochiku-message "Break finished" "" "" t)))
    (add-hook 'org-pomodoro-finished-hook (lambda () (todochiku-message "Pomodoro finished" "" "" t)))
    (setq org-pomodoro-length 25)
    (setq org-pomodoro-short-break-length 5)
    (setq org-pomodoro-long-break-length 30)))
#+end_src

** pdf
#+name: org-pdf
#+begin_src emacs-lisp
(use-package pdf-tools
  :ensure t)
#+end_src
** agenda

#+name: org-agenda
#+begin_src emacs-lisp
(add-hook 'org-agenda-mode-hook (lambda () (load-file "~/.org-settings")))

(setq org-agenda-prefix-format
      '((agenda  . " %(parent-directory):%i%-12:c%?-12t% s")
        (timeline  . "  % s")
        (todo  . " %i %-12:c")
        (tags  . " %i %-12:c")
        (search . " %i %-12:c")))
#+end_src

** bibliography
#+name: org-bib
#+begin_src emacs-lisp :exports none :noweb yes

(let ((file "~/.org-ref-bib-settings"))
  (if (file-exists-p file)
      (load-file file)))

(setq org-ref-notes-directory "~/bib"
      org-ref-bibliography-notes "~/bib/index.org"
      org-ref-default-bibliography '("~/bib/index.bib")
      org-ref-pdf-directory "~/bib/lib/")
(setq helm-bibtex-bibliography "~/bib/index.bib" ;; where your references are stored
      helm-bibtex-library-path "~/bib/lib/" ;; where your pdfs etc are stored
      helm-bibtex-notes-path "~/bib/index.org" ;; where your notes are stored
      bibtex-completion-bibliography "~/bib/index.bib" ;; writing completion
      bibtex-completion-notes-path "~/bib/index.org")

(require 'ox-latex)
(require 'bibtex)
;(use-package org-ref
;  :ensure t)
(define-key bibtex-mode-map (kbd "C-M-l") 'windmove-right)

(setq org-latex-title-command "\\maketitle")
(add-hook 'org-mode-hook (lambda () (org-indent-mode 1)))
(setq org-latex-pdf-process '("~/bin/latexmk -pdf %f && ~/bin/latexmk -c %f"))
(setq org-latex-listings 'minted)
(add-to-list 'org-latex-classes
             '("article-titling" "

\\documentclass[a4paper]{article}

% Default packages
[NO-DEFAULT-PACKAGES]

% Packages
[PACKAGES]

% Article
\\setlength{\\parindent}{0em}
\\setlength{\\parskip}{1em}
\\usepackage{titletoc}
\\usepackage{amssymb}




\\usepackage[T1]{fontenc}
\\usepackage{lmodern}
\\usepackage{url}
\\usepackage[svgnames]{xcolor}
%%\\ifpdf
%%  \\usepackage{pdfcolmk}
%%\\fi
%% check if using xelatex rather than pdflatex
\\ifxetex
  \\usepackage{fontspec}
\\fi
\\usepackage{graphicx}
%%\\usepackage{hyperref}
%% drawing package
\\usepackage{tikz}
%% for dingbats
\\usepackage{pifont}
\\providecommand{\\HUGE}{\\Huge}% if not using memoir
\\newlength{\\drop}% for my convenience
%% specify the Webomints family
\\newcommand*{\\wb}[1]{\\fontsize{#1}{#2}\\usefont{U}{webo}{xl}{n}}
%% select a (FontSite) font by its font family ID
\\newcommand*{\\FSfont}[1]{\\fontencoding{T1}\\fontfamily{#1}\\selectfont}
%% if you don’t have the FontSite fonts either \\renewcommand*{\\FSfont}[1]{}
%% or use your own choice of family.
%% select a (TeX Font) font by its font family ID
\\newcommand*{\\TXfont}[1]{\\fontencoding{T1}\\fontfamily{#1}\\selectfont}
%% Generic publisher’s logo
\\newcommand*{\\plogo}{\\fbox{$\\mathcal{PL}$}}
%% Some shades
\\defincolor{Dark}{gray}{0.2}
\\defincolor{MedDark}{gray}{0.4}
\\defincolor{Medium}{gray}{0.6}
\\defincolor{Light}{gray}{0.8}
%%%% Additional font series macros
\\makeatletter
%%%% light series
%% e.g., kernel doc, section s: line 12 or thereabouts
\\DeclareRobustCommand\\ltseries
  {\\not@math@alphabet\\ltseries\\relax
   \\fontseries\\ltdefault\\selectfont}
%% e.g., kernel doc, section t: line 32 or thereabouts
\\newcommand{\\ltdefault}{l}
%% e.g., kernel doc, section v: line 19 or thereabouts
\\DeclareTextFontCommand{\\textlt}{\\ltseries}
% heavy(bold) series
\\DeclareRobustCommand\\hbseries
  {\\not@math@alphabet\\hbseries\\relax
   \\fontseries\\hbdefault\\selectfont}
\\newcommand{\\hbdefault}{hb}
\\DeclareTextFontCommand{\\texthb}{\\hbseries}
\\makeatother




\\usepackage[toc]{glossaries}
\\makeglossaries
\\bibliographystyle{plain}

\\usepackage{fancyhdr}
\\pagestyle{fancy}

\\lhead{}
\\chead{}
\\rhead{}
\\lfoot{\\bfseries Donavan-Ross Costaras}
\\cfoot{\\today}
\\rfoot{\\thepage}
\\renewcommand{\\headrulewidth}{0pt}
\\renewcommand{\\footrulewidth}{0.4pt}

\\usepackage{hyperref}
\\hypersetup{
colorlinks=true,
linkcolor=blue,
filecolor=blue,
urlcolor=blue,
citecolor=blue
}

\\urlstyle{same}
% Extras
[EXTRA]
"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))


(add-to-list 'org-latex-classes
             '("title-page" "

%----------------------------------------------------------------------------------------
%       PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\\documentclass{scrartcl}

\\newcommand*{\\plogo}{\\fbox{$\\mathcal{HUPU}$-foo$\\mathcal{LABS}$}} % Generic publisher logo

%----------------------------------------------------------------------------------------
%       TITLE PAGE
%----------------------------------------------------------------------------------------


\\setlength{\\parindent}{0em}
\\setlength{\\parskip}{1em}
\\usepackage{hyperref}
\\usepackage{amssymb}
\\usepackage{graphicx}
\\usepackage{titling}
\\usepackage{textcomp}
\\usepackage[margin=1in]{geometry}

\\hypersetup{
   colorlinks=true,
   linkcolor=blue,
   filecolor=blue,
   urlcolor=blue,
   citecolor=blue
}

\\urlstyle{same}

\\usepackage[toc]{glossaries}
\\makeglossaries
\\bibliographystyle{plain}

\\usepackage{fancyhdr}
\\pagestyle{fancy}

\\lhead{}
\\chead{}
\\rhead{}
\\lfoot{}
\\cfoot{\\thepage}
\\rfoot{}
\\renewcommand{\\headrulewidth}{0pt}
\\renewcommand{\\footrulewidth}{0pt}

[NO-DEFAULT-PACKAGES]
[EXTRA]

\\newcommand*{\\maketitlepage}{\\begingroup % Create the command for including the title page in the document
\\hbox{ % Horizontal box
\\hspace*{0.2\\textwidth} % Whitespace to the left of the title page
\\rule{1pt}{\\textheight} % Vertical line
\\hspace*{0.05\\textwidth} % Whitespace between the vertical line and title page text
\\parbox[b]{0.75\\textwidth}{ % Paragraph box which restricts text to less than the width of the page

{\\noindent\\Huge\\textbf{Southern Africa Litigation Centre}}\\\\[2\\baselineskip] % Title
{\\large \\textit{A concept proposal}}\\\\[4\\baselineskip] % Tagline or further description
{\\Large \\textsc{\\theauthor}} % Author name

\\vspace{0.5\\textheight} % Whitespace between the title block and the publisher

{\\noindent \\textcopyright~{\\the\\year}~Hupu-Labs }\\\\[\\baselineskip] % Publisher and logo
}}
\\thispagestyle{empty}
\\endgroup}
"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(defun org-latex-inline-src-block (inline-src-block contents info)
  "Transcode an INLINE-SRC-BLOCK element from Org to LaTeX.
CONTENTS holds the contents of the item.  INFO is a plist holding
contextual information."
  (let* ((code (org-element-property :value inline-src-block))
         (separator (org-latex--find-verb-separator code)))
    (case (plist-get info :latex-listings)
      ;; Do not use a special package: transcode it verbatim.
      ((nil) (format "\\texttt{%s}" (org-latex--protect-text code)))
      ;; Use minted package.
      (minted
       (let* ((org-lang (org-element-property :language inline-src-block))
              (mint-lang (or (cadr (assq (intern org-lang)
                                         (plist-get info :latex-minted-langs)))
                             (downcase org-lang)))
              (options (org-latex--make-option-string
                        (plist-get info :latex-minted-options))))
         (concat (format "\\mintinline%s{%s}"
                         (if (string= options "") "" (format "[%s]" options))
                         mint-lang)
                 separator code separator)))
      ;; Use listings package.
      (otherwise
       ;; Maybe translate language's name.
       (let* ((org-lang (org-element-property :language inline-src-block))
              (lst-lang (or (cadr (assq (intern org-lang)
                                        (plist-get info :latex-listings-langs)))
                            org-lang))
              (options (org-latex--make-option-string
                        (append (plist-get info :latex-listings-options)
                                `(("language" ,lst-lang))))))
         (concat (format "\\lstinline[%s]" options)
                 separator code separator))))))

#+end_src

** acronym mode
#+begin_src emacs-lisp

(defvar-local acronym-alist nil
  "Alist of symbol prettifications.
Each element looks like (SYMBOL . CHARACTER), where the symbol
matching SYMBOL (a string, not a regexp) will be shown as
CHARACTER instead.")

(defvar acronym-alist '(
                        ("gls:ELRC" "Environ")

                        ))

(defun acronym--compose-symbol (alist)
  "Compose a sequence of characters into a symbol.
Regexp match data 0 points to the chars."
  ;; Check that the chars should really be composed into a symbol.
  (let* ((start (match-beginning 0))
         (end (match-end 0))
         (syntaxes (if (eq (char-syntax (char-after start)) ?w)
                       '(?w ?_) '(?. ?\\)))
         match)
    (if (or (memq (char-syntax (or (char-before start) ?\s)) syntaxes)
            (memq (char-syntax (or (char-after end) ?\s)) syntaxes)
            ;; syntax-ppss could modify the match data (bug#14595)
            (progn (setq match (match-string 0)) (nth 8 (syntax-ppss))))
        ;; No composition for you.  Let's actually remove any composition
        ;; we may have added earlier and which is now incorrect.
        (remove-text-properties start end '(composition))
      ;; That's a symbol alright, so add the composition.
      (compose-region start end (cdr (assoc match alist)))))
  ;; Return nil because we're not adding any face property.
  nil)

(defun acronym--make-keywords ()
  (if acronym-alist
      `((,(regexp-opt (mapcar 'car acronym-alist) t)
         (0 (acronym--compose-symbol ',acronym-alist))))
    nil))

(defvar-local acronym--keywords nil)

;;;###autoload
(define-minor-mode acronym-mode
  "Toggle Acronym Symbols mode.
With a prefix argument ARG, enable Acronym Symbols mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

When Acronym Symbols mode and font-locking are enabled, symbols are
prettified (displayed as composed characters) according to the rules
in `acronym-alist' (which see), which are locally defined
by major modes supporting acronyming.  To add further customizations
for a given major mode, you can modify `acronym-alist' thus:

  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (push '(\"<=\" . ?≤) acronym-alist)))

You can enable this mode locally in desired buffers, or use
`global-acronym-mode' to enable it for all modes that
support it."
  :init-value nil
  (if acronym-mode
      ;; Turn on
      (when acronym-alist
        (font-lock-add-keywords nil acronym-alist)
        (setq-local font-lock-extra-managed-props
                    (cons 'composition font-lock-extra-managed-props))
        (font-lock-fontify-buffer))
    ;; Turn off
    (when acronym--keywords
      (font-lock-remove-keywords nil acronym--keywords)
      (setq acronym--keywords nil))
    (when (memq 'composition font-lock-extra-managed-props)
      (setq font-lock-extra-managed-props (delq 'composition
                                                font-lock-extra-managed-props))
      (with-silent-modifications
        (remove-text-properties (point-min) (point-max) '(composition nil))))))

(defun turn-on-acronym-mode ()
  (when (and (not acronym-mode)
             (local-variable-p 'acronym-alist))
    (acronym-mode 1)))

;;;###autoload
(define-globalized-minor-mode global-acronym-mode
  acronym-mode turn-on-acronym-mode)
#+end_src
** Drill
#+begin_src emacs-lisp
;(require 'org-drill)
;;(setq org-drill-save-buffers-after-drill-sessions-p nil)
#+end_src
** Mobile Org
#+begin_src emacs-lisp
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Mobile org

      ;; Set to the name of the file where new notes will be stored
      ;; Set to <your Dropbox root directory>/MobileOrg.
      (setq
       org-mobile-directory "~/Dropbox/mobileorg"
       org-mobile-index-file "~/Dropbox/mobileorg/index.org"
       org-mobile-inbox-for-pull "~/Dropbox/mobileorg/flagged.org"
       )
  #+end_src
** Babel

#+NAME: org-babel
#+begin_src emacs-lisp

  ;; (require 'ob-mathematica)
  ;; (require 'ob-maxima)
  (defun tangle-on-save-org-mode-file()
    (when (string= (message "%s" major-mode) "org-mode")
      (org-babel-tangle)))

  (add-hook 'after-save-hook 'tangle-on-save-org-mode-file)


  ;; syntax highlighting in export src blocks
  (defun my/org-inline-css-hook (exporter)
    "Insert custom inline css to automatically set the
  background of code to whatever theme I'm using's background"
    (when (eq exporter 'html)
      (let* ((my-pre-bg (face-background 'default))
             (my-pre-fg (face-foreground 'default)))
        (setq
         org-html-head-extra
         (concat
          org-html-head-extra
          (format "<style type=\"text/css\">\n pre.src {background-color: %s; color: %s;}</style>\n"
                  my-pre-bg my-pre-fg))))))

  (add-hook 'org-export-before-processing-hook 'my/org-inline-css-hook)
  ;; active Babel languages
(setq org-confirm-babel-evaluate
      (lambda (lang body)
        (not (or (string= lang "sql-mode")
                 (string= lang "http")
                 (string= lang "sql")
                 (string= lang "clojure")))))
  (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     ;; (maxima . t)
     ;; (mathematica . t)
     ;; (latex . t)
     ;; (python . t)
     ;; (sass .t)
      (sql . t)
     ;; (js . t)
     ;; (shell . t)
     ;; (scala . t)
     ;; (dot . t)
      (clojure . t)
     ;; (gnuplot . t)
     ;; (http . t)
     ;; (csharp . t)
     ;; (ditaa . t)
      (dot . t)
     ;; (plantuml . t)
     ;; (scheme . t)
     ))
  (setq org-babel-clojure-backend 'cider)
  (setq org-src-window-setup 'current-window)
  (setq org-confirm-babel-evaluate nil)
  (setq org-babel-clojure-sync-nrepl-timeout nil)

  (defun my/org-inline-css-hook (exporter)
    "Insert custom inline css to automatically set the
  background of code to whatever theme I'm using's background"
    (when (eq exporter 'html)
      (let* ((my-pre-bg (face-background 'default))
             (my-pre-fg (face-foreground 'default)))
        (setq
         org-html-head-extra
         (concat
          org-html-head-extra
          (format "<style type=\"text/css\">\n pre.src {background-color: %s; color: %s;}</style>\n"
                  my-pre-bg my-pre-fg))))))

  (add-hook 'org-export-before-processing-hook 'my/org-inline-css-hook)
#+end_src

** Functions

#+name: org-functions
#+begin_src emacs-lisp :noweb yes
(message "org-functios")

(defmacro progn-src (true-body false-body)
  `(if (org-src-edit-buffer-p)
       (progn
         (org-edit-src-exit)
         ,@true-body)
     (progn ,@false-body)))

(defun up-heading-and-cycle ()
  (interactive)
  (org-up-heading-safe)
  (my-org-cycle-current-headline))

(defun save ()
  (interactive)
  (progn-src
   (org-edit-src-save)
   (save-buffer)))

(defun tangle ()
  (interactive)
  (if (org-src-edit-buffer-p)
      (progn
        (org-edit-src-exit)
        (org-babel-tangle)
        (org-edit-src-code))
    (org-babel-tangle)))

(defun control-c-control-c ())

(defun cycle-current-headline ()
  (interactive)
  (if (looking-at "*")
      (org-cycle)
    (progn
      (outline-previous-heading)
      (org-cycle))))
#+end_src

*** Tangle file function

#+begin_src emacs-lisp
  (defvar my-org-tangle-switch nil)

  (defun my-tangle-file ()
    (interactive)
    (cond (my-org-tangle-switch
           (org-babel-tangle-file my-org-tangle-switch))
          ((string-match "init.org" buffer-file-name)
           (progn
             (org-babel-tangle-file "~/.emacs.d/init.org")
             (byte-compile-file "~/.emacs.d/init.el")))))

 ; (global-set-key (kbd "M-, t") 'my-tangle-file)

#+end_src

*** TODO write function to clean up org init file

#+begin_src emacs-lisp
(defconst init-org-src-clean-rx
'(and

  (group bol (+ "*") " " (+? (or word space "-")) eol)
  (opt (* (syntax whitespace)))

  (group (*? anything))
  (opt (* (syntax whitespace)))

  (group bol (and "#+begin_src " "emacs-lisp") (*? any) eol)
  (opt (* (syntax whitespace)))

  (group (*? anything))
  (opt (* (syntax whitespace)))

  (group (and "#+end_" "src"))
  (opt (* (syntax whitespace)))))

(defun clean-org-src-file-global ()
  (interactive)
  (save-excursion
    (goto-char 1)
    (while (search-forward-regexp (rx-to-string init-org-src-clean-rx) nil t)
      (replace-match (concat
                      (match-string 1) "\n"
                      (if (s-blank? (match-string 2))
                          (concat "\n")
                        (concat "\n" (match-string 2) "\n\n"))
                      (match-string 3) "\n"
                      (match-string 4) "\n"
                      (match-string 5) "\n" "\n")
                     t nil))))

#+end_src

**** TODO learn how to use m-buffer to replace text between markers from matches

** Ditaa
#+begin_src emacs-lisp
;(message "ditaa:::: %.2fs" (- (float-time) shit-load-time-start))

;(setq org-ditaa-jar-path "~/.emacs.d/jar/ditaa0_9.jar")
;(setq ditaa-cmd "java -jar ~/.emacs.d/jar/ditaa0_9.jar")
;(defun djcb-ditaa-generate ()
;  (interactive)
;  (shell-command
;    (concat ditaa-cmd " " buffer-file-name)))
#+end_src

** PlantUML

#+name: org-plantuml
#+begin_src emacs-lisp :noweb yes
(message "org/plantuml:::: %.2fs" (- (float-time) shit-load-time-start))

(use-package plantuml-mode
  :ensure t
  :init
  (progn
    (setq
plantuml-jar-path "/usr/local/Cellar/plantuml/8018/plantuml.8018.jar"
org-plantuml-jar-path plantuml-jar-path
)))
#+end_src

* Markdown

  #+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(use-package markdown-mode
:ensure t
:mode (("README\\.md\\'" . gfm-mode)
	("\\.md\\'" . markdown-mode)
	("\\.markdown\\'" . markdown-mode))
:init (setq markdown-command "multimarkdown"))

(defhydra dh-hydra-markdown-mode (:hint nil)
    "
Formatting        C-c C-s    _s_: bold          _e_: italic     _b_: blockquote   _p_: pre-formatted    _c_: code

Headings          C-c C-t    _h_: automatic     _1_: h1         _2_: h2           _3_: h3               _4_: h4

Lists             C-c C-x    _m_: insert item

Demote/Promote    C-c C-x    _l_: promote       _r_: demote     _u_: move up      _d_: move down

Links, footnotes  C-c C-a    _L_: link          _U_: uri        _F_: footnote     _W_: wiki-link      _R_: reference

"


    ("s" markdown-insert-bold)
    ("e" markdown-insert-italic)
    ("b" markdown-insert-blockquote :color blue)
    ("p" markdown-insert-pre :color blue)
    ("c" markdown-insert-code)

    ("h" markdown-insert-header-dwim)
    ("1" markdown-insert-header-atx-1)
    ("2" markdown-insert-header-atx-2)
    ("3" markdown-insert-header-atx-3)
    ("4" markdown-insert-header-atx-4)

    ("m" markdown-insert-list-item)

    ("l" markdown-promote)
    ("r" markdown-demote)
    ("d" markdown-move-down)
    ("u" markdown-move-up)

    ("L" markdown-insert-link :color blue)
    ("U" markdown-insert-uri :color blue)
    ("F" markdown-insert-footnote :color blue)
    ("W" markdown-insert-wiki-link :color blue)
    ("R" markdown-insert-reference-link-dwim :color blue)
)

(global-set-key [f9] 'dh-hydra-markdown-mode/body)
  #+end_src

* Lisps
  #+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (message "Lisps:::: %.2fs" (- (float-time) shit-load-time-start))

  ;; (defvar cool-fg       "#ffffff")
  ;; (defvar cool-bg       "#18191B")
  ;; (defvar cool-green-0  "#95ff94")
  ;; (defvar cool-green-1  "#25492D")
  ;; (defvar cool-orange-0 "#ED7200")
  ;; (defvar cool-yellow-0 "#f9fe8a")
  ;; (defvar cool-yellow-1 "#fec952")
  ;; (defvar cool-red-0    "#f5666d")
  ;; (defvar cool-pink-0   "#F74D97")
  ;; (defvar cool-pink-1   "#FA519A")
  ;; (defvar cool-pink-2   "#FD8DBD")
  ;; (defvar cool-purple-0 "#a8799c")
  ;; (defvar cool-blue-0   "#a3beff")
  ;; (defvar cool-blue-1   "#9cd4fc")
  ;; (defvar cool-blue-2   "#8ca0fd")
  ;; (defvar cool-blue-3   "#acb3eF")

  (use-package rainbow-delimiters
    :ensure t)

  (use-package paredit
    :ensure t)

  (use-package aggressive-indent
    :ensure t)

  (use-package lispy
    :ensure t
    :pin melpa-stable
    :general
    (:keymaps 'lispy-mode-map
	      "M-," nil)
    :config
    (progn
      (defun conditionally-enable-lispy ()
	(when (eq this-command 'eval-expression)
	  (lispy-mode 1)))
      (add-hook 'minibuffer-setup-hook 'conditionally-enable-lispy)))

  (use-package lispyville
    :ensure t
    :pin melpa-stable
    :after lispy
    :config
    (progn
      (lispyville-set-key-theme
       '(operators
	 c-w
	 prettify
	 additional-motions
	 additional-insert
	 commentary
	 slurp/barf-lispy))
      (add-hook 'lispy-mode-hook #'lispyville-mode)))

  (defun my-lisp-mode-hook ()
    (rainbow-delimiters-mode)
    (aggressive-indent-mode)
    (show-paren-mode)
    (lispy-mode))

  (general-add-hook
   '(scheme-mode-hook
     emacs-lisp-mode-hook
     reb-lisp-mode-hook
     clojure-mode-hook
     lisp-mode-hook)
   #'my-lisp-mode-hook)

  (defun my-lisp-repl-mode-hook ()
    (rainbow-delimiters-mode)
    (aggressive-indent-mode nil)
    (show-paren-mode)
    (lispy-mode))

  (general-add-hook '(cider-repl-mode-hook) #'my-lisp-repl-mode-hook)
  #+end_src

** Scheme
#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(setq scheme-program-name "scheme --band /Applications/Scheme.app/Contents/Resources/all.com")
#+end_src
** Clojure
*** package

#+begin_src emacs-lisp :noweb yes :tangle ~/.emacs.d/init.el
(message "Clojure:::: %.2fs" (- (float-time) shit-load-time-start))
(use-package clojure-mode
:commands clojure-mode
:mode ("\\.boot\\'" . clojure-mode)
:ensure t
:init
(progn
    ;; (add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)
    )
:config
(progn
    ;; (setq clojure-defun-style-default-indent t)
    ;; <<clojure-keys>>
    <<clojure-cider>>
    ;; <<clojure-refactor>>
    <<clojure-flycheck>>
    <<clojure-config>>
    ))
#+end_src

*** keys

#+name: clojure-keys
#+begin_src emacs-lisp
;; (add-to-list 'auto-mode-alist '("\.cljs$" . clojurescript-mode))
;; (add-to-list 'auto-mode-alist '("\.boot$" . clojure-mode))
;; (add-hook 'clojure-mode (lambda ()
;;                           (local-set-key (kbd "C-x C-e")
;;                                          ())))

;; (defhydra clojure-x-map ()
;;   ("e" cider-eval-defn "eval defn" :color blue)
;;   ("h" mark-whole-buffer :color blue))


;; (if (featurep 'evil)
;;     (evil-define-key 'normal clojure-mode-map " x" 'clojure-x-map/body)
;;   (define-key org-mode-map (kbd "C-c x") 'clojure-x-map/body))
#+end_src

*** TODO babel

#+name: clojure-babel
#+begin_src emacs-lisp

(setq org-babel-clojure-backend 'cider)
(defun org-babel-execute:clojure (body params)
"Execute a block of Clojure code with Babel."
(let ((expanded (org-babel-expand-body:clojure body params))
    result)
(case org-babel-clojure-backend
    (cider
    (require 'cider)
    (let ((result-params (cdr (assoc :result-params params))))
	(setq result
	    (nrepl-dict-get
	    (nrepl-sync-request:eval expanded)
	    (if (or (member "output" result-params)
		    (member "pp" result-params))
		"out"
		"value")))))
    )
(org-babel-result-cond (cdr (assoc :result-params params))
    result
    (condition-case nil (org-babel-script-escape result)
    (error result)))))
#+end_src

*** flycheck

#+name: clojure-flycheck
#+begin_src emacs-lisp
(use-package flycheck-clojure
:ensure t)

(after 'flycheck (flycheck-clojure-setup))

#+end_src

*** cider

#+name: clojure-cider
#+begin_src emacs-lisp
(use-package cider
:ensure t
:pin melpa-stable
:general ("C-c C-c" 'cider-eval-defn)
:config
(progn

    (setq cider-boot-parameters "dev")
    (setq cider-auto-select-test-report-buffer nil)
    (setq cider-repl-history-file "~/.emacs.d/var/cider-history")
    (setq cider-repl-use-clojure-font-lock t)
    (setq cider-repl-wrap-history t)
    (setq nrepl-log-messages t)
    (setq cider-show-error-buffer nil)

    (defun cider-eval-test-and-run ()
    (interactive)
    (cider-eval-defun-at-point)
    (cider-test-run-test))

    (evil-define-key 'normal clojure-mode-map (kbd "C-c C-c") 'cider-eval-test-and-run)

    (add-to-list 'aggressive-indent-excluded-modes 'cider-repl-mode)

    (add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion)
    (add-hook 'cider-test-report-mode-hook #'visual-line-mode)

    ;; (setq cider-cljs-lein-repl
    ;;       "(do (require 'figwheel-sidecar.repl-api)
    ;;        (figwheel-sidecar.repl-api/start-figwheel!)
    ;;        (figwheel-sidecar.repl-api/cljs-repl))")

    (define-key cider-mode-map (kbd "M-,") nil)
    (add-hook 'cider-mode-hook #'eldoc-mode)

    (defun cider-eval-defn ()
    (interactive)
    (save-excursion
	(mark-defun)
	(cider-eval-region (region-beginning)
			    (region-end))))))
#+end_src

*** clj-refactor

#+name: clojure-refactor
#+begin_src emacs-lisp
(use-package clj-refactor
:ensure t
:config
(progn

;; (use-package cljr-helm
;;   :ensure t)

(defun my-clj-refactor-mode-hook ()
    (clj-refactor-mode 1)
    (yas-minor-mode 1) ; for adding require/use/import
    ;; (cljr-add-keybindings-with-prefix " o")
    )
(add-hook 'clojure-mode-hook #'my-clj-refactor-mode-hook)))
#+end_src

*** Clojurescript

#+name: clojurescript-save
#+begin_src emacs-lisp
;; (defun save-all ()
;;   (interactive)
;;   (save-some-buffers t))
;; (add-hook 'focus-out-hook 'save-all)
#+end_src

*** motion

#+name: clojure-hydra
#+begin_src emacs-lisp
(message "Start clojure/motion:::: %.2fs" (- (float-time) shit-load-time-start))

(defhydra hydra-clojure-motion (:hint nil)
"
_f_: cider stop
_q_: quit
"
    ("f" my-cider-stop)
    ("q" nil :color blue))

(if (featurep 'evil)
(evil-define-key 'normal clojure-mode-map " o" 'hydra-clojure-motion/body)
(define-key clojure-mode-map (kbd "C-c o") 'hydra-clojure-motion/body))
#+end_src

*** functions

#+name: clojure-functions
#+begin_src emacs-lisp
(defun my-cider-stop ()
(interactive)
(cider-interactive-eval "(stop)"))
#+end_src

*** config
#+name: clojure-config
#+begin_src emacs-lisp
;; (require 'align-cljlet)

;; Configure nrepl.el
(setq nrepl-hide-special-buffers t)
(setq nrepl-popup-stacktraces-in-repl t)
(setq nrepl-history-file "~/.emacs.d/var/nrepl-history")

(defface my/highlight
  '((t :foreground "#F92672"))
  "My highlighting")

(defun my/highlight-words ()
  "Use hi-lock to highlight specific words"
  (hi-lock-face-buffer "\\(and-paths\\|or-paths\\|cond-path\\)" 'my/highlight))

(add-hook 'clojure-mode-hook #'my/highlight-words)


;; (eval-after-load 'clojure-mode
;;   '(font-lock-add-keywords
;;     'clojure-mode `(("(\\(fn\\)[\[[:space:]]"
;;                      (0 (progn (compose-region (match-beginning 1)
;;                                                (match-end 1) "λ")
;;                                nil))))))

;; (eval-after-load 'clojure-mode
;;   '(font-lock-add-keywords
;;     'clojure-mode `(("\\(#\\)("
;;                      (0 (progn (compose-region (match-beginning 1)
;;                                                (match-end 1) "ƒ")
;;                                nil))))))

;; (eval-after-load 'clojure-mode
;;   '(font-lock-add-keywords
;;     'clojure-mode `(("\\(#\\){"
;;                      (0 (progn (compose-region (match-beginning 1)
;;                                                (match-end 1) "∈")
;;                                nil))))))

;; (add-hook 'clojure-mode-hook
;;           (lambda ()
;;             (setq buffer-save-without-query t)))

#+end_src
** Emacs lisp

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(message "Elisp:::: %.2fs" (- (float-time) shit-load-time-start))
(use-package emacs-lisp-mode
:interpreter (("emacs" . emacs-lisp-mode))
:config
(progn

;;(define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-defun)

(use-package eldoc
    :init (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode))
(use-package macrostep
    :bind ("C-c e" . macrostep-expand))
(use-package ert
    :config (add-to-list 'emacs-lisp-mode-hook 'ert--activate-font-lock-keywords))

;; (autoload 'cider--make-result-overlay "cider-overlays")

;; (defun endless/eval-overlay (value point)
;;   (cider--make-result-overlay (format "%S" value)
;;                               :where point
;;                               :duration 'command)
;;   ;; Preserve the return value.
;;   value)

;; (advice-add 'eval-region :around
;;             (lambda (f beg end &rest r)
;;               (endless/eval-overlay
;;                (apply f beg end r)
;;                end)))

;; (advice-add 'eval-last-sexp :filter-return
;;             (lambda (r)
;;               (endless/eval-overlay r (point))))

;; (advice-add 'eval-defun :filter-return
;;             (lambda (r)
;;               (endless/eval-overlay
;;                r
;;                (save-excursion
;;                  (end-of-defun)
;;                  (point)))))
))
;; <<auto-compile>>
;; <<eval-line>>
;; <<company-elisp>>
#+end_src

*** Auto-compile

#+name: auto-compile
#+begin_src emacs-lisp
(require 'auto-compile)

(auto-compile-on-load-mode 1)
(auto-compile-on-save-mode 1)
#+end_src

*** Eval line

#+name: eval-line
#+begin_src emacs-lisp
(defun my-eval-line ()
    (interactive)
    (save-excursion
    (end-of-line)
    (eval-last-sexp nil)))

(define-key emacs-lisp-mode-map (kbd "C-x C-e") 'my-eval-line)
(add-hook 'org-mode-hook (lambda ()
(define-key org-mode-map (kbd "C-x C-e") 'my-eval-line)))


(defun describe-function-in-popup ()
(interactive)
(let ((description (save-window-excursion
		    (describe-function (symbol-at-point))
		    (switch-to-buffer "*Help*")
		    (buffer-string))))
(popup-tip description
	    :point (point)
	    :around t
	    :height 30
	    :scroll-bar t
	    :margin t)))

(define-key emacs-lisp-mode-map (kbd "C-c C-d") 'describe-function-in-popup)
(define-key org-mode-map (kbd "C-c C-d") 'org-deadline)
(add-hook 'org-mode-hook (lambda ()(define-key org-mode-map (kbd "C-c C-d") 'describe-function-in-popup)))
#+end_src

*** Company elisp backend

#+name: company-elisp
#+begin_src emacs-lisp
(defun company-elisp-finder-keyword-backend (command &optional arg &rest ign)
"`company-backend' for finder-keywords."
(case command
    (prefix
    (and (require 'finder nil t)
	(or (company-grab ":group '\\(\\(\\sw\\|\\s_\\)*\\)" 1)
	    (company-grab "Keywords:.*[ \t]+\\(\\(\\sw\\|\\s_\\)*\\)" 1))))
    (candidates (all-completions arg finder-known-keywords))
    (meta (cdr (assoc (intern arg) finder-known-keywords)))))

(add-to-list 'company-backends 'company-elisp-finder-keyword-backend)

#+end_src

* BNF

(add-hook 'after-save-hook (lambda () (cider-load-buffer (get-buffer "query_parser.cljc<carpenter>"))) nil t)

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(defun my-bnf-mode-hook ()
  (font-lock-add-keywords
   'bnf-mode '(("(\\*.*\\*)" 0 'font-lock-comment-face t)))
  (setq comment-start "(* ")
  (setq comment-end " *)"))

(add-hook 'bnf-mode-hook 'my-bnf-mode-hook)
#+end_src

* SQL

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
(setq sql-mysql-options (list "--protocol=tcp"))

(setq sql-mysql-login-params
    '((user :default "award_shdb")
    (password :default "root")
    (database :default "award_shdb")
    (server :default "127.0.0.1")
    (port :default 3306)))
#+end_src

* Debug

#+begin_src emacs-lisp
(setq debug-on-error nil)
#+end_src

* spacemacs

  #+begin_src emacs-lisp
    ;; -*- lexical-binding: t; -*-
  #+end_src

** Theming

   #+begin_src emacs-lisp
     (setq theming-modifications
           '((monokai
              (sp-show-pair-match-face :foreground "#F92672")

              (default ((((class color) (min-colors 257)) (:foreground "#F8F8F2" :background "#272822")) (((class color) (min-colors 89)) (:foreground "#F5F5F5" :background "#1B1E1C"))))
              (ediff-current-diff-C ((t (:background "selectedKnobColor"))))
              (org-agenda-restriction-lock ((t (:background "#555"))))
              (org-mode-line-clock ((t (:background "grey75" :foreground "red" :box (:line-width -1 :style released-button)))))
              ;; (org-mode-line-clock ((t (:background "grey75" :foreground "red" :box (:line-width -1 :style released-button)))) t)

              )))
   #+end_src

** Macros

   #+begin_src emacs-lisp
     (defmacro after (feature &rest body)
       "After FEATURE is loaded, evaluate BODY."
       (declare (indent defun))
       `(eval-after-load ,feature
          '(progn ,@body)))
   #+end_src

** Functions
*** generators
**** UUID

     #+BEGIN_SRC emacs-lisp
       (defun random-uuid ()
         (interactive)
         (replace-regexp-in-string "\n$" "" (shell-command-to-string "uuidgen")))
     #+END_SRC

**** strings

     #+BEGIN_SRC emacs-lisp
       (defun random-alnum ()
         (let* ((alnum "abcdefghijklmnopqrstuvwxyz0123456789")
                (i (% (abs (random)) (length alnum))))
           (substring alnum i (1+ i))))

       (defun random-string (num)
         (interactive)
         (string-join (cl-loop for i
                               from 1 to num
                               collect (random-alnum))))
     #+END_SRC

*** discover keybindings

    #+BEGIN_SRC emacs-lisp
      (defun locate-key-binding (key)
        "Determine in which keymap KEY is defined."
        (interactive "kPress key: ")
        (let ((ret
               (list
                (key-binding-at-point key)
                (minor-mode-key-binding key)
                (local-key-binding key)
                (global-key-binding key))))
          (when (called-interactively-p 'any)
            (message "At Point: %s\nMinor-mode: %s\nLocal: %s\nGlobal: %s"
                     (or (nth 0 ret) "")
                     (or (mapconcat (lambda (x) (format "%s: %s" (car x) (cdr x)))
                                    (nth 1 ret) "\n             ")
                         "")
                     (or (nth 2 ret) "")
                     (or (nth 3 ret) "")))
          ret))
      (defun key-binding-at-point (key)
        (mapcar (lambda (keymap) (when (keymapp keymap)
                                   (lookup-key keymap key)))
                (list
                 ;; More likely
                 (get-text-property (point) 'keymap)
                 (mapcar (lambda (overlay)
                           (overlay-get overlay 'keymap))
                         (overlays-at (point)))
                 ;; Less likely
                 (get-text-property (point) 'local-map)
                 (mapcar (lambda (overlay)
                           (overlay-get overlay 'local-map))
                         (overlays-at (point))))))

      (defun keymaps-at-point ()
        "List entire keymaps present at point."
        (interactive)
        (let ((map-list
               (list
                (mapcar (lambda (overlay)
                          (overlay-get overlay 'keymap))
                        (overlays-at (point)))
                (mapcar (lambda (overlay)
                          (overlay-get overlay 'local-map))
                        (overlays-at (point)))
                (get-text-property (point) 'keymap)
                (get-text-property (point) 'local-map))))
          (apply #'message
                 (concat
                  "Overlay keymap: %s\n"
                  "Overlay local-map: %s\n"
                  "Text-property keymap: %s\n"
                  "Text-property local-map: %s")
                 map-list)))
    #+END_SRC


*** save and compile

    #+BEGIN_SRC emacs-lisp
(defun save-all-and-compile ()
  (interactive)
  (save-some-buffers 1)
  (helm-make-projectile 1))

(spacemacs/set-leader-keys
  "c c" 'save-all-and-compile)
    #+END_SRC

** major modes

   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.blade.php\\'" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.mjml\\'" . web-mode))
     (add-to-list 'auto-mode-alist '("\\(/\\|\\`\\)[Mm]akefile" . makefile-gmake-mode))
     (add-to-list 'auto-mode-alist '("\\.ml\\'" . makefile-gmake-mode))
   #+end_src

** jump to mark

   #+begin_src emacs-lisp
     (defun jump-to-mark ()
       "Jumps to the local mark, respecting the 'mark-ring' order.
             This is the same as using \\[set-mark-command] with the prefix argument."
       (interactive)
       (set-mark-command 1))

     (defun push-mark-no-activate ()
       "Pushes 'point' to 'mark-ring' and does not activate the region
             Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
       (interactive)
       (push-mark (point) t nil)
       (message "Pushed mark to ring"))

     (defun exchange-point-and-mark-no-activate ()
       "Identical to \\[exchange-point-and-mark] but will not activate the region."
       (interactive)
       (exchange-point-and-mark)
       (deactivate-mark nil))
     (define-key global-map [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)

     (global-set-key (kbd "C-'") 'push-mark-no-activate)
     (global-set-key (kbd "M-'") 'jump-to-mark)
   #+end_src

** Line numbers

   #+begin_src emacs-lisp
;; (setq-default display-line-numbers 'relative)
;; (setq display-line-numbers-type 'visual)
(global-display-line-numbers-mode)
   #+end_src

** Whitespace

   #+begin_src emacs-lisp
     (use-package ethan-wspace
       :init (setq-default
              require-final-newline nil
              mode-require-final-newline nil)
       :config (global-ethan-wspace-mode 1)
       :ensure t)
   #+end_src

** Sort region

   #+BEGIN_SRC emacs-lisp
     (defun sort-region (start end)
       (interactive "r")
       (save-excursion
         (narrow-to-region start end)
         (sort-lines nil (point-min) (point-max))
         (widen)))
   #+END_SRC

** Shell environment

   #+BEGIN_SRC sh
     BASH_ENV="~/.spacemacs.d/bashrc.sh" exec bash "$@"
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     ;; (setq shell-file-name "~/.spacemacs.d/emacs-shell.sh")
     ;; (setq shell-file-name "/usr/local/bin/bash")
     ;; (setq shell-command-switch "-c")
   #+END_SRC

*** Env vars

    #+begin_src emacs-lisp
      (setenv "EMAIL" "d.costaras@gmail.com")
      ;; (setenv "SSH_AUTH_SOCK" "/Users/donavan/.gnupg/S.gpg-agent.ssh")
      (setenv "BACKUP_LOCATION" "SpiderOak\\ Hive")
      ;;(setenv "BOOT_JVM_OPTIONS" "--add-modules java.xml.bind")
      (setenv "BOOT_JVM_OPTIONS" "-XX:-OmitStackTraceInFastThrow")
    #+end_src

** Fullscreen

   #+BEGIN_SRC emacs-lisp
     (setq ns-use-native-fullscreen nil)
   #+END_SRC

** Prodigy

   #+begin_src emacs-lisp
     (add-hook 'prodigy-view-mode-hook (lambda () (spacemacs/toggle-truncate-lines-on)))

     ;; (defun prodigy-insert-output (service output)
     ;;   "Switch to SERVICE process view buffer and insert OUTPUT."
     ;;   (prodigy-with-service-process-buffer service
     ;;     (let ((output (prodigy-process-output output)))
     ;;       (if output
     ;;           (let ((current-position (point))
     ;;                 (at-buffer-end (equal (point) (point-max))))
     ;;             (goto-char (point-max))
     ;;             (insert output)
     ;;             (unless at-buffer-end
     ;;               (goto-char current-position)))))))

     (setq my-prodigy-truncate-amount 5000
           my-prodigy-truncate-threshold 15000)
     ;; NOTE overriden
     (defun prodigy-truncate-buffer (service _)
       "Truncate SERVICE process view buffer to its maximum size."
       (prodigy-with-service-process-buffer service
         (when (>  (line-number-at-pos (point-max)) my-prodigy-truncate-threshold)
           (save-excursion
             (goto-char (point-min))
             (forward-line my-prodigy-truncate-amount)
             (delete-region (point-min) (point))))))

     (defun prodigy-strip-host (output)
       "Strip host from output"
       (s-replace (system-name) "" output))

     ;; (defun prodigy-remove-debug (output)
     ;;   (if (not (s-match "DEBUG" output))
     ;;       output)))

     (add-to-list 'prodigy-output-filters 'prodigy-strip-host)

     (prodigy-define-tag
       :name 'boot
       :ready-message  "==== Complete\\. Time taken: [0-9\\.]+s ====")

     (prodigy-define-tag
       :name 'boot-start
       :ready-message "Elapsed time: .* sec")

     (prodigy-define-service
       :name "Beethoven"
       :command "fire-up"
       :cwd "~/src/beethoven"
       :tags '(elit)
       :stop-signal 'sigterm
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Beethoven MySql"
       :command "docker"
       :args '("run" "-e" "MYSQL_ROOT_PASSWORD=secret-password" "-p" "3306:3306" "beethoven_mysql")
       :cwd "~/src/beethoven"
       :tags '(elit mysql)
       :stop-signal 'sigterm
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Beethoven PostgresQL"
       :command "docker"
       :args '("run" "-p" "5432:5432" "beethoven_postgres")
       :cwd "~/src/beethoven"
       :tags '(elit postgres)
       :stop-signal 'sigterm
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Turnstile create fake EST container"
       :command "docker"
       :args '("run" "-it" "-v" "--name" "fake-est" "/tmp/est/speech/results:/tmp/est/speech/results" "-v" "/tmp/est/speech/input:/tmp/est/speech/input" "-v" "/tmp/est/submission/results:/tmp/est/submission/results" "-v" "/tmp/est/submission/input:/tmp/est/submission/input" "fake-est")
       :cwd "~/src/turnstile"
       :tags '(elit turnstile)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Turnstile start fake EST container"
       :command "docker"
       :args '("start" "-i" "fake-est")
       :cwd "~/src/turnstile"
       :tags '(elit turnstile)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Turnstile"
       :command "boot"
       :args '("cider" "dev")
       :cwd "~/src/turnstile"
       :tags '(elit turnstile)

       :stop-signal 'sigkill
       :kill-process-buffer-on-stop nil)

     (prodigy-define-service
       :name "Fake EST analyser"
       :command "fswatch"
       :args '("/tmp/est-input-dir/" "|" "xargs" "-n1" "/tmp/change.sh")
       :cwd "~/src/turnstile"
       :tags '(elit turnstile)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Accounts"
       :command "boot"
       :args '("cider" "dev")
       :cwd "~/src/accounts"
       :tags '(elit accounts boot)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Write and Improve"
       :command "boot"
       :args '("cider" "dev")
       :cwd "~/src/write-and-improve"
       :tags '(elit wandi boot)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Saucelabs proxy"
       :command "sc"
       :args '("-u" "donavan@englishlanguageitutoring.com" "-k"
               (shell-command-to-string "pass elit/saucelabs/secret-key"))
       :cwd "~/bin"
       :tags '(elit sandi saucelabs)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Postgres"
       :command "postgres"
       :args '("-D" "/usr/local/var/postgres")
       :cwd "~/"
       :tags '(elit sandi postgres)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Redis"
       :command "redis-server"
       :args '("/usr/local/etc/redis.conf")
       :cwd "~/"
       :tags '(elit sandi redis)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "lionel - backend"
       :command "boot"
       :args '("cider" "dev")
       :cwd "~/src/lionel"
       :tags '(elit sandi lionel boot boot-start)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "paxman - backend"
       :command "boot"
       :args '("cider" "dev")
       :cwd "~/src/paxman"
       :tags '(elit sandi paxman boot)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "sandi - devcards"
       :command "npm"
       :args '("run" "devcards")
       :cwd "~/src/sandi"
       :tags '(elit sandi)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "sandi - frontend"
       :command "npm"
       :args '("start")
       :cwd "~/src/sandi"
       :tags '(elit sandi)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "sandi - backend"
       :command "boot"
       :args '("cider" "dev")
       :cwd "~/src/sandi"
       :tags '(elit sandi boot)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Choma - admin"
       :command "yarn"
       :args '("start")
       :cwd "~/src/choma/admin"
       :tags '(arc choma)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Choma - proxy"
       :command "node"
       :args '("proxy.js")
       :cwd "~/src/choma/dev-proxy"
       :tags '(arc choma)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "CellC Girl - admin"
       :command "yarn"
       :args '("start")
       :cwd "~/src/cellc-girl/admin"
       :tags '(arc cellc)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "CellC Girl - proxy"
       :command "node"
       :args '("proxy.js")
       :cwd "~/src/cellc-girl/dev-proxy"
       :tags '(arc cellc)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Arc Interactive admin interface"
       :command "yarn"
       :args '("start")
       :cwd "~/src/arcinteractive/admin"
       :tags '(arc arcinteractive)
       :stop-signal 'sigkill
       :env '(("REACT_APP_ENV" "development"))
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "SAA landing page - frontend"
       :command "yarn"
       :args '("watch")
       :cwd "~/src/saa-boarding-pass-landing-page/laravel"
       :tags '(arc saa)
       :stop-signal 'sigkill
       :env '(("APP_ENV" "local"))
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Arc Interactive frontend"
       :command "yarn"
       :args '("watch")
       :cwd "~/src/arcinteractive/laravel"
       :tags '(arc arcinteractive)
       :stop-signal 'sigkill
       :env '(("APP_ENV" "local"))
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Laradock"
       :command "docker-compose"
       :args '("up" "nginx" "mysql")
       :cwd "~/src/laradock"
       :tags '(arc)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Ultibro admin interface"
       :command "yarn"
       :args '("start")
       :cwd "~/src/ultibrorsvp/admin"
       :tags '(arc ultibrorsvp)
       :stop-signal 'sigkill
       :env '(("APP_ENV" "local"))
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Ultibro mailer"
       :command "mjml"
       :args '("--watch" "index.mlml")
       :cwd "~/src/ultibrorsvp/mailers/save-the-date"
       :tags '(arc ultibrorsvp)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Think Video frontend"
       :command "npm"
       :args '("run" "watch")
       :cwd "~/src/thinkvideo/laravel"
       :tags '(arc ultibrorsvp)
       :stop-signal 'sigkill
       :env '(("APP_ENV" "local"))
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Ultibro frontend"
       :command "npm"
       :args '("run" "watch")
       :cwd "~/src/ultibrorsvp/laravel"
       :tags '(arc ultibrorsvp)
       :stop-signal 'sigkill
       :env '(("APP_ENV" "local"))
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Masterclass frontend"
       :command "npm"
       :args '("run" "watch")
       :cwd "~/src/masterclassrsvp/laravel"
       :tags '(arc masterclassrsvp)
       :stop-signal 'sigkill
       :env '(("APP_ENV" "local"))
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Masterclass mailers"
       :command "npm"
       :args '("run" "start")
       :cwd "~/src/masterclassrsvp/mailers/rsvp"
       :tags '(arc masterclassrsvp)
       :stop-signal 'sigkill
       :env '(("APP_ENV" "local"))
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Masterclass admin interface"
       :command "yarn"
       :args '("start")
       :cwd "~/src/masterclassrsvp/admin"
       :tags '(arc masterclassrsvp)
       :stop-signal 'sigkill
       :env '(("APP_ENV" "local"))
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Entresto admin interface"
       :command "yarn"
       :args '("start")
       :cwd "~/src/entrestolaunch/admin"
       :tags '(arc entresto)
       :stop-signal 'sigkill
       :env '(("APP_ENV" "local"))
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Entresto frontend"
       :command "yarn"
       :args '("run" "watch")
       :cwd "~/src/entrestolaunch/laravel"
       :tags '(arc entresto)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-define-service
       :name "Game of life - cards"
       :command "make"
       :args '("cards")
       :cwd "~/src/game-of-life"
       :tags '(fun clojure)
       :stop-signal 'sigkill
       :kill-process-buffer-on-stop t)

     (prodigy-add-filter :tag 'elit)
   #+end_src

** Eshell
*** Aliases

    #+begin_src emacs-lisp
      (defalias 'open 'find-file)
      (defalias 'openo 'find-file-other-window)
      (defalias 'dc-restart "cd ~/src/laradock && dc down && dc up -d nginx mysql")
      (defalias 'j9 "export JAVA_HOME=`/usr/libexec/java_home -v 9`; java -version")
      (defalias 'j8 "export JAVA_HOME=`/usr/libexec/java_home -v 1.8`; java -version")
      (defalias 'j7 "export JAVA_HOME=`/usr/libexec/java_home -v 1.7`; java -version")
      (defalias 'get-docker-cmd "docker inspect --format='{{.Config.Cmd}}' $*")
      (defalias 'migratus "boot migratus -a $*")
    #+end_src

*** Functions
    #+begin_src emacs-lisp
      (defun eshell/q () (eshell/exit))
      (defun eshell/emacs (&rest args)
        "Open a file in emacs. Some habits die hard."
        (if (null args)
            ;; If I just ran "emacs", I probably expect to be launching
            ;; Emacs, which is rather silly since I'm already in Emacs.
            ;; So just pretend to do what I ask.
            (bury-buffer)
          ;; We have to expand the file names or else naming a directory in an
          ;; argument causes later arguments to be looked for in that directory,
          ;; not the starting directory
          (mapc #'find-file (mapcar #'expand-file-name (eshell-flatten-list (reverse args))))))
    #+end_src

*** Unique shell per perspective

    #+begin_src emacs-lisp
      (defun set-persp-specific-shell (arg)
        "Make each perspective use its own shell/term"
        (progn
          (loop for persp in (persp-names-current-frame-fast-ordered) and i from 1
                when (string= persp arg)
                do (progn (setq shell-pop-last-shell-buffer-index i) (return)))))

      (defun switch-to-X-advice (arg)
        (setq shell-pop-last-shell-buffer-index (+ 1 arg)))

      (advice-add 'persp-switch :after #'set-persp-specific-shell)
      (advice-add 'spacemacs/layout-switch-by-pos :after #'switch-to-X-advice)
    #+end_src

** Perspective

   #+begin_src emacs-lisp
     (global-set-key (kbd "C-S-h") 'spacemacs/layouts-transient-state/persp-prev)
     (global-set-key (kbd "C-S-l") 'spacemacs/layouts-transient-state/persp-next)
   #+end_src

** Aggressive indent

   #+begin_src emacs-lisp
     (aggressive-indent-global-mode)
   #+end_src

** highlighting

*** highlight.el
    #+begin_src emacs-lisp
;;; highlight-global.el --- package for highlighting multi symbols accross ALL buffers

;; Copyright 2013-2014 Glen Dai
;; Author: Glen Dai <gafglen@gmail.com>
;; Keywords: highlight
;; URL: https://github.com/glen-dai/highlight-global
;; Version: 0.01

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; When reading source code with EMACS, couples of related files will
;; be opened simultaneously. A function/variable defined in one file
;; will be referenced by another function in another file. A
;; highlight of the corresponding function/vairalbe accross these
;; buffers will make code reading much more friendly.

;; EMACS support multi highlight symbols in one buffer but not
;; accross multi buffers. This package provide highlighting of
;; symbols accross all buffer.

;; When new highlight is being added, only the windows of current
;; frame are updated. Whenever frame configration change(say new
;; window is added to current frame), window's highlight will be
;; updated to make windows currently showing always has the updated
;; highlights. This way is much more effecient than iterating the
;; overall buffer-list to update highlights for every buffer.
;;
;; Multi symbols can be highlighted simultaneously. Different
;; highlights have different face. You could add your highlight face
;; to highlight-faces.

;;; How to use?

;; Put the package into load-path, and load the packaget
;;     (require 'highlight-global)

;; Toggle highlight of current region (or symbol under cursor if
;; region is not active) and bind it like this:
;;     (global-set-key (kbd "M-H") 'highlight-frame-toggle)

;; Clear all highlight of current frame, and bind it like this:
;;     (global-set-key (kbd "M-C") 'clear-highlight-frame)


(require 'hi-lock)
(setq hi-lock-file-patterns-policy 'never)

(defvar highlight-faces
  '(('hi-yellow . 0)
    ('hi-pink . 0)
    ('hi-green . 0)
    ('hi-blue . 0))
  "Default faces for hi-lock interactive functions, you could add your own.")

(defun clear-all-faces ()
  "Reset all face's usage count to zero."
  (dolist (item highlight-faces)
    (setcdr item 0)))

(defun find-and-use-face ()
  "Find the least used face and increase it, the face will be returned to caller"
  (let ((least-used-one (nth 0 highlight-faces)))
    (progn
      (dolist (face highlight-faces)
        (when (< (cdr face) (cdr least-used-one))
          (setq least-used-one face)))
      (setcdr least-used-one (+ 1 (cdr least-used-one)))
      (car least-used-one))))

(defun release-face (face-to-release)
  "Release the use of a face by decreasing the counting"
  (dolist (face highlight-faces)
    (when (equal (car face) face-to-release)
      (setcdr face (- (cdr face) 1)))))

;; list to store what had been highlighted
(defvar global-highlight-list nil
  "Global highlight list, always store the updated highlight
  regexp list, and every item is stored like this ((hilight-str1
  . hilight-face1) (hilight-str2 . hilight-face2) ...)")

(defvar global-highlight-list-update-timestamp 0.0
  "Store the timestamp when `global-highlight-list' was updated")

(defvar new-unhighlight nil "Store's thing to be unhighlight")
(defvar new-highlight nil "Store's thing to be highlight")

(defvar buffer-highlight-list nil
  "Stores the regexp highlighed by `highlight-windows' package of
  current buffer")
(make-variable-buffer-local 'buffer-highlight-list)
(put 'buffer-highlight-list 'permanent-local t)

;; set it to -0.5 to make sure first time it will update
(defvar buffer-highlight-list-update-timestamp -0.5
  "Stores the recently timestamp when `buffer-highlight-list' was
  updated")
(make-variable-buffer-local 'buffer-highlight-list-update-timestamp)
(put 'buffer-highlight-list-update-timestamp 'permanent-local t)

(defun clear-highlight-window (win)
  "Clear all highlight of current buffer, called by
  `unhighlit-windows-all' when iterating all windows. When a
  buffer is being burry, this funciton also will be called to
  clear all highlight"
  (select-window win)
  (setq buffer-highlight-list-update-timestamp (float-time))
  (dolist (item global-highlight-list)
    (font-lock-remove-keywords
     nil
     `((,(car item) 0 ,(cdr item) prepend)))
    (font-lock-fontify-buffer)))

(defun clear-highlight-frame ()
  "Clear all highlights of all windows "
  (interactive)
  (walk-windows 'clear-highlight-window)
  (setq global-highlight-list nil)
  (clear-all-faces)
  (setq global-highlight-list-update-timestamp (float-time)))

(defun unhighlight-window (win)
  "Highligt a buffer, should update of buffer-local
highlight-list and timestamp, used by `walk-windows'"
  (select-window win)
  (setq buffer-highlight-list-update-timestamp (float-time))
  (setq buffer-highlight-list
        (delete new-unhighlight buffer-highlight-list))
  ;; add new highlight to current buffer's keyword list
  (font-lock-remove-keywords
   nil
   `((,(car new-unhighlight) 0 ,(cdr new-unhighlight) prepend)))
  (font-lock-fontify-buffer))

(defun highlight-window (win)
  "Highligt a buffer, should update buffer-local highlight-list
and timestamp"
  (select-window win)
  (setq buffer-highlight-list-update-timestamp (float-time))
  (push new-highlight buffer-highlight-list)
  (font-lock-add-keywords
   nil
   `((,(car new-highlight) 0 ,(cdr new-highlight) prepend)) 'append)
  (font-lock-fontify-buffer))

(defun get-thing-to-highlight ()
  "Get thing to highlight. If active region, get reigon, else get
symbol under cursor"
  (if (use-region-p)
      (buffer-substring-no-properties (region-beginning) (region-end))
    (if (thing-at-point 'symbol)
        (buffer-substring-no-properties
         (car (bounds-of-thing-at-point 'symbol))
         (cdr (bounds-of-thing-at-point 'symbol))))))

(defun check-whether-highlighted (hi)
  "Check if HI is already highlighted by checking
global-highlight-list"
  (let ((the-found-one nil))
    (progn
      (dolist (item global-highlight-list)
        (when (equal hi (car item))
          (progn
            (setq the-found-one item))))
      the-found-one)))

(defun highlight-frame-toggle ()
  (interactive)
  (let* ((thing-to-highlight (get-thing-to-highlight))
         (hi nil)
         (face nil))
    (if (stringp thing-to-highlight)
        (progn
          (setq hi (check-whether-highlighted thing-to-highlight))
          ;; toogle highlight, 2 cases
          ;; 1) thing already unlighlight and stored in list, unhighight it
          ;; 2) new highlight, highlight it and add it to list
          (if hi
              ;; 1) toogle off
              ;;    1. delete item from global-list && update timestamp
              ;;    2. set new-unhighlight and unhighight each window
              (progn
                (setq new-unhighlight hi)
                (release-face (cdr new-unhighlight))
                (setq global-highlight-list
                      (delete new-unhighlight global-highlight-list))
                (setq global-highlight-list-update-timestamp (float-time))
                (walk-windows 'unhighlight-window))
            ;; 2) new highlight
            (progn
              (setq new-highlight (cons thing-to-highlight (find-and-use-face)))
              (setq global-highlight-list (cons new-highlight global-highlight-list))
              (setq global-highlight-list-update-timestamp (float-time))
              (walk-windows 'highlight-window))))
      (message "No vaidate region, or no validate symbol under cursor!"))))

(defun highlight-update-current-buffer ()
  "Update a buffer's highlight to be consistent with global
highlight"
  (if (<= buffer-highlight-list-update-timestamp
          global-highlight-list-update-timestamp)
      (if (null global-highlight-list)      ; clear buffer
          ;; 1) global null
          (progn
            (dolist (item buffer-highlight-list)
              (font-lock-remove-keywords
               nil
               `((,(car item) 0 ,(cdr item) prepend)))
              (font-lock-fontify-buffer))
            (setq buffer-highlight-list-update-timestamp (float-time))
            (setq buffer-highlight-list nil))
        ;; 2) globla is not null, now update local to global
        (progn
          ;; (message "Updating buffer : %s" (current-buffer))
          ;; 2.1) iterate buffer-list to delete
          (dolist (item buffer-highlight-list)
            (if (not (member item global-highlight-list))
                (progn
                  ;; `((,(car new-highlight) 0 ,(cdr new-highlight) prepend))
                  ;; (list (car item))
                  (font-lock-remove-keywords
                   nil
                   `((,(car item) 0 ,(cdr item) prepend)))
                  (font-lock-fontify-buffer)
                  (setq buffer-highlight-list
                        (delete item buffer-highlight-list)))))
          ;; 2.2) iterate global-list to add
          (dolist (item global-highlight-list)
            (if (not (member item buffer-highlight-list))
                (progn
                  (font-lock-add-keywords
                   nil
                   `((,(car item) 0 ,(cdr item) prepend)) 'append)
                  (font-lock-fontify-buffer)
                  (push item buffer-highlight-list))))
          (setq buffer-highlight-list-update-timestamp (float-time)))
        ;; (message "no need to update : %s" (current-buffer))
        )))

;; Force to update highlights on current frame, call this function
;; will update highlights in every window within current frame
(defun force-highlight-frame ()
  (interactive)
  (save-excursion
    (walk-windows #'(lambda (win)
                      (select-window win)
                      (highlight-update-current-buffer)))))

;; Automatically update new buffer's highlights when any windows on
;; current frame changed. This will make buffers that to be showned
;; because of window splitting alway has highlights updated to date.
(defun update-highlight-fixup (frame)
  (force-highlight-frame))

;; register the on-the-fly highlight-list updating strategy to
;; window-size-change-functions hook
(if (null window-size-change-functions)
    (setq window-size-change-functions '(update-highlight-fixup))
  (add-to-list 'window-size-change-functions 'update-highlight-fixup))

(provide 'highlight-global)

;;; highlight-global.el ends here
    #+end_src

*** keybindings

    #+BEGIN_SRC emacs-lisp
(require 'highlight)
(spacemacs/set-leader-keys
  "ths" 'highlight-frame-toggle
  "thc" 'clear-highlight-frame)
    #+END_SRC

** mu4e

   #+BEGIN_SRC emacs-lisp
     (require 'smtpmail)
     (setq mu4e-maildir "~/mail"
           mu4e-get-mail-command "mbsync --all"
           mu4e-completing-read-function 'completing-read
           message-kill-buffer-on-exit t
           mu4e-confirm-quit nil
           smtpmail-smtp-service 587
           message-send-mail-function 'smtpmail-send-it
           starttls-use-gnutls t
           mu4e-sent-messages-behavior 'delete
           mu4e-headers-skip-duplicates t
           mu4e-use-fancy-chars nil
           mu4e-view-show-images t
           mu4e-view-prefer-html nil
           mu4e-html2text-command 'mu4e-shr2text
           shr-color-visible-distance-min 5
           shr-color-visible-luminance-min 60
           shr-use-colors nil)

     (require 'mu4e-contrib)
     (advice-add #'shr-colorize-region :around (defun shr-no-colourise-region (&rest ignore)))

     (add-hook 'mu4e-view-mode-hook
               (lambda()
                 (local-set-key (kbd "<tab>") 'shr-next-link)
                 (local-set-key (kbd "<backtab>") 'shr-previous-link)))

     (define-key mu4e-headers-mode-map (kbd "C-c c") 'org-mu4e-store-and-capture)
       (define-key mu4e-view-mode-map    (kbd "C-c c") 'org-mu4e-store-and-capture)

     (add-to-list 'mu4e-bookmarks
                  (make-mu4e-bookmark
                   :name  "Unread filtered"
                   :query "flag:unread and not maildir:/INBOX.gitlab and not maildir:/INBOX.github and not maildir:/INBOX.mailinglist.something-user and not maildir:/INBOX.mailinglist.other-user"
                   :key ?n)
                  )
     ;; (when (fboundp 'imagemagick-register-types)
     ;;   (imagemagick-register-types))

     ;; (smtpmail-starttls-credentials (("smtp.gmail.com" 587 nil nil)))
     ;; (smtpmail-auth-credentials (("smtp.gmail.com" 587 "d.costaras@gmail.com" nil)))
     ;; (smtpmail-default-smtp-server "smtp.gmail.com")

     (after 'mu4e
       (setq
        mu4e-contexts
        `(,(make-mu4e-context
            :name "personal"
            :enter-func
            (lambda () (mu4e-message "Switch to the personal context"))
            :match-func
            (lambda (msg)
              (when msg
                (mu4e-message-contact-field-matches msg :to "d.costaras@gmail.com")))
            :vars '(
                    (mu4e-sent-folder .  "/personal/sent")
                    (mu4e-drafts-folder . "/personal/drafts")
                    (mu4e-trash-folder . "/personal/trash")
                    (mu4e-refile-folder . "/personal/archive")
                    (smtpmail-smtp-server . "smtp.gmail.com")
                    (mu4e-maildir-shortcuts
                     . (("/personal/archive" . ?a)
                        ("/personal/inbox"   . ?i)
                        ("/personal/work"    . ?w)
                        ("/personal/sent"    . ?s)))
                    (user-mail-address . "d.costaras@gmail.com"  )
                    (user-full-name . "Donavan-Ross Costaras" )
                    (mu4e-compose-signature .
                                            (concat
                                             "Donavan-Ross Costaras"))
                    ))
          ,(make-mu4e-context
            :name "work"
            :enter-func
            (lambda () (mu4e-message "Switch to the work context"))
            :match-func
            (lambda (msg)
              (when msg
                (mu4e-message-contact-field-matches msg :to "d.costaras@gmail.com")))
            :vars '(
                    (mu4e-sent-folder .  "/work/sent")
                    (mu4e-drafts-folder . "/work/drafts")
                    (mu4e-trash-folder . "/work/trash")
                    (mu4e-refile-folder . "/work/archive")
                    (smtpmail-smtp-server . "smtp.gmail.com")
                    (mu4e-maildir-shortcuts
                     . (("/work/archive" . ?a)
                        ("/work/inbox"   . ?i)
                        ("/work/work"    . ?w)
                        ("/work/sent"    . ?s)))
                    (user-mail-address . "d.costaras@gmail.com"  )
                    (user-full-name . "Donavan-Ross Costaras" )
                    (mu4e-compose-signature .
                                            (concat
                                             "Donavan-Ross Costaras"))
                    ))
          )))
   #+END_SRC

** Hide region
   ;;; hide-region.el --- hide regions of text using overlays
   ;;
   ;; Copyright (C) 2001, 2005  Mathias Dahl
   ;;
   ;; Version: 1.0.2
   ;; Keywords: hide, region
   ;; Author: Mathias Dahl <mathias.rem0veth1s.dahl@gmail.com>
   ;; Maintainer: Mathias Dahl
   ;; URL: http://mathias.dahl.net/pgm/emacs/elisp/hide-region.el
   ;; Last-Updated: Thu Sun Jul 28 16:10:15 2011 (+0200)
   ;;           By: Deniz Dogan <deniz@dogan.se>
   ;;
   ;; This file is not part of GNU Emacs.
   ;;
   ;; This is free software; you can redistribute it and/or modify it
   ;; under the terms of the GNU General Public License as published by
   ;; the Free Software Foundation; either version 2, or (at your option)
   ;; any later version.
   ;;
   ;; This is distributed in the hope that it will be useful, but WITHOUT
   ;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   ;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   ;; License for more details.
   ;;
   ;; You should have received a copy of the GNU General Public License
   ;; along with GNU Emacs; see the file COPYING.  If not, write to the
   ;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   ;; Boston, MA 02111-1307, USA.
   ;;
   ;;; Commentary:
   ;;
   ;; The function `hide-region-hide' hides the region. You can hide many
   ;; different regions and they will be "marked" by two configurable
   ;; strings (so that you know where the hidden text is).
   ;;
   ;; The hidden regions is pushed on a kind of hide-region \"ring".
   ;;
   ;; The function `hide-region-unhide' "unhides" one region, starting
   ;; with the last one you hid.
   ;;
   ;; The best is to try it out. Test on the following:
   ;;
   ;; Test region 1
   ;; Test region 2
   ;; Test region 3
   ;;
   ;; It can be useful to bind the commands to mnemonic keys, e.g.:
   ;; (global-set-key (kbd "C-c h r") 'hide-region-hide)
   ;; (global-set-key (kbd "C-c h u") 'hide-region-unhide)
   ;;
   ;;; Version history
   ;;
   ;; Version 1.0.2
   ;;
   ;; * Added defface for text properties.
   ;;
   ;; * Minor tweaks.
   ;;
   ;;
   ;; Version 1.0.1
   ;;
   ;; * Seems that the getting-stuck problem have disappeared since Emacs
   ;; 21.3 was released, so no need anymore for the extra movement
   ;; commands.
   ;;
   ;; * Added the intangible property to the overlays because that seemed
   ;; to remove a minor getting-stuck problem (the overlay "ate" one
   ;; keystroke) when navigating around an overlay. Adding the intangible
   ;; property makes it impossible to navigate into the overlay.
   ;;
   ;; * Added custom option to propertize the overlay markers for greater
   ;; visibility.
   ;;
   ;; * Minor code cleanup
   ;;
   ;;
   ;;; Bugs
   ;;
   ;; Probably many, but none that I know of. Comments and suggestions
   ;; are welcome!

   ;;; Code:

   (defgroup hide-region nil
   "Functions to hide region using an overlay with the invisible
   property. The text is not affected."
   :prefix "hide-region-"
   :group 'convenience)

   (defcustom hide-region-before-string "@["
   "String to mark the beginning of an invisible region. This string is
   not really placed in the text, it is just shown in the overlay"
   :type 'string
   :group 'hide-region)

   (defcustom hide-region-after-string "]@"
   "String to mark the beginning of an invisible region. This string is
   not really placed in the text, it is just shown in the overlay"
   :type 'string
   :group 'hide-region)

   (defcustom hide-region-propertize-markers t
   "If non-nil, add text properties to the region markers."
   :type 'boolean
   :group 'hide-region)

   (defface hide-region-before-string-face
   '((t (:inherit region)))
   "Face for the before string.")

   (defface hide-region-after-string-face
   '((t (:inherit region)))
   "Face for the after string.")

   (defvar hide-region-overlays nil
   "Variable to store the regions we put an overlay on.")

   ;;;###autoload
   (defun hide-region-hide ()
   "Hides a region by making an invisible overlay over it and save the
   overlay on the hide-region-overlays \"ring\""
   (interactive)
   (let ((new-overlay (make-overlay (mark) (point))))
   (push new-overlay hide-region-overlays)
   (overlay-put new-overlay 'invisible t)
   (overlay-put new-overlay 'intangible t)
   (overlay-put new-overlay 'before-string
   (if hide-region-propertize-markers
   (propertize hide-region-before-string
   'font-lock-face 'hide-region-before-string-face)
   hide-region-before-string))
   (overlay-put new-overlay 'after-string
   (if hide-region-propertize-markers
   (propertize hide-region-after-string
   'font-lock-face 'hide-region-after-string-face)
   hide-region-after-string))))

   ;;;###autoload
   (defun hide-region-unhide ()
   "Unhide a region at a time, starting with the last one hidden and
   deleting the overlay from the hide-region-overlays \"ring\"."
   (interactive)
   (when (car hide-region-overlays)
   (delete-overlay (car hide-region-overlays))
   (setq hide-region-overlays (cdr hide-region-overlays))))

   (provide 'hide-region)

   ;;; hide-region.el ends here
** Evil
*** searching


    #+BEGIN_SRC emacs-lisp
      (evil-select-search-module 'evil-search-module 'isearch)
      (quelpa '(isearch+ :url "https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/isearch+.el" :fetcher url))
      (require 'isearch+)
    #+END_SRC

*** evil-escape

    #+begin_src emacs-lisp
      (setq evil-escape-delay 0.2
            evil-escape-unordered-key-sequence t)

      (after 'cider

        (define-key cider-test-report-mode-map (kbd "$") 'evil-end-of-line)
        (define-key cider-test-report-mode-map (kbd "0") 'evil-beginning-of-line)

        ;; (add-hook 'cider-test-report-mode-hook (lambda () (spacemacs/toggle-truncate-lines-on)))
        )
    #+end_src

** Eyebrowse

   #+begin_src emacs-lisp
     (after 'evil
       (define-key evil-normal-state-map (kbd "gt") 'eyebrowse-last-window-config))
   #+end_src

** Modifiers

   #+begin_src emacs-lisp
     (setq mac-command-modifier 'meta) ; make cmd key do Meta
     (setq mac-option-modifier 'super) ; make opt key do Super
   #+end_src

** keys
*** Windows

    #+begin_src emacs-lisp
      (after 'web-mode
        (define-key web-mode-map (kbd "C-M-j") (lambda () (interactive) (ignore-errors (windmove-down))))
        (define-key web-mode-map (kbd "C-M-h") (lambda () (interactive) (ignore-errors (windmove-left)))))
      (after 'php-mode
        (define-key php-mode-map (kbd "C-M-h") (lambda () (interactive) (ignore-errors (windmove-left))))
        (define-key php-mode-map (kbd "C-M-j") (lambda () (interactive) (ignore-errors (windmove-down)))))
      (global-set-key (kbd "C-M-h") (lambda () (interactive) (ignore-errors (windmove-left))))
      (global-set-key (kbd "C-M-j") (lambda () (interactive) (ignore-errors (windmove-down))))
      (global-set-key (kbd "C-M-k") (lambda () (interactive) (ignore-errors (windmove-up))))
      (global-set-key (kbd "C-M-l") (lambda () (interactive) (ignore-errors (windmove-right))))
    #+end_src

*** Yank, kill

    #+begin_src emacs-lisp
    #+end_src

*** Dired

    #+begin_src emacs-lisp
      (evilified-state-evilify dired-mode dired-mode-map
        "K" 'dired-kill-subdir)
    #+end_src

*** Helm AG

    #+begin_src emacs-lisp
      (evilified-state-evilify helm-ag-mode helm-ag-mode-map
        "o" (lambda ()
              (interactive)
              (save-selected-window
                (helm-ag-mode-jump-other-window))))
    #+end_src

** Mousetrap

   #+begin_src emacs-lisp
     (defun silence ()
       (interactive))

     (define-key evil-motion-state-map [down-mouse-1] 'silence)
     (define-key evil-motion-state-map [mouse-1] 'silence)
     (define-key evil-visual-state-map [down-mouse-1] 'silence)
     (define-key evil-visual-state-map [mouse-1] 'silence)
     (define-key evil-insert-state-map [down-mouse-1] 'silence)
     (define-key evil-insert-state-map [mouse-1] 'silence)
     (define-key evil-normal-state-map [down-mouse-1] 'silence)
     (define-key evil-normal-state-map [mouse-1] 'silence)
   #+end_src

** smart-parens
   #+begin_src emacs-lisp
     (setq sp-escape-quotes-after-insert nil)
   #+end_src

** Modeline
** Fancy battery
   #+begin_src emacs-lisp
     (fancy-battery-mode 1)
     (setq powerline-default-separator 'utf-8)
   #+end_src

   #+begin_src emacs-lisp
   #+end_src

** Org mode

   Base on http://doc.norang.ca/org-mode.html

   #+begin_src emacs-lisp
     (spacemacs/set-leader-keys-for-major-mode 'org-mode "os" ",',sb,c")
     (setq org-src-preserve-indentation t)
     (setq org-src-window-setup 'current-window)
     (add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))
     (after 'org
       (define-key org-mode-map (kbd "C-<return>") 'org-meta-return)
       (define-key org-mode-map (kbd "C-M-<return>") 'org-insert-heading-respect-content)
       (add-to-list 'org-modules 'org-habit))
   #+end_src

*** babel

    #+begin_src emacs-lisp

(require 'ob-sql-mode)
(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   ;; (maxima . t)
   ;; (mathematica . t)
   ;; (latex . t)
   ;; (python . t)
   ;; (sass .t)
   (sql . t)
   (js . t)
   (shell . t)
   (http . t)
   (makefile .t)
   ;; (scala . t)
   ;; (dot . t)
   (clojure . t)
   ;; (gnuplot . t)
   ;; (http . t)
   ;; (csharp . t)
   ;; (ditaa . t)
   ;; (dot . t)
   ;; (plantuml . t)
   ;; (scheme . t)
   ))
    #+end_src

*** Agenda

    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-files (quote ("~/org")))
    #+END_SRC

*** Keybindings

    #+BEGIN_SRC emacs-lisp
      (defun bh/hide-other ()
        (interactive)
        (save-excursion
          (org-back-to-heading 'invisible-ok)
          (hide-other)
          (org-cycle)
          (org-cycle)
          (org-cycle)))

      (defun bh/set-truncate-lines ()
        "Toggle value of truncate-lines and refresh window display."
        (interactive)
        (setq truncate-lines (not truncate-lines))
        ;; now refresh window display (an idiom from simple.el):
        (save-excursion
          (set-window-start (selected-window)
                            (window-start (selected-window)))))

      (defun bh/make-org-scratch ()
        (interactive)
        (find-file "/tmp/publish/scratch.org")
        (gnus-make-directory "/tmp/publish"))

      (defun bh/switch-to-scratch ()
        (interactive)
        (switch-to-buffer "*scratch*"))
    #+END_SRC

*** Tasks and states

    #+BEGIN_SRC emacs-lisp
      (setq org-todo-keywords
            (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                    (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

      (setq org-todo-keyword-faces
            (quote (("TODO" :foreground "red" :weight bold)
                    ("NEXT" :foreground "blue" :weight bold)
                    ("DONE" :foreground "forest green" :weight bold)
                    ("WAITING" :foreground "orange" :weight bold)
                    ("HOLD" :foreground "magenta" :weight bold)
                    ("CANCELLED" :foreground "forest green" :weight bold)
                    ("MEETING" :foreground "forest green" :weight bold)
                    ("PHONE" :foreground "forest green" :weight bold))))

      (setq org-use-fast-todo-selection t)
      (setq org-treat-S-cursor-todo-selection-as-state-change nil)

      (setq org-todo-state-tags-triggers
            (quote (("CANCELLED" ("CANCELLED" . t))
                    ("WAITING" ("WAITING" . t))
                    ("HOLD" ("WAITING") ("HOLD" . t))
                    (done ("WAITING") ("HOLD"))
                    ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                    ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                    ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
    #+END_SRC

*** Org capture

    #+BEGIN_SRC emacs-lisp
      (setq org-directory "~/org")
      (setq org-default-notes-file "~/org/refile.org")

      ;; I use C-c c to start capture mode
      (global-set-key (kbd "C-c c") 'org-capture)

      ;; Capture templates for: TODO tasks, Notes, appointments, phone calls, meetings, and org-protocol
      (setq org-capture-templates
            '(("t" "todo" entry (file "~/org/refile.org")
               "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
              ("r" "respond" entry (file "~/org/refile.org")
               "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
              ("n" "note" entry (file "~/org/refile.org")
               "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
              ("j" "Journal" entry (file+datetree "~/org/diary.org")
               "* %?\n%U\n" :clock-in t :clock-resume t)
              ("s" "Standup" entry (file+olp+datetree "~/org/elit.org" "Standups")
               "* Plan\nY:\n\n- %?\n\nT: \n\n- "
               :clock-in t :clock-resume t)
              ("w" "org-protocol" entry (file "~/org/refile.org")
               "* TODO Review %c\n%U\n" :immediate-finish t)
              ("m" "Meeting" entry (file "~/org/refile.org")
               "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
              ("p" "Phone call" entry (file "~/org/refile.org")
               "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
              ("h" "Habit" entry (file "~/org/refile.org")
               "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n")))
    #+END_SRC

**** Remove empty log entries

     #+BEGIN_SRC emacs-lisp
       ;; Remove empty LOGBOOK drawers on clock out
       (defun bh/remove-empty-drawer-on-clock-out ()
         (interactive)
         (save-excursion
           (beginning-of-line 0)
           (org-remove-empty-drawer-at "LOGBOOK" (point))))

       ;; (add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)
     #+END_SRC

*** Refile

    #+BEGIN_SRC emacs-lisp
                                              ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
      (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                       (org-agenda-files :maxlevel . 9))))

                                              ; Use full outline paths for refile targets - we file directly with IDO
      (setq org-refile-use-outline-path t)

                                              ; Targets complete directly with IDO
      (setq org-outline-path-complete-in-steps nil)

                                              ; Allow refile to create parent tasks with confirmation
      (setq org-refile-allow-creating-parent-nodes (quote confirm))

                                              ; Use IDO for both buffer and file completion and ido-everywhere to t
      (setq org-completion-use-ido t)
      (setq ido-everywhere t)
      (setq ido-max-directory-size 100000)
      (ido-mode (quote both))
                                              ; Use the current window when visiting files and buffers with ido
      (setq ido-default-file-method 'selected-window)
      (setq ido-default-buffer-method 'selected-window)
                                              ; Use the current window for indirect buffer display
      (setq org-indirect-buffer-display 'current-window)

      ;;;; Refile settings
                                              ; Exclude DONE state tasks from refile targets
      (defun bh/verify-refile-target ()
        "Exclude todo keywords with a done state from refile targets"
        (not (member (nth 2 (org-heading-components)) org-done-keywords)))

      (setq org-refile-target-verify-function 'bh/verify-refile-target)
    #+END_SRC

*** Agenda

    #+BEGIN_SRC emacs-lisp
      ;; Do not dim blocked tasks
      (setq org-agenda-dim-blocked-tasks nil)

      ;; Compact the block agenda view
      (setq org-agenda-compact-blocks t)

      ;; Custom agenda command definitions
      (setq org-agenda-custom-commands
            (quote (("N" "Notes" tags "NOTE"
                     ((org-agenda-overriding-header "Notes")
                      (org-tags-match-list-sublevels t)))

                    ("y" "Yesterday" )
                    ("h" "Habits" tags-todo "STYLE=\"habit\""
                     ((org-agenda-overriding-header "Habits")
                      (org-agenda-sorting-strategy
                       '(todo-state-down effort-up category-keep))))

                    (" " "Agenda"

                     ((agenda "" nil)

                      (tags "REFILE"
                            ((org-agenda-overriding-header "Tasks to Refile")
                             (org-tags-match-list-sublevels nil)))

                      (tags-todo "-CANCELLED/!"
                                 ((org-agenda-overriding-header "Stuck Projects")
                                  (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                                  (org-agenda-sorting-strategy
                                   '(category-keep))))
                      (tags-todo "-HOLD-CANCELLED/!"
                                 ((org-agenda-overriding-header "Projects")
                                  (org-agenda-skip-function 'bh/skip-non-projects)
                                  (org-tags-match-list-sublevels 'indented)
                                  (org-agenda-sorting-strategy
                                   '(category-keep))))
                      (tags-todo "-CANCELLED/!NEXT"
                                 ((org-agenda-overriding-header (concat "Project Next Tasks"
                                                                        (if bh/hide-scheduled-and-waiting-next-tasks
                                                                            ""
                                                                          " (including WAITING and SCHEDULED tasks)")))
                                  (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                                  (org-tags-match-list-sublevels t)
                                  (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                                  (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                                  (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                                  (org-agenda-sorting-strategy
                                   '(todo-state-down effort-up category-keep))))
                      (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                                 ((org-agenda-overriding-header (concat "Project Subtasks"
                                                                        (if bh/hide-scheduled-and-waiting-next-tasks
                                                                            ""
                                                                          " (including WAITING and SCHEDULED tasks)")))
                                  (org-agenda-skip-function 'bh/skip-non-project-tasks)
                                  (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                                  (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                                  (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                                  (org-agenda-sorting-strategy
                                   '(category-keep))))
                      (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                                 ((org-agenda-overriding-header (concat "Standalone Tasks"
                                                                        (if bh/hide-scheduled-and-waiting-next-tasks
                                                                            ""
                                                                          " (including WAITING and SCHEDULED tasks)")))
                                  (org-agenda-skip-function 'bh/skip-project-tasks)
                                  (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                                  (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                                  (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                                  (org-agenda-sorting-strategy
                                   '(category-keep))))
                      (tags-todo "-CANCELLED+WAITING|HOLD/!"
                                 ((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
                                                                        (if bh/hide-scheduled-and-waiting-next-tasks
                                                                            ""
                                                                          " (including WAITING and SCHEDULED tasks)")))
                                  (org-agenda-skip-function 'bh/skip-non-tasks)
                                  (org-tags-match-list-sublevels nil)
                                  (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                                  (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)))
                      (tags "-REFILE/"
                            ((org-agenda-overriding-header "Tasks to Archive")
                             (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                             (org-tags-match-list-sublevels nil))))

                     nil))))

      (defun bh/org-auto-exclude-function (tag)
        "Automatic task exclusion in the agenda with / RET"
        (and (cond
              ((string= tag "hold")
               t)
              ((string= tag "farm")
               t))
             (concat "-" tag)))

      (setq org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)
    #+END_SRC

*** Time clocking
    #+BEGIN_SRC emacs-lisp
      ;;
      ;; Resume clocking task when emacs is restarted
      (org-clock-persistence-insinuate)
      ;;
      ;; Show lot of clocking history so it's easy to pick items off the C-F11 list
      (setq org-clock-history-length 23)
      ;; Resume clocking task on clock-in if the clock is open
      (setq org-clock-in-resume t)
      ;; Change tasks to NEXT when clocking in
      (setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
      ;; Separate drawers for clocking and logs
      (setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
      ;; Save clock data and state changes and notes in the LOGBOOK drawer
      (setq org-clock-into-drawer t)
      ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
      (setq org-clock-out-remove-zero-time-clocks t)
      ;; Clock out when moving task to a done state
      (setq org-clock-out-when-done t)
      ;; Save the running clock and all clock history when exiting Emacs, load it on startup
      (setq org-clock-persist t)
      ;; Do not prompt to resume an active clock
      (setq org-clock-persist-query-resume nil)
      ;; Enable auto clock resolution for finding open clocks
      (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
      ;; Include current clocking task in clock reports
      (setq org-clock-report-include-clocking-task t)

      (setq bh/keep-clock-running nil)

      (defun bh/clock-in-to-next (kw)
        "Switch a task from TODO to NEXT when clocking in.
      Skips capture tasks, projects, and subprojects.
      Switch projects and subprojects from NEXT back to TODO"
        (when (not (and (boundp 'org-capture-mode) org-capture-mode))
          (cond
           ((and (member (org-get-todo-state) (list "TODO"))
                 (bh/is-task-p))
            "NEXT")
           ((and (member (org-get-todo-state) (list "NEXT"))
                 (bh/is-project-p))
            "TODO"))))

      (defun bh/find-project-task ()
        "Move point to the parent (project) task if any"
        (save-restriction
          (widen)
          (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
            (while (org-up-heading-safe)
              (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
                (setq parent-task (point))))
            (goto-char parent-task)
            parent-task)))

      (defun bh/punch-in (arg)
        "Start continuous clocking and set the default task to the
      selected task.  If no task is selected set the Organization task
      as the default task."
        (interactive "p")
        (setq bh/keep-clock-running t)
        (if (equal major-mode 'org-agenda-mode)
            ;;
            ;; We're in the agenda
            ;;
            (let* ((marker (org-get-at-bol 'org-hd-marker))
                   (tags (org-with-point-at marker (org-get-tags-at))))
              (if (and (eq arg 4) tags)
                  (org-agenda-clock-in '(16))
                (bh/clock-in-organization-task-as-default)))
          ;;
          ;; We are not in the agenda
          ;;
          (save-restriction
            (widen)
                                              ; Find the tags on the current task
            (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
                (org-clock-in '(16))
              (bh/clock-in-organization-task-as-default)))))

      (defun bh/punch-out ()
        (interactive)
        (setq bh/keep-clock-running nil)
        (when (org-clock-is-active)
          (org-clock-out))
        (org-agenda-remove-restriction-lock))

      (defun bh/clock-in-default-task ()
        (save-excursion
          (org-with-point-at org-clock-default-task
            (org-clock-in))))

      (defun bh/clock-in-parent-task ()
        "Move point to the parent (project) task if any and clock in"
        (let ((parent-task))
          (save-excursion
            (save-restriction
              (widen)
              (while (and (not parent-task) (org-up-heading-safe))
                (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
                  (setq parent-task (point))))
              (if parent-task
                  (org-with-point-at parent-task
                    (org-clock-in))
                (when bh/keep-clock-running
                  (bh/clock-in-default-task)))))))

      (defvar bh/organization-task-id "eb155a82-92b2-4f25-a3c6-0304591af2f9")

      (defun bh/clock-in-organization-task-as-default ()
        (interactive)
        (org-with-point-at (org-id-find bh/organization-task-id 'marker)
          (org-clock-in '(16))))

      (defun bh/clock-out-maybe ()
        (when (and bh/keep-clock-running
                   (not org-clock-clocking-in)
                   (marker-buffer org-clock-default-task)
                   (not org-clock-resolving-clocks-due-to-idleness))
          (bh/clock-in-parent-task)))

      (add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)

      (setq org-agenda-clock-consistency-checks
            (quote (:max-duration "4:00"
                                  :min-duration 0
                                  :max-gap 0
                                  :gap-ok-around ("4:00"))))
    #+END_SRC

*** Time reporting

    #+BEGIN_SRC emacs-lisp
      ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
      (setq org-clock-out-remove-zero-time-clocks t)

      ;; Agenda clock report parameters
      (setq org-agenda-clockreport-parameter-plist
            (quote (:link t :maxlevel 5 :fileskip0 t :compact t :narrow 80)))

                                              ; Set default column view headings: Task Effort Clock_Summary
      (setq org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")

                                              ; global Effort estimate values
                                              ; global STYLE property values for completion
      (setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                          ("STYLE_ALL" . "habit"))))

      ;; Agenda log mode items to display (closed and state changes by default)
      (setq org-agenda-log-mode-items (quote (closed state)))
    #+END_SRC

*** Tags

    #+BEGIN_SRC emacs-lisp
                                              ; Tags with fast selection keys
      (setq org-tag-alist (quote ((:startgroup)
                                  ("@errand" . ?e)
                                  ("@office" . ?o)
                                  ("@home" . ?H)
                                  ("@farm" . ?f)
                                  (:endgroup)
                                  ("WAITING" . ?w)
                                  ("HOLD" . ?h)
                                  ("PERSONAL" . ?P)
                                  ("WORK" . ?W)
                                  ("FARM" . ?F)
                                  ("ORG" . ?O)
                                  ("NORANG" . ?N)
                                  ("crypt" . ?E)
                                  ("NOTE" . ?n)
                                  ("CANCELLED" . ?c)
                                  ("FLAGGED" . ??))))

                                              ; Allow setting single tags without the menu
      (setq org-fast-tag-selection-single-key (quote expert))

                                              ; For tag searches ignore tasks with scheduled and deadline dates
      (setq org-agenda-tags-todo-honor-ignore-options t)
    #+END_SRC

*** GTD

    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-span 'day)

      (setq org-stuck-projects (quote ("" nil nil "")))
      (defun bh/is-project-p ()
        "Any task with a todo keyword subtask"
        (save-restriction
          (widen)
          (let ((has-subtask)
                (subtree-end (save-excursion (org-end-of-subtree t)))
                (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
            (save-excursion
              (forward-line 1)
              (while (and (not has-subtask)
                          (< (point) subtree-end)
                          (re-search-forward "^\*+ " subtree-end t))
                (when (member (org-get-todo-state) org-todo-keywords-1)
                  (setq has-subtask t))))
            (and is-a-task has-subtask))))

      (defun bh/is-project-subtree-p ()
        "Any task with a todo keyword that is in a project subtree.
      Callers of this function already widen the buffer view."
        (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                    (point))))
          (save-excursion
            (bh/find-project-task)
            (if (equal (point) task)
                nil
              t))))

      (defun bh/is-task-p ()
        "Any task with a todo keyword and no subtask"
        (save-restriction
          (widen)
          (let ((has-subtask)
                (subtree-end (save-excursion (org-end-of-subtree t)))
                (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
            (save-excursion
              (forward-line 1)
              (while (and (not has-subtask)
                          (< (point) subtree-end)
                          (re-search-forward "^\*+ " subtree-end t))
                (when (member (org-get-todo-state) org-todo-keywords-1)
                  (setq has-subtask t))))
            (and is-a-task (not has-subtask)))))

      (defun bh/is-subproject-p ()
        "Any task which is a subtask of another project"
        (let ((is-subproject)
              (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
          (save-excursion
            (while (and (not is-subproject) (org-up-heading-safe))
              (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
                (setq is-subproject t))))
          (and is-a-task is-subproject)))

      (defun bh/list-sublevels-for-projects-indented ()
        "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
        This is normally used by skipping functions where this variable is already local to the agenda."
        (if (marker-buffer org-agenda-restrict-begin)
            (setq org-tags-match-list-sublevels 'indented)
          (setq org-tags-match-list-sublevels nil))
        nil)

      (defun bh/list-sublevels-for-projects ()
        "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
        This is normally used by skipping functions where this variable is already local to the agenda."
        (if (marker-buffer org-agenda-restrict-begin)
            (setq org-tags-match-list-sublevels t)
          (setq org-tags-match-list-sublevels nil))
        nil)

      (defvar bh/hide-scheduled-and-waiting-next-tasks t)

      (defun bh/toggle-next-task-display ()
        (interactive)
        (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
        (when  (equal major-mode 'org-agenda-mode)
          (org-agenda-redo))
        (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

      (defun bh/skip-stuck-projects ()
        "Skip trees that are not stuck projects"
        (save-restriction
          (widen)
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (if (bh/is-project-p)
                (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                       (has-next ))
                  (save-excursion
                    (forward-line 1)
                    (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                      (unless (member "WAITING" (org-get-tags-at))
                        (setq has-next t))))
                  (if has-next
                      nil
                    next-headline)) ; a stuck project, has subtasks but no next task
              nil))))

      (defun bh/skip-non-stuck-projects ()
        "Skip trees that are not stuck projects"
        ;; (bh/list-sublevels-for-projects-indented)
        (save-restriction
          (widen)
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (if (bh/is-project-p)
                (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                       (has-next ))
                  (save-excursion
                    (forward-line 1)
                    (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                      (unless (member "WAITING" (org-get-tags-at))
                        (setq has-next t))))
                  (if has-next
                      next-headline
                    nil)) ; a stuck project, has subtasks but no next task
              next-headline))))

      (defun bh/skip-non-projects ()
        "Skip trees that are not projects"
        ;; (bh/list-sublevels-for-projects-indented)
        (if (save-excursion (bh/skip-non-stuck-projects))
            (save-restriction
              (widen)
              (let ((subtree-end (save-excursion (org-end-of-subtree t))))
                (cond
                 ((bh/is-project-p)
                  nil)
                 ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
                  nil)
                 (t
                  subtree-end))))
          (save-excursion (org-end-of-subtree t))))

      (defun bh/skip-non-tasks ()
        "Show non-project tasks.
      Skip project and sub-project tasks, habits, and project related tasks."
        (save-restriction
          (widen)
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (cond
             ((bh/is-task-p)
              nil)
             (t
              next-headline)))))

      (defun bh/skip-project-trees-and-habits ()
        "Skip trees that are projects"
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              subtree-end)
             ((org-is-habit-p)
              subtree-end)
             (t
              nil)))))

      (defun bh/skip-projects-and-habits-and-single-tasks ()
        "Skip trees that are projects, tasks that are habits, single non-project tasks"
        (save-restriction
          (widen)
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (cond
             ((org-is-habit-p)
              next-headline)
             ((and bh/hide-scheduled-and-waiting-next-tasks
                   (member "WAITING" (org-get-tags-at)))
              next-headline)
             ((bh/is-project-p)
              next-headline)
             ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
              next-headline)
             (t
              nil)))))

      (defun bh/skip-project-tasks-maybe ()
        "Show tasks related to the current restriction.
      When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
      When not restricted, skip project and sub-project tasks, habits, and project related tasks."
        (save-restriction
          (widen)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (next-headline (save-excursion (or (outline-next-heading) (point-max))))
                 (limit-to-project (marker-buffer org-agenda-restrict-begin)))
            (cond
             ((bh/is-project-p)
              next-headline)
             ((org-is-habit-p)
              subtree-end)
             ((and (not limit-to-project)
                   (bh/is-project-subtree-p))
              subtree-end)
             ((and limit-to-project
                   (bh/is-project-subtree-p)
                   (member (org-get-todo-state) (list "NEXT")))
              subtree-end)
             (t
              nil)))))

      (defun bh/skip-project-tasks ()
        "Show non-project tasks.
      Skip project and sub-project tasks, habits, and project related tasks."
        (save-restriction
          (widen)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              subtree-end)
             ((org-is-habit-p)
              subtree-end)
             ((bh/is-project-subtree-p)
              subtree-end)
             (t
              nil)))))

      (defun bh/skip-non-project-tasks ()
        "Show project tasks.
      Skip project and sub-project tasks, habits, and loose non-project tasks."
        (save-restriction
          (widen)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (cond
             ((bh/is-project-p)
              next-headline)
             ((org-is-habit-p)
              subtree-end)
             ((and (bh/is-project-subtree-p)
                   (member (org-get-todo-state) (list "NEXT")))
              subtree-end)
             ((not (bh/is-project-subtree-p))
              subtree-end)
             (t
              nil)))))

      (defun bh/skip-projects-and-habits ()
        "Skip trees that are projects and tasks that are habits"
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              subtree-end)
             ((org-is-habit-p)
              subtree-end)
             (t
              nil)))))

      (defun bh/skip-non-subprojects ()
        "Skip trees that are not projects"
        (let ((next-headline (save-excursion (outline-next-heading))))
          (if (bh/is-subproject-p)
              nil
            next-headline)))
    #+END_SRC

*** Archiving

    #+BEGIN_SRC emacs-lisp
      (setq org-archive-mark-done nil)
      (setq org-archive-location "%s_archive::* Archived Tasks")
      (defun bh/skip-non-archivable-tasks ()
        "Skip trees that are not available for archiving"
        (save-restriction
          (widen)
          ;; Consider only tasks with done todo headings as archivable candidates
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
                (subtree-end (save-excursion (org-end-of-subtree t))))
            (if (member (org-get-todo-state) org-todo-keywords-1)
                (if (member (org-get-todo-state) org-done-keywords)
                    (let* ((daynr (string-to-int (format-time-string "%d" (current-time))))
                           (a-month-ago (* 60 60 24 (+ daynr 1)))
                           (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                           (this-month (format-time-string "%Y-%m-" (current-time)))
                           (subtree-is-current (save-excursion
                                                 (forward-line 1)
                                                 (and (< (point) subtree-end)
                                                      (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                      (if subtree-is-current
                          subtree-end ; Has a date in this month or last month, skip it
                        nil))  ; available to archive
                  (or subtree-end (point-max)))
              next-headline))))
    #+END_SRC

*** Reminders

    #+BEGIN_SRC emacs-lisp
                                              ; Erase all reminders and rebuilt reminders for today from the agenda
      (defun bh/org-agenda-to-appt ()
        (interactive)
        (setq appt-time-msg-list nil)
        (org-agenda-to-appt))

                                              ; Rebuild the reminders everytime the agenda is displayed
      (add-hook 'org-finalize-agenda-hook 'bh/org-agenda-to-appt 'append)

                                              ; This is at the end of my .emacs - so appointments are set up when Emacs starts
      (bh/org-agenda-to-appt)

                                              ; Activate appointments so we get notifications
      (appt-activate t)

                                              ; If we leave Emacs running overnight - reset the appointments one minute after midnight
      (run-at-time "24:01" nil 'bh/org-agenda-to-appt)

    #+END_SRC

*** Productivity

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "<f5>") 'bh/org-todo)

      (defun bh/org-todo (arg)
        (interactive "p")
        (if (equal arg 4)
            (save-restriction
              (bh/narrow-to-org-subtree)
              (org-show-todo-tree nil))
          (bh/narrow-to-org-subtree)
          (org-show-todo-tree nil)))

      (global-set-key (kbd "<S-f5>") 'bh/widen)

      (defun bh/widen ()
        (interactive)
        (if (equal major-mode 'org-agenda-mode)
            (progn
              (org-agenda-remove-restriction-lock)
              (when org-agenda-sticky
                (org-agenda-redo)))
          (widen)))

      (add-hook 'org-agenda-mode-hook
                '(lambda () (org-defkey org-agenda-mode-map "W" (lambda () (interactive) (setq bh/hide-scheduled-and-waiting-next-tasks t) (bh/widen))))
                'append)

      (defun bh/restrict-to-file-or-follow (arg)
        "Set agenda restriction to 'file or with argument invoke follow mode.
      I don't use follow mode very often but I restrict to file all the time
      so change the default 'F' binding in the agenda to allow both"
        (interactive "p")
        (if (equal arg 4)
            (org-agenda-follow-mode)
          (widen)
          (bh/set-agenda-restriction-lock 4)
          (org-agenda-redo)
          (beginning-of-buffer)))

      (add-hook 'org-agenda-mode-hook
                '(lambda () (org-defkey org-agenda-mode-map "F" 'bh/restrict-to-file-or-follow))
                'append)

      (defun bh/narrow-to-org-subtree ()
        (widen)
        (org-narrow-to-subtree)
        (save-restriction
          (org-agenda-set-restriction-lock)))

      (defun bh/narrow-to-subtree ()
        (interactive)
        (if (equal major-mode 'org-agenda-mode)
            (progn
              (org-with-point-at (org-get-at-bol 'org-hd-marker)
                (bh/narrow-to-org-subtree))
              (when org-agenda-sticky
                (org-agenda-redo)))
          (bh/narrow-to-org-subtree)))

      (add-hook 'org-agenda-mode-hook
                '(lambda () (org-defkey org-agenda-mode-map "N" 'bh/narrow-to-subtree))
                'append)

      (defun bh/narrow-up-one-org-level ()
        (widen)
        (save-excursion
          (outline-up-heading 1 'invisible-ok)
          (bh/narrow-to-org-subtree)))

      (defun bh/get-pom-from-agenda-restriction-or-point ()
        (or (and (marker-position org-agenda-restrict-begin) org-agenda-restrict-begin)
            (org-get-at-bol 'org-hd-marker)
            (and (equal major-mode 'org-mode) (point))
            org-clock-marker))

      (defun bh/narrow-up-one-level ()
        (interactive)
        (if (equal major-mode 'org-agenda-mode)
            (progn
              (org-with-point-at (bh/get-pom-from-agenda-restriction-or-point)
                (bh/narrow-up-one-org-level))
              (org-agenda-redo))
          (bh/narrow-up-one-org-level)))

      (add-hook 'org-agenda-mode-hook
                '(lambda () (org-defkey org-agenda-mode-map "U" 'bh/narrow-up-one-level))
                'append)

      (defun bh/narrow-to-org-project ()
        (widen)
        (save-excursion
          (bh/find-project-task)
          (bh/narrow-to-org-subtree)))

      (defun bh/narrow-to-project ()
        (interactive)
        (if (equal major-mode 'org-agenda-mode)
            (progn
              (org-with-point-at (bh/get-pom-from-agenda-restriction-or-point)
                (bh/narrow-to-org-project)
                (save-excursion
                  (bh/find-project-task)
                  (org-agenda-set-restriction-lock)))
              (org-agenda-redo)
              (beginning-of-buffer))
          (bh/narrow-to-org-project)
          (save-restriction
            (org-agenda-set-restriction-lock))))

      (add-hook 'org-agenda-mode-hook
                '(lambda () (org-defkey org-agenda-mode-map "P" 'bh/narrow-to-project))
                'append)

      (defvar bh/project-list nil)

      (defun bh/view-next-project ()
        (interactive)
        (let (num-project-left current-project)
          (unless (marker-position org-agenda-restrict-begin)
            (goto-char (point-min))
                                              ; Clear all of the existing markers on the list
            (while bh/project-list
              (set-marker (pop bh/project-list) nil))
            (re-search-forward "Tasks to Refile")
            (forward-visible-line 1))

                                              ; Build a new project marker list
          (unless bh/project-list
            (while (< (point) (point-max))
              (while (and (< (point) (point-max))
                          (or (not (org-get-at-bol 'org-hd-marker))
                              (org-with-point-at (org-get-at-bol 'org-hd-marker)
                                (or (not (bh/is-project-p))
                                    (bh/is-project-subtree-p)))))
                (forward-visible-line 1))
              (when (< (point) (point-max))
                (add-to-list 'bh/project-list (copy-marker (org-get-at-bol 'org-hd-marker)) 'append))
              (forward-visible-line 1)))

                                              ; Pop off the first marker on the list and display
          (setq current-project (pop bh/project-list))
          (when current-project
            (org-with-point-at current-project
              (setq bh/hide-scheduled-and-waiting-next-tasks nil)
              (bh/narrow-to-project))
                                              ; Remove the marker
            (setq current-project nil)
            (org-agenda-redo)
            (beginning-of-buffer)
            (setq num-projects-left (length bh/project-list))
            (if (> num-projects-left 0)
                (message "%s projects left to view" num-projects-left)
              (beginning-of-buffer)
              (setq bh/hide-scheduled-and-waiting-next-tasks t)
              (error "All projects viewed.")))))

      (add-hook 'org-agenda-mode-hook
                '(lambda () (org-defkey org-agenda-mode-map "V" 'bh/view-next-project))
                'append)

      (setq org-show-entry-below (quote ((default))))

      (add-hook 'org-agenda-mode-hook
                '(lambda () (org-defkey org-agenda-mode-map "\C-c\C-x<" 'bh/set-agenda-restriction-lock))
                'append)

      (defun bh/set-agenda-restriction-lock (arg)
        "Set restriction lock to current task subtree or file if prefix is specified"
        (interactive "p")
        (let* ((pom (bh/get-pom-from-agenda-restriction-or-point))
               (tags (org-with-point-at pom (org-get-tags-at))))
          (let ((restriction-type (if (equal arg 4) 'file 'subtree)))
            (save-restriction
              (cond
               ((and (equal major-mode 'org-agenda-mode) pom)
                (org-with-point-at pom
                  (org-agenda-set-restriction-lock restriction-type))
                (org-agenda-redo))
               ((and (equal major-mode 'org-mode) (org-before-first-heading-p))
                (org-agenda-set-restriction-lock 'file))
               (pom
                (org-with-point-at pom
                  (org-agenda-set-restriction-lock restriction-type))))))))

      ;; Always hilight the current agenda line
      (add-hook 'org-agenda-mode-hook
                '(lambda () (hl-line-mode 1))
                'append)


      ;; Keep tasks with dates on the global todo lists
      (setq org-agenda-todo-ignore-with-date nil)

      ;; Keep tasks with deadlines on the global todo lists
      (setq org-agenda-todo-ignore-deadlines nil)

      ;; Keep tasks with scheduled dates on the global todo lists
      (setq org-agenda-todo-ignore-scheduled nil)

      ;; Keep tasks with timestamps on the global todo lists
      (setq org-agenda-todo-ignore-timestamp nil)

      ;; Remove completed deadline tasks from the agenda view
      (setq org-agenda-skip-deadline-if-done t)

      ;; Remove completed scheduled tasks from the agenda view
      (setq org-agenda-skip-scheduled-if-done t)

      ;; Remove completed items from search results
      (setq org-agenda-skip-timestamp-if-done t)

      (setq org-agenda-include-diary nil)
      (setq org-agenda-diary-file "~/org/diary.org")

      (setq org-agenda-insert-diary-extract-time t)
      ;; Include agenda archive files when searching for things
      (setq org-agenda-text-search-extra-files (quote (agenda-archives)))

      ;; Show all future entries for repeating tasks
      (setq org-agenda-repeating-timestamp-show-all t)

      ;; Show all agenda dates - even if they are empty
      (setq org-agenda-show-all-dates t)

      ;; Sorting order for tasks on the agenda
      (setq org-agenda-sorting-strategy
            (quote ((agenda habit-down time-up user-defined-up effort-up category-keep)
                    (todo category-up effort-up)
                    (tags category-up effort-up)
                    (search category-up))))

      ;; Start the weekly agenda on Monday
      (setq org-agenda-start-on-weekday 1)

      ;; Enable display of the time grid so we can see the marker for the current time
      (setq org-agenda-time-grid (quote ((daily today remove-match)
                                         ("----------------" 0 16 (org-heading t))
                                         (0900 1100 1300 1500 1700))))

      ;; Display tags farther right
      (setq org-agenda-tags-column -102)

      ;;
      ;; Agenda sorting functions
      ;;
      (setq org-agenda-cmp-user-defined 'bh/agenda-sort)

      (defun bh/agenda-sort (a b)
        "Sorting strategy for agenda items.
      Late deadlines first, then scheduled, then non-late deadlines"
        (let (result num-a num-b)
          (cond
                                              ; time specific items are already sorted first by org-agenda-sorting-strategy

                                              ; non-deadline and non-scheduled items next
           ((bh/agenda-sort-test 'bh/is-not-scheduled-or-deadline a b))

                                              ; deadlines for today next
           ((bh/agenda-sort-test 'bh/is-due-deadline a b))

                                              ; late deadlines next
           ((bh/agenda-sort-test-num 'bh/is-late-deadline '> a b))

                                              ; scheduled items for today next
           ((bh/agenda-sort-test 'bh/is-scheduled-today a b))

                                              ; late scheduled items next
           ((bh/agenda-sort-test-num 'bh/is-scheduled-late '> a b))

                                              ; pending deadlines last
           ((bh/agenda-sort-test-num 'bh/is-pending-deadline '< a b))

                                              ; finally default to unsorted
           (t (setq result nil)))
          result))

      (defmacro bh/agenda-sort-test (fn a b)
        "Test for agenda sort"
        `(cond
                                              ; if both match leave them unsorted
          ((and (apply ,fn (list ,a))
                (apply ,fn (list ,b)))
           (setq result nil))
                                              ; if a matches put a first
          ((apply ,fn (list ,a))
           (setq result -1))
                                              ; otherwise if b matches put b first
          ((apply ,fn (list ,b))
           (setq result 1))
                                              ; if none match leave them unsorted
          (t nil)))

      (defmacro bh/agenda-sort-test-num (fn compfn a b)
        `(cond
          ((apply ,fn (list ,a))
           (setq num-a (string-to-number (match-string 1 ,a)))
           (if (apply ,fn (list ,b))
               (progn
                 (setq num-b (string-to-number (match-string 1 ,b)))
                 (setq result (if (apply ,compfn (list num-a num-b))
                                  -1
                                1)))
             (setq result -1)))
          ((apply ,fn (list ,b))
           (setq result 1))
          (t nil)))

      (defun bh/is-not-scheduled-or-deadline (date-str)
        (and (not (bh/is-deadline date-str))
             (not (bh/is-scheduled date-str))))

      (defun bh/is-due-deadline (date-str)
        (string-match "Deadline:" date-str))

      (defun bh/is-late-deadline (date-str)
        (string-match "\\([0-9]*\\) d\. ago:" date-str))

      (defun bh/is-pending-deadline (date-str)
        (string-match "In \\([^-]*\\)d\.:" date-str))

      (defun bh/is-deadline (date-str)
        (or (bh/is-due-deadline date-str)
            (bh/is-late-deadline date-str)
            (bh/is-pending-deadline date-str)))

      (defun bh/is-scheduled (date-str)
        (or (bh/is-scheduled-today date-str)
            (bh/is-scheduled-late date-str)))

      (defun bh/is-scheduled-today (date-str)
        (string-match "Scheduled:" date-str))

      (defun bh/is-scheduled-late (date-str)
        (string-match "Sched\.\\(.*\\)x:" date-str))

      ;; Use sticky agenda's so they persist
      (setq org-agenda-sticky t)

      (require 'org-checklist)
      (setq org-enforce-todo-dependencies t)
      (setq org-cycle-separator-lines 0)
      (setq org-blank-before-new-entry (quote ((heading)
                                               (plain-list-item . auto))))
      (setq org-insert-heading-respect-content nil)
      (setq org-reverse-note-order nil)
      (setq org-show-following-heading t)
      (setq org-show-hierarchy-above t)
      (setq org-show-siblings (quote ((default))))
      (setq org-special-ctrl-a/e t)
      (setq org-special-ctrl-k t)
      (setq org-yank-adjusted-subtrees t)
      (setq org-id-method (quote uuidgen))
      (setq org-deadline-warning-days 30)
      (setq org-log-done (quote time))
      (setq org-log-into-drawer t)
      (setq org-log-state-notes-insert-after-drawers nil)
      (setq org-todo-keywords
            (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                    (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))
      (setq org-link-frame-setup (quote ((vm . vm-visit-folder)
                                         (gnus . org-gnus-no-new-news)
                                         (file . find-file))))
      (setq org-habit-graph-column 50)
      (run-at-time "06:00" 86400 '(lambda () (setq org-habit-show-habits t)))
      (defvar bh/insert-inactive-timestamp t)

      (defun bh/toggle-insert-inactive-timestamp ()
        (interactive)
        (setq bh/insert-inactive-timestamp (not bh/insert-inactive-timestamp))
        (message "Heading timestamps are %s" (if bh/insert-inactive-timestamp "ON" "OFF")))

      (defun bh/insert-inactive-timestamp ()
        (interactive)
        (org-insert-time-stamp nil t t nil nil nil))

      (defun bh/insert-heading-inactive-timestamp ()
        (save-excursion
          (when bh/insert-inactive-timestamp
            (org-return)
            (org-cycle)
            (bh/insert-inactive-timestamp))))

      (add-hook 'org-insert-heading-hook 'bh/insert-heading-inactive-timestamp 'append)
      (global-set-key (kbd "<f9> t") 'bh/insert-inactive-timestamp)
      (setq org-export-with-timestamps nil)
      (setq org-return-follows-link t)
      (custom-set-faces
       ;; custom-set-faces was added by Custom.
       ;; If you edit it by hand, you could mess it up, so be careful.
       ;; Your init file should contain only one such instance.
       ;; If there is more than one, they won't work right.
       '(org-mode-line-clock ((t (:foreground "red"))) t))
      (setq org-tags-match-list-sublevels t)
      (setq org-agenda-persistent-filter t)
      (setq org-link-mailto-program (quote (compose-mail "%a" "%s")))
      (setq org-agenda-window-setup 'current-window)
      (setq org-clone-delete-id t)
      (setq org-cycle-include-plain-lists t)
      (setq org-src-fontify-natively t)
      (setq org-structure-template-alist
            (quote (("s" "#+begin_src ?\n\n#+end_src" "<src lang=\"?\">\n\n</src>")
                    ("e" "#+begin_example\n?\n#+end_example" "<example>\n?\n</example>")
                    ("q" "#+begin_quote\n?\n#+end_quote" "<quote>\n?\n</quote>")
                    ("v" "#+begin_verse\n?\n#+end_verse" "<verse>\n?\n</verse>")
                    ("c" "#+begin_center\n?\n#+end_center" "<center>\n?\n</center>")
                    ("l" "#+begin_latex\n?\n#+end_latex" "<literal style=\"latex\">\n?\n</literal>")
                    ("L" "#+latex: " "<literal style=\"latex\">?</literal>")
                    ("h" "#+begin_html\n?\n#+end_html" "<literal style=\"html\">\n?\n</literal>")
                    ("H" "#+html: " "<literal style=\"html\">?</literal>")
                    ("a" "#+begin_ascii\n?\n#+end_ascii")
                    ("A" "#+ascii: ")
                    ("i" "#+index: ?" "#+index: ?")
                    ("I" "#+include %file ?" "<include file=%file markup=\"?\">"))))
      (defun bh/mark-next-parent-tasks-todo ()
        "Visit each parent task and change NEXT states to TODO"
        (let ((mystate (or (and (fboundp 'org-state)
                                state)
                           (nth 2 (org-heading-components)))))
          (when mystate
            (save-excursion
              (while (org-up-heading-safe)
                (when (member (nth 2 (org-heading-components)) (list "NEXT"))
                  (org-todo "TODO")))))))

      (add-hook 'org-after-todo-state-change-hook 'bh/mark-next-parent-tasks-todo 'append)
      (add-hook 'org-clock-in-hook 'bh/mark-next-parent-tasks-todo 'append)
      (setq org-startup-folded t)
      (setq org-alphabetical-lists t)
      (add-hook 'message-mode-hook 'orgstruct++-mode 'append)
      (add-hook 'message-mode-hook 'turn-on-auto-fill 'append)
      (add-hook 'message-mode-hook 'bbdb-define-all-aliases 'append)
      (add-hook 'message-mode-hook 'orgtbl-mode 'append)
      (add-hook 'message-mode-hook 'turn-on-flyspell 'append)
      (add-hook 'message-mode-hook
                '(lambda () (setq fill-column 72))
                'append)
      (setq org-src-preserve-indentation nil)
      (setq org-edit-src-content-indentation 0)
      ;; (setq org-catch-invisible-edits 'error)
      ;; (setq org-catch-invisible-edits nil)
      (setq org-export-coding-system 'utf-8)
      (prefer-coding-system 'utf-8)
      (set-charset-priority 'unicode)
      (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
      (setq org-time-clocksum-format
            '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))
      (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
    #+END_SRC

*** block splitting

    #+begin_src emacs-lisp
      (defun modi/org-in-any-block-p ()
        "Return non-nil if the point is in any Org block.

      The Org block can be *any*: src, example, verse, etc., even any
      Org Special block.

      This function is heavily adapted from `org-between-regexps-p'."
        (save-match-data
          (let ((pos (point))
                (case-fold-search t)
                (block-begin-re "^[[:blank:]]*#\\+begin_\\(?1:.+?\\)\\(?: .*\\)*$")
                (limit-up (save-excursion (outline-previous-heading)))
                (limit-down (save-excursion (outline-next-heading)))
                beg end)
            (save-excursion
              ;; Point is on a block when on BLOCK-BEGIN-RE or if
              ;; BLOCK-BEGIN-RE can be found before it...
              (and (or (org-in-regexp block-begin-re)
                       (re-search-backward block-begin-re limit-up :noerror))
                   (setq beg (match-beginning 0))
                   ;; ... and BLOCK-END-RE after it...
                   (let ((block-end-re (concat "^[[:blank:]]*#\\+end_"
                                               (match-string-no-properties 1)
                                               "\\( .*\\)*$")))
                     (goto-char (match-end 0))
                     (re-search-forward block-end-re limit-down :noerror))
                   (> (setq end (match-end 0)) pos)
                   ;; ... without another BLOCK-BEGIN-RE in-between.
                   (goto-char (match-beginning 0))
                   (not (re-search-backward block-begin-re (1+ beg) :noerror))
                   ;; Return value.
                   (cons beg end))))))

      (defun modi/org-split-block ()
        "Sensibly split the current Org block at point."
        (interactive)
        (if (modi/org-in-any-block-p)
            (save-match-data
              (save-restriction
                (widen)
                (let ((case-fold-search t)
                      (at-bol (bolp))
                      block-start
                      block-end)
                  (save-excursion
                    (re-search-backward "^\\(?1:[[:blank:]]*#\\+begin_.+?\\)\\(?: .*\\)*$" nil nil 1)
                    (setq block-start (match-string-no-properties 0))
                    (setq block-end (replace-regexp-in-string
                                     "begin_" "end_" ;Replaces "begin_" with "end_", "BEGIN_" with "END_"
                                     (match-string-no-properties 1))))
                  ;; Go to the end of current line, if not at the BOL
                  (unless at-bol
                    (end-of-line 1))
                  (insert (concat (if at-bol "" "\n")
                                  block-end
                                  "\n\n"
                                  block-start
                                  (if at-bol "\n" "")))
                  ;; Go to the line before the inserted "#+begin_ .." line
                  (beginning-of-line (if at-bol -1 0)))))
          (message "Point is not in an Org block")))

      (defun modi/org-meta-return (&optional arg)
        "Insert a new heading or wrap a region in a table.

      Calls `org-insert-heading', `org-insert-item',
      `org-table-wrap-region', or `modi/org-split-block' depending on
      context.  When called with an argument, unconditionally call
      `org-insert-heading'."
        (interactive "P")
        (org-check-before-invisible-edit 'insert)
        (or (run-hook-with-args-until-success 'org-metareturn-hook)
            (call-interactively (cond (arg #'org-insert-heading)
                                      ((org-at-table-p) #'org-table-wrap-region)
                                      ((org-in-item-p) #'org-insert-item)
                                      ((modi/org-in-any-block-p) #'modi/org-split-block)
                                      (t #'org-insert-heading)))))

      (advice-add 'org-meta-return :override #'modi/org-meta-return)
    #+end_src

** Iedit
** Diff hl mode

   #+BEGIN_SRC emacs-lisp
     (diff-hl-flydiff-mode '(:global t))
   #+END_SRC

** Ispell
   #+begin_src emacs-lisp
     (setq ispell-program-name "/usr/local/bin/aspell" )
   #+end_src

** ediff
   #+begin_src emacs-lisp
     (defun ediff-copy-both-to-C ()
       (interactive)
       (ediff-copy-diff ediff-current-difference nil 'C nil
                        (concat
                         (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                         (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
     (defun add-d-to-ediff-mode-map () (define-key ediff-mode-map "d" 'ediff-copy-both-to-C))
     (add-hook 'ediff-keymap-setup-hook 'add-d-to-ediff-mode-map)
   #+end_src

** Langs

   #+BEGIN_SRC emacs-lisp
     (spacemacs/toggle-evil-safe-lisp-structural-editing-on-register-hooks)
   #+END_SRC

*** JS

    #+BEGIN_SRC emacs-lisp
      (setq js-indent-level 2)
    #+END_SRC

*** Clojure

    #+begin_src emacs-lisp
      (push '("melpa-stable" . "stable.melpa.org/packages/") configuration-layer-elpa-archives)
      (push '(cider . "melpa-stable") package-pinned-packages)
    #+end_src

    #+begin_src emacs-lisp
      (setq cider-invert-insert-eval-p t)
      (setq cider-switch-to-repl-after-insert-p nil)
      (setq cider-eval-toplevel-inside-comment-form t)
      (setq cider-save-file-on-load nil)

      (setq org-babel-clojure-backend 'cider
            cider-boot-parameters "cider testing dev")

      (setq cider-eval-toplevel-inside-comment-form t)
      (setq cider-cljs-lein-repl
            "(do (require 'figwheel-sidecar.repl-api)
                                    (figwheel-sidecar.repl-api/start-figwheel!)
                                    (figwheel-sidecar.repl-api/cljs-repl))")

      (defun re-seq (regexp string)
        "Get a list of all regexp matches in a string"
        (save-match-data
          (let ((pos 0)
                matches)
            (while (string-match regexp string pos)
              (push (match-string 0 string) matches)
              (setq pos (match-end 0)))
            matches)))

      ;; (defmacro my-print
      ;;   [expression]
      ;;   (list 'let ['result expression]
      ;;         (list 'println 'result)
      ;;         'result))

    #+end_src

**** Compiling CSS

     #+BEGIN_SRC emacs-lisp
       (defun splash-p ()
         (equal current-prefix-arg '(4)))

       (defun my-cider-compile-base-styles ()
         (interactive)
         (cider-eval-defun-at-point)
         (with-current-buffer "base.cljc"
           (cider-interactive-eval
            (concat
             "(->> (garden.core/css (sandi.styles.base/base-css {" (when (splash-p) ":splash? true") "}))
                   (spit \"resources/public/css/" (if (splash-p) "splash.css" "base.css")"\"))")
            (lambda (optional-args) (message (concat "CSS compiled to " (if (splash-p) "splash.css" "base.css")))))))

       (spacemacs/set-leader-keys-for-major-mode 'clojurec-mode
         "es" 'my-cider-compile-base-styles)

       (spacemacs/set-leader-keys-for-major-mode 'clojurescript-mode
         "es" 'my-cider-compile-base-styles)

       (after 'clojure-mode
         (define-key clojure-mode-map (kbd "C-c e s") 'my-cider-compile-base-styles))
     #+END_SRC

**** Cider

     #+BEGIN_SRC emacs-lisp

       ;; (defun my-any-line-that-contains (string)
       ;;   (rx-form
       ;;    `(sequence
       ;;     line-start
       ;;     (repeat 6 (sequence (repeat 2 alnum) not-newline))
       ;;     (* (not (any " "))) " "
       ;;     (or "INFO" "DEBUG") " "
       ;;     ,string
       ;;     (zero-or-more anything))))

       ;; (defmacro rx-extra (&rest body-forms)
       ;;   (let ((add-ins (list
       ;;                   `(my-any-line-that-contains . (my-any-line-that-contains 1 1))
       ;;                   )))
       ;;     `(let ((rx-constituents (append ',add-ins rx-constituents nil)))
       ;;        ,@body-forms)))

       (defun cider-repl--emit-output-at-pos (buffer string output-face position &optional bol)
         "Using BUFFER, insert STRING (applying to it OUTPUT-FACE) at POSITION.
       If BOL is non-nil insert at the beginning of line.  Run
       `cider-repl-preoutput-hook' on STRING."
         (with-current-buffer buffer
           (save-excursion
             (cider-save-marker cider-repl-output-start
               (cider-save-marker cider-repl-output-end
                 (goto-char position)
                 ;; TODO: Review the need for bol
                 (when (and bol (not (bolp))) (insert-before-markers "\n"))
                 (setq string (propertize string
                                          'font-lock-face output-face
                                          'rear-nonsticky '(font-lock-face)))
                 (setq string (cider-run-chained-hook 'cider-repl-preoutput-hook string))
                 (insert-before-markers
                  (replace-regexp-in-string
                   (rx

                    (or

                     (sequence
                      line-start
                      (repeat 6 (sequence (repeat 2 alnum) not-newline))
                      (* (not (any " "))) " "
                      (or "INFO" "DEBUG") " "
                      "[com.zaxxer.hikari.HikariDataSource"
                      (zero-or-more anything))

                     (sequence
                      line-start
                      (repeat 6 (sequence (repeat 2 alnum) not-newline))
                      (* (not (any " "))) " "
                      (or "INFO" "DEBUG") " "
                      "[org.apache.http"
                      (zero-or-more anything))

                     (sequence
                      line-start
                      (repeat 6 (sequence (repeat 2 alnum) not-newline))
                      (* (not (any " "))) " "
                      (or "INFO" "DEBUG") " ")

                     ))
                   ""
                   string))
                 (cider-repl--flush-ansi-color-context)
                 (when (and (= (point) cider-repl-prompt-start-mark)
                            (not (bolp)))
                   (insert-before-markers "\n")
                   (set-marker cider-repl-output-end (1- (point)))))))
           (cider-repl--show-maximum-output)))
     #+END_SRC

**** keys

     #+BEGIN_SRC emacs-lisp
       (evil-define-key 'insert emacs-lisp-mode-map ")" 'sp-up-sexp)
       (evil-define-key 'insert clojure-mode-map ")" 'sp-up-sexp)
       (define-key cider-mode-map (kbd "C-c C-c") 'cider-pprint-eval-defun-at-point)
     #+END_SRC

**** taps


*** HAML

    #+begin_src emacs-lisp
      (add-to-list 'auto-mode-alist '("\\.twig\\'" . haml-mode))
    #+end_src

#+setupfile: ./setup-file.org
#+title: Environment
#+author: Donavan-Ross Costaras
#+email: d.costaras@gmail.com

* Emacs
** todos
*** DONE set C-M-\ to nil to train self to use indentation evil verb "="
*** TODO org src buffers to be added to workspace
*** TODO cider switch to last buffer from repl (C-c C-z) should do so across frames
*** TODO C-h sometimes doesn't work as back level in counsel find file
*** TODO figure out how to have uncharged time in org clocktables
*** TODO clj-kondo/clojure-lsp can't find reference if it's used a default destructuring arg

currency-format is in the :or map of the next function
#+begin_src clojure
(defn currency-format [value]
  (ft/format-number value {:currency? true
                           :round-to  0
                           :dash?     false}))

(defn unroll-row [content key & {:keys [format-fn classes style]
                                 :or   {format-fn currency-format
                                        classes   []
                                        style     {}}}]
  (map
   (fn [x] (dom/td {:classes classes :style style}
                   (format-fn (key x))))
   content))
#+end_src

*** TODO clj-kondo/clojure-lsp clean-ns doesn't see aliases used in keywords as usage and removes the entries
*** TODO clj-kondo/clojure-lsp can't autocomplete locals
*** TODO auto complete refers in ns forms
*** TODO auto complete should support symbols in refer blocks
*** TODO eval last/current sexp text object
so one can yank eval last sexp
*** TODO Investigate with-undo-collapse
(defmacro with-undo-collapse (&rest body)
  "Like `progn' but perform BODY with undo collapsed."
  (declare (indent 0) (debug t))
  (let ((handle (make-symbol "--change-group-handle--"))
        (success (make-symbol "--change-group-success--")))
    `(let ((,handle (prepare-change-group))
            ;; Don't truncate any undo data in the middle of this.
            (undo-outer-limit nil)
            (undo-limit most-positive-fixnum)
            (undo-strong-limit most-positive-fixnum)
            (,success nil))
       (unwind-protect
         (progn
           (activate-change-group ,handle)
           (prog1 ,(macroexp-progn body)
             (setq ,success t)))
         (if ,success
           (progn
             (accept-change-group ,handle)
             (undo-amalgamate-change-group ,handle))
           (cancel-change-group ,handle))))))
*** TODO investigate binky mode
https://github.com/liuyinz/binky-mode/tree/b430ad8b6bcc03830cd910d0540e149f68780cf8
*** TODO pcase-defun
>  (defun eval-feature-expression (form)
>    (pcase form
>     ((pred atom) (featurep form nil))
>     (`(not ,x) (not (eval-feature-expression x)))
>     (`(and) t)
>     (`(and ,form1 . ,forms)
>      (and (eval-feature-expression form1)
>           (eval-feature-expression (cons 'and forms))))
>     (`(or) nil)
>     (`(or ,form1 . ,forms)
>      (or (eval-feature-expression form1)
>          (eval-feature-expression (cons 'or forms))))
>     (t (error "Invalid feature expression: %s" form)))))
*** TODO investigate using src blocks as templates for babel and export
*** TODO make a tangle like option called :compile
*** TODO Investigate using +default/search-buffer for evil search

Based on https://github.com/doomemacs/doomemacs/issues/6478#issuecomment-1328110153

#+begin_src elisp
(defun org-show-current-heading-tidily ()
  (interactive)                         ;Inteactive
  "Show next entry, keeping other entries closed."
  (if (save-excursion (end-of-line) (outline-invisible-p))
      (progn (org-show-entry) (show-children))
    (setq-local my:current_line (line-number-at-pos))
    (outline-back-to-heading)
    (unless (and (bolp) (org-on-heading-p))
      (org-up-heading-safe)
      (hide-subtree)
      (error "Boundary reached"))
    (org-overview)
    (org-reveal t)
    (org-show-entry)
    (show-children)
    (goto-line my:current_line)))

(defun qw/search-buffer ()
  (interactive)
  (org-fold-show-all)
  (+default/search-buffer)
  (org-show-current-heading-tidily))
#+end_src
*** TODO make certain minor modes for auto compile, tangle, etc.

;; (defun eval-and-run ()
;;   (interactive)
;;   (eros-eval-defun nil)
;;   (save-excursion
;;     (with-current-buffer "sicp-workbook.org"
;;       (org-latex-export-to-latex))))

;; (general-define-key
;;  :keymaps 'org-src-mode-map
;;  "C-c C-c" #'eval-and-run)
*** TODO comment blocks in elisp
*** TODO bug in [[file:~/.config/doom-emacs/.local/straight/repos/org/lisp/ob-exp.el::defmacro org-babel-exp--at-source (&rest body][org macro debug declaration]]
*** TODO think of defun prefix for personal functions like `+` in doom emacs
*** TODO add :lexical t globally to all elisp src blocks

org-babel-default-header-args:elisp is a variable defined in
ob-emacs-lisp.el.

Value
((:lexical . "no"))

Set

Documentation
Default arguments for evaluating an elisp source block.

A value of "yes" or t causes source blocks to be eval'd using
lexical scoping.  It can also be an alist mapping symbols to
their value.  It is used both as the optional LEXICAL argument to
eval, and as the value for lexical-binding in buffers created
by org-edit-src-code.
*** TODO do a publish step when tangling environment so I don't lose the compiled versions and can't tangle on stock emacs / or see if I can bootstrap the tangling with default doom?
Use GitHub releases for this?
*** TODO load config after tangling env
*** TODO investigate doom popups module
*** TODO investigate use-package-compute-statistics
*** TODO :tangle property to take into account :dir property prefix
*** TODO backup scripts for annexes using prodigy
** config

*** Lexical binding

#+begin_src elisp :tangle ~/.doom.d/config.el :comments no
;;; -*- lexical-binding: t; -*-
#+end_src

*** Settings

#+begin_src elisp :tangle ~/.doom.d/config.el
(setq

 ;; Place your private configuration here! Remember, you do not need to run 'doom
 ;; sync' after modifying this file!

 ;; Some functionality uses this to identify you, e.g. GPG configuration, email
 ;; clients, file templates and snippets.
 user-full-name "Donavan-Ross Costaras"
 user-mail-address "d.costaras@gmail.com"

 ;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
 ;; are the three important ones:
 ;;
 ;; + `doom-font'
 ;; + `doom-variable-pitch-font'
 ;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for
 ;;   presentations or streaming.
 ;;
 ;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
 ;; font string. You generally only need these two:
 ;; (setq doom-font (font-spec :family "monospace" :size 12 :weight 'semi-light)
 ;;       doom-variable-pitch-font (font-spec :family "sans" :size 13))

 ;; There are two ways to load a theme. Both assume the theme is installed and
 ;; available. You can either set `doom-theme' or manually load a theme with the
 ;; ; If you use `org' and don't want your org files in the default location below,
 ;; change `org-directory'. It must be set before org loads!
 org-directory "~/org/"
 doom-font (font-spec :family "Fira Code" :size 13)
 display-line-numbers-type 'visual

 ;; IMO, modern editors have trained a bad habit into us all: a burning
 ;; need for completion all the time -- as we type, as we breathe, as we
 ;; pray to the ancient ones -- but how often do you *really* need that
 ;; information? I say rarely. So opt for manual completion:
 company-idle-delay nil

 ;; lsp-ui-sideline is redundant with eldoc and much more invasive, so
 ;; disable it by default.
 lsp-ui-sideline-enable nil
 lsp-enable-symbol-highlighting nil

 ;; More common use-case
 evil-ex-substitute-global t

 delete-by-moving-to-trash t
 truncate-string-ellipsis "…"
 auto-save-default t

 ns-use-native-fullscreen t)

;; More modern fill column length
(setq-default fill-column 100)

;; Turn subword mode on
(global-subword-mode 1)

;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.
;;
#+end_src

**** COMMENT Fullscreen

#+begin_src elisp :noweb-ref doom-config
(add-hook! 'emacs-startup-hook #'toggle-frame-fullscreen)
#+end_src

**** Pulse

#+begin_src elisp :tangle ~/.doom.d/config.el
;; This is not disabled even if we do not load the nav-flash :ui module
(remove-hook 'doom-switch-window-hook #'+nav-flash-blink-cursor-maybe-h)

(defun pulse-line (&rest _)
  "Pulse the current line."
  (pulse-momentary-highlight-one-line (point)))

(dolist (command '(evil-window-left
                   evil-window-right
                   evil-window-bottom
                   evil-window-down
                   evil-window-up
                   evil-scroll-down
                   evil-scroll-up
                   other-window))
  (advice-add command :after #'pulse-line))
#+end_src

*** MacOS

#+begin_src elisp :tangle ~/.doom.d/config.el
(setq mac-option-modifier 'super)
(setq mac-command-modifier 'meta)
(setq mac-pass-command-to-system nil)
#+end_src

*** Core dependencies

#+begin_src elisp :tangle ~/.doom.d/packages.el
(package! ht)
(package! xht
  :recipe (:type git :repo "https://git.sr.ht/~flandrew/xht"))
(package! s)
(package! dash)
(package! loopy)
#+end_src

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package! ht)
(use-package xht
  :config
  (global-xht-fontify-mode)
  (global-xht-do-mode))
(use-package! s)
(use-package! dash
  :config (global-dash-fontify-mode))
(use-package! loopy)
#+end_src

*** Functionality

**** f-string

From: https://kitchingroup.cheme.cmu.edu/blog/2018/05/14/f-strings-in-emacs-lisp/
#+begin_src elisp :tangle ~/.doom.d/config.el
(defmacro f-string (fmt)
  "Like `s-format' but with format fields in it.
FMT is a string to be expanded against the current lexical
environment. It is like what is used in `s-lex-format', but has
an expanded syntax to allow format-strings. For example:
${user-full-name 20s} will be expanded to the current value of
the variable `user-full-name' in a field 20 characters wide.
  (let ((f (sqrt 5)))  (f-string \"${f 1.2f}\"))
  will render as: 2.24
This function is inspired by the f-strings in Python 3.6, which I
enjoy using a lot.
"
  (let* ((matches (s-match-strings-all "${\\(?3:\\(?1:[^} ]+\\) *\\(?2:[^}]*\\)\\)}" fmt))
         (agetter (cl-loop for (m0 m1 m2 m3) in matches
                           collect `(cons ,m3 (format (format "%%%s" (if (string= ,m2 "")
                                                                         (if s-lex-value-as-lisp "S" "s")
                                                                       ,m2))
                                                      (symbol-value (intern ,m1)))))))

    `(s-format ,fmt 'aget (list ,@agetter))))
#+end_src

**** Coercion

#+begin_src elisp :tangle ~/.doom.d/config.el
(defun keyword->symbol (keyword)
  "Convert KEYWORD to symbol."
  (intern (substring (symbol-name keyword) 1)))

(defun keyword->string (keyword)
  "Convert KEYWORD to symbol."
  (substring (symbol-name keyword) 1))

(defun symbol->string (symbol)
  (symbol-name symbol))

(defun symbol->keyword (symbol)
  (intern (concat ":" (symbol-name symbol))))

(defun string->symbol (string)
  (intern string))
#+end_src

**** Printing

#+begin_src elisp :tangle ~/.doom.d/packages.el
(package! yaml)
#+end_src

#+begin_src elisp :tangle ~/.doom.d/config.el
(defun pp-nil (node)
  (pp node)
  "")

(defun ppn (node)
  (pp node)
  (message "\n"))

(after! org-ml
  (defun pp-node (node)
    (ppn (org-ml-remove-parent node))))

(defun prn (value)
  (message "%s" value))

(use-package! yaml
  :config
  (defun pp-yaml (value)
    (prn (yaml-encode value))))
#+end_src

**** Comment macro

#+begin_src elisp :tangle ~/.doom.d/config.el
(defmacro comment (&rest _)
  (declare (indent defun)))
#+end_src

**** >defadvice!

#+begin_src elisp :tangle ~/.doom.d/config.el
(defmacro >defadvice! (symbol arglist &optional docstring &rest args)
  "Define an advice called SYMBOL and add it to PLACES.

ARGLIST is as in `defun'. WHERE is a keyword as passed to `advice-add', and
PLACE is the function to which to add the advice, like in `advice-add'.
DOCSTRING and BODY are as in `defun'. Use :mode MODE to limit the advice to a mode.

\(fn SYMBOL ARGLIST &optional DOCSTRING &rest :mode MODE [WHERE PLACES...] BODY\)"
  (declare (doc-string 3) (indent defun))
  (unless (stringp docstring)
    (push docstring args)
    (setq docstring nil))
  (let (where-alist mode body)
    (named-let recur ((body* args))
      (pcase body*
        (`(:mode ,mode-symbol . ,_)
         (setq mode mode-symbol)
         (recur (cddr body*)))

        (`(,(and (pred keywordp) position)
           ,function . ,_)
         (push `(cons ,position (ensure-list ,function)) where-alist)
         (recur (cddr body*)))

        (_
         (setq body body*))))
    `(progn
       (defun ,symbol ,arglist
         ,docstring
         (when (or (derived-mode-p ',mode)
                   (and (boundp ',mode) ,mode))
           ,@body))
       (dolist (targets (list ,@(nreverse where-alist)))
         (dolist (target (cdr targets))
           (advice-add target (car targets) #',symbol))))))
#+end_src

**** fn and defn

#+name: fn-and-defn
#+begin_src emacs-lisp :tangle ~/.doom.d/config.el
(defmacro fn (args &rest body)
  (declare (doc-string 2) (indent defun))
  `(pcase-lambda ,args ,@body))

(defmacro defn (name arglist docstring &rest body)
  (declare (doc-string 3) (indent 2))
  (unless (stringp docstring)
    (setq body (cons docstring body)
          docstring nil))
  `(defalias ',name
     (pcase-lambda ,arglist ,@body)
     ,docstring))
#+end_src

This makes sure that the ~fn~ and ~defn~ functions are available during tangling with a stock emacs. When this block is tangled the block named by the noweb call is evaluated for it's side effects and we discard the result of tangling.
#+begin_src emacs-lisp :tangle /tmp/throw-away
<<fn-and-defn()>>
#+end_src

**** Process

#+begin_src elisp :noweb-ref :tangle ~/.doom.d/config.el
(defun >start-sudo-process (cmd)
  (with-temp-buffer
    (cd "/sudo::/")
    (>start-process cmd)))

(defun >start-process (cmd)
  (let* ((output-buffer (get-buffer-create (concat "*" cmd "*")))
         (proc (apply #'start-process cmd output-buffer (s-split " " cmd)))
         (sentinel (lambda (process signal)
                     (when (memq (process-status process) '(exit signal))
                       (message "Done: %s" cmd)))))
    (if (process-live-p proc)
        (set-process-sentinel proc sentinel)
      (message "No process running: %s" cmd))))
#+end_src

*** TODO Tail buffer minor mode

#+begin_src elisp :tangle ~/.doom.d/config.el
(defun message-buffer-goto-end-of-buffer (&rest args)
  (let* ((win (get-buffer-window "*Messages*"))
         (buf (and win (window-buffer win))))
    (and win (not (equal (current-buffer) buf))
         (set-window-point
          win (with-current-buffer buf (point-max))))))

;; (advice-add 'message :after 'message-buffer-goto-end-of-buffer)
#+end_src

*** org-mode

"Organize your plain life in plain text"

**** TODO Fixing current issues with searching in org buffers

#+begin_src elisp :noweb-ref org-init
(setq org-fold-core-style 'overlays)
#+end_src

#+begin_src elisp
;; Configuration A
(progn
  (setq org-fold-core-style 'overlays)
  (evil-select-search-module 'evil-search-module 'evil-search))

;; Configuration B
(progn
  (setq org-fold-core-style 'text-properties)
  (evil-select-search-module 'evil-search-module 'isearch))
#+end_src

**** API

#+begin_src elisp :noweb-ref org-config
(defun >unfold-heading (heading)
  (->> (org-ml-parse-headlines 'all)
       (org-ml-match-do `((:raw-value ,heading)) #'org-ml-unfold)))
#+end_src

**** Settings

#+begin_src elisp :noweb-ref org-config
(setq org-time-clocksum-use-effort-durations nil)
(setq org-duration-format '(("h" . nil) (special . 2)))
(setq org-effort-durations `(("h" . 60)))
(setq org-startup-folded t)
(setq org-directory "~/org")
#+end_src

**** Org buffers
**** Babel
:PROPERTIES:
:header-args+: :noweb-ref org-config
:END:

#+begin_src elisp
(set-popup-rule! "^\\*Org Src" :ignore t)
(setq org-src-window-setup 'current-window)
#+end_src

#+begin_src elisp :noweb-ref real-buffer
(string-match-p (rx line-start "*Org Src") (buffer-name buffer))
#+end_src

#+begin_src elisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (http . t)
   (racket . t)
   (scheme . t)
   <<org-babel-languages>>))
#+end_src

#+begin_src elisp
(>defadvice! >org-edit-src-save-before-+eval/buffer (&rest _)
  :mode org-src-mode
  :before #'+eval/buffer
  (org-edit-src-save))
#+end_src

#+begin_src elisp
(defun >tangle-source-buffer ()
  (interactive)
  (with-current-buffer (org-src-source-buffer)
    (org-babel-tangle)))
#+end_src

#+name: src-block-value
#+begin_src elisp :var name="" :var nl="" :noweb-ref no
(let* ((element (save-excursion
                  (org-babel-goto-named-src-block name)
                  (org-element-at-point)))
       (value (org-element-property :value element)))
  (if (s-equals? "nil" nl)
      (pp (replace-regexp-in-string "\n" "" value))
    (pp value)))
#+end_src

***** ex commands

#+begin_src elisp :noweb-ref org-init
(defun >org-src-mode-ex-commands ()
  (>evil-ex-define-local-cmd "w" #'org-edit-src-save))

(add-hook! org-src-mode #'>org-src-mode-ex-commands)
#+end_src

***** Keybindings

Keybindings are defined manually in the ~:config~ block because they need to override the org-mode defaults

#+begin_src elisp
(general-define-key
 :keymaps 'org-src-mode-map
 "C-c C-c" nil
 "C-c C-k" nil
 "C-c C-v C-t" #'>tangle-source-buffer
 "C-c '" #'org-edit-src-exit)
#+end_src

***** ob-http

#+begin_src elisp :noweb-ref packages
(package! ob-http)
#+end_src

#+begin_src elisp
(use-package! ob-http)
#+end_src

**** Auto tangling
***** COMMENT org-auto-tangle

uses:
#+auto_tangle: t

#+begin_src elisp :tangle ~/.doom.d/packages.el
(package! org-auto-tangle)
#+end_src

#+begin_src elisp
;; (use-package! org-auto-tangle
;;   :defer t
;;   :hook (org-mode . org-auto-tangle-mode)
;;   :config
;;   (setq org-auto-tangle-babel-safelist
;;         '("~/env/rc.org")))
#+end_src

***** another way of doing it
-*- eval: (add-hook 'after-save-hook #'org-babel-tangle nil 'buffer-local) -*-

***** Tie it into [[*make certain minor modes for auto compile, tangle, etc.][make certain minor modes for auto compile, tangle, etc.]]

**** COMMENT Worf

#+begin_src elisp :noweb-ref org-config
(use-package! worf
  :config

  (defun bjm/worf-insert-internal-link ()
    "Use ivy to insert a link to a heading in the current `org-mode' document. Code is based on `worf-goto'."
    (interactive)
    (let ((cands (worf--goto-candidates)))
      (ivy-read "Heading: " cands
                :action 'bjm/worf-insert-internal-link-action)))

  (defun bjm/worf-insert-internal-link-action (x)
    "Insert link for `bjm/worf-insert-internal-link'"
    ;; go to heading
    (save-excursion
      (goto-char (cdr x))
      ;; store link
      (call-interactively 'org-store-link))
    ;; return to original point and insert link
    (org-insert-last-stored-link 1)
    ;; org-insert-last-stored-link adds a newline so delete this
    (delete-backward-char 1)))
#+end_src

**** Agenda

#+begin_src elisp :noweb-ref real-buffer
(string-match-p (rx line-start "*Org Agenda*" line-end) (buffer-name buffer))
#+end_src

Restore org-agenda buffers when loading workspaces
#+begin_src elisp :noweb-ref persp-mode-config
(persp-def-buffer-save/load
 :mode 'org-agenda-mode
 :tag-symbol 'def-agenda-buffer
 :mode-restore-function #'(lambda (_mode) (org-agenda nil "t"))
 :save-vars '(major-mode default-directory))
#+end_src

#+begin_src elisp :noweb-ref org-config
(use-package! org-agenda
  :after org-roam
  :init
  (setq org-agenda-files
        (list org-directory
              org-roam-directory
              <<environment-file-name()>>)

        org-capture-templates
        `(("i" "Inbox" entry  (file ,(concat org-directory "/inbox.org"))
           ,(concat "* TODO %?\n"
                    "/Entered on/ %U")))

        org-agenda-hide-tags-regexp
        "."

        org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-12t% s")
          (todo   . " ")
          (tags   . " %i %-12:c")
          (search . " %i %-12:c")))

  :config
  (map! :leader "X" #'>org-capture-inbox)

  (defun >org-capture-inbox ()
    (interactive)
    (call-interactively 'org-store-link)
    (org-capture nil "i")))
#+end_src

**** org-ml

#+begin_src elisp :noweb-ref packages
(package! org-ml)
#+end_src

#+begin_src elisp :noweb-ref org-config
(use-package! org-ml)
#+end_src

**** Export
:PROPERTIES:
:header-args+: :noweb-ref org-config
:END:

#+begin_src elisp
(use-package! ox-latex)

(add-to-list 'org-latex-packages-alist '("" "minted"))
(setq org-latex-listings 'minted)
(setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+end_src

***** Environments
****** TODO export environment is possibly a bad name for this

Does it clashes semantically with actual org environment?

****** Machinary

#+begin_src elisp
(defvar >org-export-environments)

(defun >org-babel-exp-code-template (&optional environments)
  ;; TODO split the orig var instead of hard coding
  ;; TODO this doesn't work for things with a `-` in them
  (concat "#+begin_src %lang%switches%flags"
          " :part %part"
          ;; (mapconcat (lambda (attr)
          ;;              (format " :%s %%%s" attr attr))
          ;;            (map-keys environments))
          "\n%body\n#+end_src"))

(setq org-babel-exp-code-template (>org-babel-exp-code-template))

(defun >org-block-attr-value (block attr)
  (let* ((block-info (org-with-point-at (org-element-property :begin block)
                       (org-babel-get-src-block-info)))
         (attr-value-or-template (assoc-default (symbol->keyword attr) (elt block-info 2))))
    (unless (s-equals? attr-value-or-template (format "%%%s" attr))
      attr-value-or-template)))

(defun >org-export-environment-templates (org-block backend-key)
  (loopy
   (named outer)
   (map (environment-name . instances) >org-export-environments)

   (set block-instance-name (>org-block-attr-value org-block environment-name))
   (unless block-instance-name (skip))

   (loopy
    (map (instance . backends) instances)
    (at outer (when (s-equals? block-instance-name instance)
                (collect templates (map-elt backends backend-key)))))

   (finally-return templates)))

(defun >org-export-apply-templates (result templates)
  (if templates
      (map-let (before after) (car templates)
        (>org-export-apply-templates (concat before result after) (cdr templates)))
    result))

(defun >org-latex-src-block (old-func src-block _contents info)
  (let ((result (funcall old-func src-block _contents info))
        (templates (>org-export-environment-templates src-block 'latex)))
    (>org-export-apply-templates result templates)))

(advice-add 'org-latex-src-block :around #'>org-latex-src-block)

(defun >org-html-src-block (old-func src-block _contents info)
  (let ((result (funcall old-func src-block _contents info))
        (templates (>org-export-environment-templates src-block 'html)))
    (>org-export-apply-templates result templates)))

(advice-add 'org-html-src-block :around #'>org-html-src-block)

(defun >org-element-has-tag? (heading tag)
  (member tag (org-element-property :tags heading)))

(defun >org-export-process-backend (backend-block)
  (let ((backend (ht)))
    (org-element-map backend-block 'src-block
      (lambda (src-block)
        (let ((part (--> src-block
                         (org-ml-get-property :parameters it)
                         (map-elt it :part)))
              (value (--> src-block
                          (org-ml-get-property :value it)
                          (concat "\n" it "\n"))))
          (map-put! backend part value))))
    backend))

(defun >org-export-create-environments ()
  (let ((environments (ht)))
    (cl-flet ((name (element) (->> element
                                   (org-ml-get-property :raw-value)
                                   (string->symbol))))
      (org-element-map (org-element-parse-buffer) 'headline
        (lambda (environment)
          (when (>org-element-has-tag? environment "environment")
            (loopy
             (with (instances (ht))
                   (environment-name (name environment)))
             (list instance (org-ml-get-children environment))

             (loopy
              (with (backends (ht)))
              (list backend (org-ml-get-children instance))
              (do (map-put! backends (name backend) (>org-export-process-backend backend)))
              (after-do (map-put! instances (name instance) backends)))

             (after-do (map-put! environments environment-name instances))))))
      environments)))
#+end_src

***** Backends

#+begin_src elisp
(setq org-export-backends '(org md ascii html icalendar latex odt))
#+end_src

**** Tangling
:PROPERTIES:
:header-args+: :noweb-ref org-config
:END:

#+begin_src emacs-lisp
(defun >org-babel-find-tangled-file ()
  (interactive)
  (let ((file (--> (org-ml-parse-this-element)
                   (nth 1 it)
                   (map-elt it :parameters)
                   (org-babel-parse-header-arguments it)
                   (map-elt it :tangle))))
    (when (and file (not (equal "no" file)))
      (find-file file)
      t)))
;; (map! :leader "e" #'>org-babel-find-tangled-file)
#+end_src

***** Environment

#+name: environment-file-name
#+begin_src elisp :results pp :noweb-ref none
(buffer-file-name)
#+end_src

#+begin_src elisp
(defvar >environment-file-name <<environment-file-name()>>)
#+end_src

#+begin_src elisp
(defun >tangle-environment ()
  (interactive)
  (with-current-buffer (find-file-noselect >environment-file-name)
    (let ((org-babel-tangle-finished-hook '(>post-tangle-environment-hook)))
      (org-babel-tangle))))
#+end_src

#+begin_src elisp :noweb-ref org-post-tangle-environment-hook
(load-file "~/.doom.d/config.el")
#+end_src

#+begin_src elisp
(defun >post-tangle-environment-hook ()
  <<org-post-tangle-environment-hook>>)
#+end_src

****** TODO make tangling the env async

**** org-tempo
***** Templates
:PROPERTIES:
:header-args: :noweb-ref org-tempo-config
:END:

#+begin_src elisp
(tempo-define-template
 "src scheme expression"
 '(n
   "#+begin_src scheme" n
   p n
   "#+end_src")
 "<ss")

(tempo-define-template
 "src scheme definition"
 '(n
   "#+begin_src scheme :results none" n
   p n
   "#+end_src")
 "<ssd")
#+end_src

#+begin_src elisp
(tempo-define-template
 "src swift expression"
 '(n
   "#+begin_src swift" n
   p n
   "#+end_src")
 "<swift")
#+end_src

#+begin_src elisp
(tempo-define-template
 "src emacs lisp expression"
 '(n
   "#+begin_src elisp" n
   p n
   "#+end_src")
 "<emacs")
#+end_src

****** Doom

#+begin_src elisp
(tempo-define-template
 "Doom config src block"
 '(n
   "#+begin_src elisp :tangle ~/.doom.d/config.el" n
   p n
   "#+end_src")
 "<config")

(tempo-define-template
 "Doom packages src block"
 '(n
   "#+begin_src elisp :tangle ~/.doom.d/packages.el" n
   p n
   "#+end_src")
 "<packages")

(tempo-define-template
 "Doom init src block"
 '(n
   "#+begin_src elisp :tangle ~/.doom./init.el" n
   p n
   "#+end_src")
 "<init")
#+end_src

***** TODO investigate whether we can use search here to keep titles in the other doc from poluting this file
***** TODO investigate yas-snippet for this

***** Package

#+begin_src elisp :noweb-ref org-config
(use-package! org-tempo
  :config
  <<org-tempo-config>>)
#+end_src

**** COMMENT org-modern

#+begin_src elisp :noweb-ref packages
(package! org-modern)
#+end_src

#+begin_src elisp :noweb-ref org-config
(use-package! org-modern
  :config (global-org-modern-mode))
#+end_src

**** org-roam

#+begin_src elisp :noweb-ref org-config
(use-package! org-roam
  :init
  (setq
   org-roam-directory
   (concat org-directory "/roam")

   org-roam-node-display-template
   (s-join " " (list "${>hierarchy:100}"
                     (propertize "${doom-tags:20}" 'face 'org-tag)))

   org-roam-node-annotation-function
   (lambda (node) (marginalia--time (org-roam-node-file-mtime node))))

  :config
  (cl-defmethod org-roam-node->hierarchy ((node org-roam-node))
    "Return hierarchy for NODE, constructed of its file title, OLP and direct title.
If some elements are missing, they will be stripped out."
    (let ((title     (-> (org-roam-node-title node)
                         (propertize 'face '(consult-file italic))))
          (olp       (->> (org-roam-node-olp node)
                          (mapcar (fn (path)
                                    (propertize path 'face '(consult-key italic))))))
          (level     (org-roam-node-level node))
          (filetitle (-> (org-roam-node-doom-filetitle node)
                         (propertize 'face '(consult-bookmark italic))))
          (separator (propertize org-eldoc-breadcrumb-separator 'face 'consult-buffer)))
      (cl-case level
        ;; node is a top-level file
        (0 filetitle)
        ;; node is a level 1 heading
        (1 (concat filetitle
                   separator title))
        ;; node is a heading with an arbitrary outline path
        (t (concat filetitle
                   separator (s-join separator olp)
                   separator title)))))

  (defun >org-roam-capture-get-node-path ()
    (if (eq 0 (org-roam-node-level org-roam-capture--node))
        '()
      (append (org-roam-node-olp org-roam-capture--node)
              (list (org-roam-node-title org-roam-capture--node)))))

  (defadvice! >org-roam-capture-process-target (target)
    :filter-return #'org-roam-capture--get-target
    (pcase target
      (`(file+head+olp ,path ,head ,(and (pred symbol-function) olp-fn))
       (list 'file+head+olp path head (funcall olp-fn)))
      (_ target)))

  (defun >yequake-org-roam-capture-finalize-hook (&rest _)
    (remove-hook! 'org-capture-after-finalize-hook #'>yequake-org-roam-capture-finalize-hook)
    (vertico-buffer-mode -1)
    (vertico-posframe-mode)
    (yequake-retoggle))

  (defun yequake-org-roam-capture (&rest args)
    "Call `org-capture' in a Yequake frame.
Adds a function to `org-capture-after-finalize-hook' that closes
the recently toggled Yequake frame and removes itself from the
hook.

Note: if another Yequake frame is toggled before the capture is
finalized, when the capture is finalized, the wrong Yequake frame
will be toggled."
    (add-hook! 'org-capture-after-finalize-hook #'>yequake-org-roam-capture-finalize-hook)

    ;; MAYBE: Propose an `org-capture-switch-buffer-fn' variable that could be rebound here.

    ;; NOTE: We override `org-switch-to-buffer-other-window' because
    ;; it always uses `switch-to-buffer-other-window', and we want to
    ;; display the template menu and capture buffer in the existing
    ;; window rather than splitting the frame.
    (cl-letf* (((symbol-function #'org-switch-to-buffer-other-window)
                (symbol-function #'switch-to-buffer)))
      (condition-case nil
          (progn
            (vertico-buffer-mode)
            (vertico-posframe-mode -1)

            ;; TODO maximizing the minibuffer is a nice idea but I can't get it to work
            ;; (minibuffer-with-setup-hook
            ;;     (lambda ()
            ;;       ;; (other-window)
            ;;       ;; (maximize-window)
            ;;       ;; (+workspace/close-window-or-workspace)
            ;;       )
            ;;   (apply #'org-roam-capture args))

            (apply #'org-roam-capture args)
            ;; Be sure to return the "CAPTURE-" buffer, which is the current
            ;; buffer at this point.
            (current-buffer))
        ((error quit)
         (run-hooks 'org-capture-after-finalize-hook))))))
#+end_src

***** capture templates

#+name: org-roam-capture-default-template
#+begin_src org
,* title
:PROPERTIES:
:ID: %(org-id-new)
:END:
%?
#+end_src

#+begin_src elisp :noweb-ref org-config
(setq org-roam-capture-templates
      '(("d" "default" entry <<src-block-value(name="org-roam-capture-default-template")>>
         :target (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                "#+title: ${title}\n"
                                >org-roam-capture-get-node-path)
         :unnarrowed t)))
#+end_src

**** COMMENT org-ref

#+begin_src elisp :noweb-ref packages
(package! org-ref)
#+end_src

#+name: bibtex-completion-notes-template-multiple-files-template
#+begin_src org
,* ${author-or-editor}, ${title}, ${journal}, (${year}) :${=type=}:

See [[cite:&${=key=}]]
#+end_src

#+begin_src elisp :noweb-ref org-config
(use-package! org-ref
  :config
 (setq bibtex-completion-bibliography '("~/Dropbox/emacs/bibliography/references.bib"
                                        "~/Dropbox/emacs/bibliography/dei.bib"
                                        "~/Dropbox/emacs/bibliography/master.bib"
                                        "~/Dropbox/emacs/bibliography/archive.bib")
        bibtex-completion-library-path '("~/Dropbox/emacs/bibliography/bibtex-pdfs/")
        bibtex-completion-notes-path "~/Dropbox/emacs/bibliography/notes/"
        bibtex-completion-notes-template-multiple-files <<src-block-value(name="bibtex-completion-notes-template-multiple-files-template")>>

        bibtex-completion-additional-search-fields '(keywords)
        bibtex-completion-display-formats
        '((article . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${journal:40}")
          (inbook . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} Chapter ${chapter:32}")
          (incollection . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
          (inproceedings . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
          (t . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*}"))
        bibtex-completion-pdf-open-function
        (lambda (fpath)
          (call-process "open" nil 0 nil fpath))
        )

  (use-package! bibtex
    :config
    (setq bibtex-autokey-year-length 4
          bibtex-autokey-name-year-separator "-"
          bibtex-autokey-year-title-separator "-"
          bibtex-autokey-titleword-separator "-"
          bibtex-autokey-titlewords 2
          bibtex-autokey-titlewords-stretch 1
          bibtex-autokey-titleword-length 5)))

#+end_src

**** COMMENT doct based capture templates

#+begin_src elisp :noweb-ref packages
(package! doct)
#+end_src

#+begin_src elisp :noweb-ref org-config
(use-package! doct
  :init
  (setq org-capture-templates
        (doct '(("Parent" :keys "p"
                 :file "~/example.org"
                 :prepend t
                 :template ("* %^{Description}"
                            ":PROPERTIES:"
                            ":Created: %U"
                            ":END:"
                            "%?"))))))
#+end_src

**** Hide property drawers

#+begin_src elisp :noweb-ref org-config
(defun >org-hide-properties ()
  "Hide all org-mode headline property drawers in buffer. Could be slow if it has a lot of overlays."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward
            (rx line-start
                (* " ")
                (seq ":" (or "properties" "PROPERTIES") ":")
                "\n"
                (+ (or (minimal-match
                        (* " ")
                        ":"
                        (group "ROAM_REFS")
                        ":"
                        (group (* " ") (0+ not-newline))
                        "\n")
                       (minimal-match
                        (* " ")
                        ":"
                        (0+ not-newline)
                        ":"
                        (0+ not-newline)
                        "\n")))
                (* " ")
                (seq ":" (or "end" "END") ":"))
            nil t)
      (if (match-beginning 1)
          (progn
            (-doto (make-overlay (match-beginning 0) (match-beginning 1))
              (overlay-put 'display "")
              (overlay-put 'hidden-prop-drawer t))
            (-doto (make-overlay (match-end 1) (match-beginning 2))
              (overlay-put 'display "")
              (overlay-put 'hidden-prop-drawer t))
            (-doto (make-overlay (match-end 2) (match-end 0))
              (overlay-put 'display "")
              (overlay-put 'hidden-prop-drawer t)))
        (-doto (make-overlay (match-beginning 0) (1+ (match-end 0)))
              (overlay-put 'display "")
              (overlay-put 'hidden-prop-drawer t)))))
  (put 'org-toggle-properties-hide-state 'state 'hidden))

(defun >org-show-properties ()
  "Show all org-mode property drawers hidden by org-hide-properties."
  (interactive)
  (remove-overlays (point-min) (point-max) 'hidden-prop-drawer t)
  (put 'org-toggle-properties-hide-state 'state 'shown))

(defun >org-toggle-properties ()
  "Toggle visibility of property drawers."
  (interactive)
  (if (eq (get 'org-toggle-properties-hide-state 'state) 'hidden)
      (>org-show-properties)
    (>org-hide-properties)))

;; call org-hide-properties after inserting a new node
(add-hook 'org-roam-post-node-insert-hook (fn (&rest _) (>org-hide-properties)))
#+end_src

**** Snippets
:PROPERTIES:
:header-args+: :comments no
:END:

#+begin_src elisp :noweb-ref yasnippet-fixed-indent-modes
org-mode
#+end_src

#+begin_src snippet :tangle ~/.doom.d/snippets/org-mode/src-block-haskell
# name: Haskell src block
# key: <ha
# --
,#+begin_src haskell
$1 :: $3
$1 $2 = $0

main = do
  print \$ $1
,#+end_src
#+end_src

***** TODO this doesn't work with ~emacs -Q~

**** Package

#+begin_src elisp :noweb-ref doom-init-lang
(org +pomodoro
     +dragndrop
     +pandoc
     +roam2)
#+end_src

#+begin_src elisp :noweb-ref packages
(package! org-contrib)
#+end_src

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package! org
  :init
  <<org-init>>
  :config
  <<org-config>>)
#+end_src

*** COMMENT poly-mode

#+begin_src elisp :noweb-ref packages
(package! polymode)
(package! poly-org)
#+end_src

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package! poly-org)

(defun poly-org-eval-region (beg end msg)
  (pcase msg
   ("Eval chunk"
    (org-babel-execute-src-block-maybe))
   ("Eval region"
    (+eval/region beg end))))

(defun poly-org-mode-setup ()
  (setq-local polymode-eval-region-function #'poly-org-eval-region))
#+end_src

#+begin_src elisp
(prn 'evalling)
(prn 'other-evalling)
(+ 1 1)
(- 1 1)
#+end_src

#+begin_src elisp
(add-hook! org-mode #'poly-org-mode-setup)
#+end_src

*** OSA

#+begin_src elisp :noweb-ref packages
(package! osa)
#+end_src

#+begin_src elisp :noweb-ref doom-config
(use-package! osa
  :config

  (defun >plist->osa-record (plist)
    (cl-loop for (k v) on plist by #'cddr
             collect (cons (string-remove-prefix ":" (symbol-name k))
                           v)
             into ret
             finally return (cons :reco ret)))

  (defun >osa-parse-json (json-string)
    (json-parse-string json-string :object-type 'plist)))
#+end_src

**** Notifications

#+begin_src js :tangle ~/bin/osa/notify.js
function notify(msg, options)
{
    if (msg == null) {throw 'Argument "msg" is required';}

    let app  = Application.currentApplication();
    let args = {};

    app.includeStandardAdditions = true;

    if (typeof options === 'object' && options !== 'null') {
        if ('title' in options) {
            args['withTitle'] = options.title;
        }

        if ('subtitle' in options) {
            args['subtitle']  = options.subtitle;
        }

        if ('sound' in options) {
            args['soundName'] = options.sound;
        }
    }

    app.displayNotification(msg, args);
    return [msg, JSON.stringify(options)]

}
#+end_src

#+begin_src elisp :noweb-ref doom-config
(cl-defun >osa-notify (msg &rest rest &key title subtitle sound)
  (osa-eval-file "~/bin/osa/notify.js"
                 :lang "JavaScript"
                 :call "notify"
                 :args (list msg (>plist->osa-record rest))))
#+end_src

**** Safari

#+name: safari-get-url
#+begin_src js :cmd osascript -l JavaScript :results output replace
const tab = Application("Safari").documents[0];
JSON.stringify({
  "tab-url": tab.url(),
  "tab-title": tab.name()
});
#+end_src

#+begin_src elisp :noweb-ref doom-config
(defun >osa-safari-get-tab ()
  (pcase (->> (osa-eval <<src-block-value(name="safari-get-url")>> :lang "JavaScript")
              (>osa-parse-json))
    ((map (:tab-title "Untitled")
          (:tab-url :null))
     nil)
    (tab tab)))
#+end_src

*** Babashka

#+begin_src elisp :tangle ~/.doom.d/config.el
(defun >bb-tasks-for-project ()
  (interactive)
  (let* ((default-directory (projectile-project-root))
         (tasks-string (shell-command-to-string "bb tasks | tail -n +3 | cut -f1 -d ' '")))
    (s-split (rx (seq symbol-end
                      (not (syntax symbol))))
             tasks-string
             'omit-nulls)))

(defun >bb-task-sentinel (process event)
  (if (string-equal event "finished\n")
      (setq mode-name (propertize mode-name 'face 'mode-line-highlight))
    (setq mode-name (propertize mode-name 'face 'font-lock-warning-face))))

(defun >bb-task (task)
  (setq mode-name (propertize mode-name 'face 'font-lock-string-face))
  (let ((default-directory (projectile-project-root)))
    (set-process-sentinel
     (start-process-shell-command task task (format "bb %s" task))
     '>bb-task-sentinel)))

(defvar >bb-task-consult-items
  (list :name "BB Tasks"
        :action #'>bb-task
        :enabled #'projectile-project-root
        :items (lambda ()
                 (>bb-tasks-for-project))))

(defun >bb-run-task ()
  (interactive)
  (consult--multi '(>bb-task-consult-items)
                  :prompt "Run: "))

(map! :leader "cc" #'>bb-run-task)
#+end_src

*** Latex

#+begin_src elisp :tangle ~/.doom.d/config.el
(defun >bb-compile-latex ()
  (interactive)
  (>bb-task "compile"))

(defun >latex-mode-hook ()
  (add-hook 'after-save-hook #'>bb-compile-latex nil 'make-it-local))

(define-minor-mode >compile-latex-on-save-mode
  nil nil nil
  :global t
  (if >compile-latex-on-save-mode
      (add-hook! tex-mode #'>latex-mode-hook)
    (remove-hook! tex-mode #'>latex-mode-hook)))
#+end_src

*** Auto dim other buffers

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package! auto-dim-other-buffers)
#+end_src

*** Spelling

#+begin_src elisp :tangle ~/.doom.d/config.el
(setq ispell-dictionary "en"
      ispell-personal-dictionary "~/env/spelling/.pws")
#+end_src

*** general

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package! general)
#+end_src

*** Theme

#+begin_src elisp :tangle ~/.doom.d/config.el
(setq doom-theme 'doom-monokai-pro)

(custom-theme-set-faces! '(doom-monokai-pro)
  ;; `(doom-modeline-bar :background ,(doom-color 'black) :foreground ,(doom-color 'black))
  <<faces>>

  ;; `(mode-line :foreground ,(doom-color 'blue))
  ;; `(mode-line-buffer-id :foreground ,(doom-color 'fg) :background "#000000")
  ;; '(mode-line-success-highlight :background \"#00FF00\")
  ;; '(org-tag :background \"#4499FF\")
  ;; '(org-ellipsis :inherit org-tag)
  ;; '(which-key-docstring-face :inherit font-lock-comment-face)
  )

(load-theme 'doom-monokai-pro t)
#+end_src

*** evil
**** Symex

#+begin_src elisp :noweb-ref packages
(package! rigpa
  :recipe (:type git :host github :repo "countvajhula/rigpa"))
(package! symex
  :recipe (:type git :host github :repo "countvajhula/symex.el"
           :fork (:host github :protocol ssh :repo "dcostaras/symex.el")))
#+end_src

#+begin_src elisp :noweb-ref evil-config
(use-package! symex
  :hook ((clojure-mode clojurescript-mode clojurec-mode) . >symex-activation-hook)

  :general

  (:states '(normal)
   "<escape>" 'symex-mode-interface)

  (:states '(insert)
   "<escape>" 'evil-normal-state)

  (:states '(normal)
   "<enter>" 'symex-mode-interface)

  (:states '(symex)
   "<escape>" 'evil-normal-state)

  (:keymaps 'symex-editing-mode-map
   :states '(symex)
   ",p" 'lispy-ace-paren
   ",s" '>lispy-ace-symbol

   ;; Motion
   "h" 'symex-go-backward
   "j" 'symex-go-up
   "k" 'symex-go-down
   "l" 'symex-go-forward

   "0" 'symex-goto-first
   "M-h" 'symex-goto-first
   "$" 'symex-goto-last
   "M-l" 'symex-goto-last
   "M-j" 'symex-goto-highest
   "M-k" 'symex-goto-lowest

   "f" 'symex-traverse-forward
   "b" 'symex-traverse-backward
   "C-f" 'symex-traverse-forward-more
   "C-b" 'symex-traverse-backward-more
   "F" 'symex-traverse-forward-skip
   "B" 'symex-traverse-backward-skip

   "{" 'symex-leap-backward
   "}" 'symex-leap-forward
   "M-{" 'symex-soar-backward
   "M-}" 'symex-soar-forward
   "C-j" 'symex-climb-branch
   "C-k" 'symex-descend-branch

   "(" 'symex-create-round
   "[" 'symex-create-square
   ")" 'symex-wrap-round
   "]" 'symex-wrap-square
   "C-'" 'symex-cycle-quote
   "C-," 'symex-cycle-unquote
   "`" 'symex-add-quoting-level
   "C-`" 'symex-remove-quoting-level

   "y" 'symex-yank
   "Y" 'symex-yank-remaining
   "p" 'symex-paste-after
   "P" 'symex-paste-before

   "d" 'symex-delete
   "D" 'symex-delete-remaining
   "X" 'symex-delete-backwards

   "c" 'symex-change
   "C" 'symex-change-remaining
   "C--" 'symex-clear
   "s" 'symex-replace
   "S" 'symex-change-delimiter
   "H" 'symex-shift-backward
   "L" 'symex-shift-forward
   "M-H" 'symex-shift-backward-most
   "M-L" 'symex-shift-forward-most
   "K" 'paredit-raise-sexp

   ;; Capture
   "C-h" 'symex-capture-backward
   "C-l" 'symex-capture-forward
   "C-S-h" 'symex-emit-backward
   "C-S-l" 'symex-emit-forward

   "z" 'symex-swallow
   "Z" 'symex-swallow-tail

   ;; Evaluation
   ;; "e" 'symex-evaluate
   "e" 'symex-evaluate-definition
   "E" 'symex-evaluate-remaining
   "C-M-e" 'symex-evaluate-pretty
   "M-e" 'symex-eval-recursive
   "T" 'symex-evaluate-thunk
   "R" 'symex-repl
   ;; "r" 'symex-run

   ;; Testing
   "t" 'cider-test-run-test
   "r" 'cider-test-rerun-failed-tests

   ":" 'evil-ex

   ;; "t" 'symex-switch-to-scratch-buffer
   "M" 'symex-switch-to-messages-buffer
   "|" 'symex-split
   "&" 'symex-join
   "-" 'symex-splice
   "o" 'symex-open-line-after
   "O" 'symex-open-line-before
   ">" 'symex-insert-newline
   "<" 'symex-join-lines-backwards
   "C->" 'symex-append-newline
   "C-<" 'symex-join-lines
   "C-S-o" 'symex-append-newline
   "J" 'symex-join-lines
   "M-J" 'symex-collapse
   "M-<" 'symex-collapse
   "M->" 'symex-unfurl
   "C-M-<" 'symex-collapse-remaining
   "C-M->" 'symex-unfurl-remaining

   "=" 'symex-tidy
   "<tab>" 'symex-tidy
   "C-=" 'symex-tidy-remaining
   "C-<tab>" 'symex-tidy-remaining
   "M-=" 'symex-tidy-proper
   "M-<tab>" 'symex-tidy-proper
   "A" 'symex-append-after
   "a" 'symex-insert-at-end
   "i" 'symex-insert-at-beginning
   "I" 'symex-insert-before
   "w" 'symex-wrap
   "W" 'symex-wrap-and-append
   "C-d" 'symex--evil-scroll-down

   ;; Commenting
   "_" 'symex-clojure-comment-reader-macro
   "M-_" 'symex-clojure-comment-remaining-reader-macro
   ";" 'symex-comment
   "M-;" 'symex-comment-remaining

   "C-;" 'symex-eval-print
   "s-;" 'symex-evaluate
   "H-h" 'symex--toggle-highlight
   "C-?" 'symex-describe
   "<return>" 'symex-enter-lower
   "<escape>" 'symex-escape-higher)

  :config

  (add-hook! 'doom-escape-hook
    (defun >symex->normal-state-doom-escape-hook ()
      (when (evil-symex-state-p)
        (progn
          (evil-normal-state)
          t))))

  (defun >symex-activation-hook ()
    (symex-mode-interface))

  (defun >lispy-ace-symbol (arg)
    "Jump to a symbol within the current sexp and mark it.
Sexp is obtained by exiting the list ARG times."
    (interactive "p")
    (message "%s" arg)
    (symex-go-down 1)
    (let ((avy-keys lispy-avy-keys)
          res)
      (avy-with lispy-ace-symbol
        (let ((avy--overlay-offset (if (eq lispy-avy-style-symbol 'at) -1 0)))
          (setq res (lispy--avy-do
                     "[([{ ]\\(?:\\sw\\|\\s_\\|[\"'`#~,@]\\)"
                     (lispy--bounds-dwim)
                     (lambda ()
                       (not (save-excursion
                              (forward-char -1)
                              (lispy--in-string-or-comment-p))))
                     lispy-avy-style-symbol))))))

  (defun >symex-initialize ()
    "Initialize symex mode.
This registers symex mode for use in all recognized Lisp modes, and also
advises functions to enable or disable features based on user configuration."
    ;; enable the symex minor mode in all recognized lisp modes
    (dolist (mode-name symex-lisp-modes)
      (let ((mode-hook (intern (concat (symbol-name mode-name)
                                       "-hook"))))
        (add-hook mode-hook 'symex-mode)))
    ;; advise functions to enable or disable configured features
    (when symex-remember-branch-positions-p
      (advice-add #'symex-go-down :around #'symex--remember-branch-position)
      (advice-add #'symex-go-up :around #'symex--return-to-branch-position)
      (advice-add #'symex-go-backward :around #'symex--forget-branch-positions)
      (advice-add #'symex-go-forward :around #'symex--forget-branch-positions))
    (symex--add-selection-advice))

  (>symex-initialize))
#+end_src

**** evil-ex-define-cmd-local

#+begin_src elisp :noweb-ref evil-config
(use-package! evil-ex)

(defun >evil-ex-define-local-cmd (cmd function)
  "Locally binds the function FUNCTION to the command CMD."
  (unless (local-variable-p 'evil-ex-commands)
    (setq-local evil-ex-commands (copy-alist evil-ex-commands)))
  (evil-ex-define-cmd cmd function))
#+end_src

**** Recenter buffer after evil motions

#+begin_src elisp :noweb-ref evil-config
(defun >evil-recenter (&optional count symbol)
  (recenter nil))

;; Evil
(advice-add 'evil-ex-search-word-forward :after #'>evil-recenter)
(advice-add 'evil-ex-search-next :after #'>evil-recenter)
(advice-add 'evil-goto-mark-line :after #'>evil-recenter)

;; Info
(advice-add 'Info-follow-nearest-node :after #'>evil-recenter)
#+end_src

**** key-chord

#+begin_src elisp :noweb-ref evil-config
(use-package key-chord
  :config (key-chord-mode 1))
#+end_src

**** Hydra paste

#+begin_src elisp :noweb-ref evil-config
(defhydra hydra-paste
  (:color red
   :hint nil)
  "\n[%s(length kill-ring-yank-pointer)/%s(length kill-ring)] \
 [_C-j_/_C-k_] cycles through yanked text, [_p_/_P_] pastes the same text \
 above or below. Anything else exits."
  ("C-j" evil-paste-pop)
  ("C-k" evil-paste-pop-next)
  ("p" evil-paste-after)
  ("P" evil-paste-before))

(map! :nv "p" #'hydra-paste/evil-paste-after
      :nv "P" #'hydra-paste/evil-paste-before)
#+end_src

**** Evil escape

#+begin_src elisp :noweb-ref evil-config
(use-package! evil-escape
  :disabled t
  :init (progn
          (setq evil-escape-key-sequence "jk")
          (setq evil-escape-unordered-key-sequence t)))
#+end_src

**** Motion trainer

#+begin_src elisp :noweb-ref evil-config
;; (global-evil-motion-trainer-mode 1)
(setq evil-motion-trainer-threshold 6)
#+end_src

**** evil-goggles

#+begin_src elisp :noweb-ref packages
(package! evil-goggles)
#+end_src

#+begin_src elisp :noweb-ref evil-config
(use-package! evil-goggles
  :config
  (setq evil-goggles-duration 0.2
        evil-goggles-async-duration 0.2
        evil-goggles-blocking-duration 0.2
        evil-goggles-pulse t
        evil-goggles-enable-delete t
        evil-goggles-enable-change t))
#+end_src

#+begin_src elisp :noweb-ref faces
`(evil-goggles-yank-face :background ,(doom-color 'green))
`(evil-goggles-paste-face :background ,(doom-color 'violet))
`(evil-goggles-delete-face :background ,(doom-color 'red))
#+end_src

**** State indicators

#+begin_src elisp :noweb-ref evil-config
(setq >evil-symex-state-colour (doom-color 'orange))
(setq >evil-normal-state-colour (doom-color 'green))
(setq >evil-insert-state-colour (doom-color 'violet))
(setq >evil-visual-state-colour (doom-color 'yellow))
(setq >evil-motion-state-colour (doom-color 'red))
(setq >evil-replace-state-colour (doom-color 'orange))
(setq >evil-operator-state-colour (doom-color 'blue))

(setq evil-symex-state-cursor (list >evil-symex-state-colour 'box))
(setq evil-normal-state-cursor (list >evil-normal-state-colour 'box))
(setq evil-insert-state-cursor (list >evil-insert-state-colour 'bar))
(setq evil-visual-state-cursor (list >evil-visual-state-colour 'hollow))
(setq evil-motion-state-cursor (list >evil-motion-state-colour 'box))
(setq evil-replace-state-cursor (list >evil-replace-state-colour 'hbar))
(setq evil-operator-state-cursor (list >evil-operator-state-colour #'evil-half-cursor))

(defun >evil-state-string->colour (state-string)
  (concat ">evil-" state-string "-state-colour"))

(defun >evil-states-entry-hook ()
  (let ((colour (-> evil-state
                    symbol->string
                    >evil-state-string->colour
                    string->symbol
                    symbol-value)))
    (custom-set-faces!
      (list 'line-number :foreground colour :slant 'normal)
      (list 'line-number-current-line :foreground "black" :background colour))))

(add-hook!
 '(evil-symex-state-entry-hook
   evil-normal-state-entry-hook
   evil-insert-state-entry-hook
   evil-visual-state-entry-hook
   evil-motion-state-entry-hook
   evil-replace-state-entry-hook
   evil-operator-state-entry-hook)
 #'>evil-states-entry-hook)
#+end_src

**** Package

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package! evil
  :config
  <<evil-config>>)
#+end_src

*** doom-modeline

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package! doom-modeline
  :config
  (setq doom-modeline-modal-icon t)
  (setq doom-modeline-bar-width 3)
  (setq doom-modeline-persp-name t)

  (doom-modeline-def-modeline 'main
    '(bar
      window-number
      matches
      buffer-info
      remote-host
      buffer-position
      word-count
      selection-info)
    '(persp-name
      battery
      grip
      irc
      mu4e
      gnus
      github
      debug
      repl
      lsp
      minor-modes
      input-method
      indent-info
      buffer-encoding
      major-mode
      process
      vcs
      checker))

  (defun doom-modeline-update-persp-name (&rest _)
    "Update perspective name in mode-line."
    (setq doom-modeline--persp-name
          ;; Support `persp-mode', while not support `perspective'
          (when (and doom-modeline-persp-name
                     (bound-and-true-p persp-mode)
                     (fboundp 'safe-persp-name)
                     (fboundp 'get-current-persp))
            (let* ((persp (get-current-persp))
                   (name (safe-persp-name persp))
                   (face (if (and persp
                                  (not (persp-contain-buffer-p (current-buffer) persp)))
                             'doom-modeline-persp-buffer-not-in-persp
                           'doom-modeline-persp-name)))
              (when (or doom-modeline-display-default-persp-name
                        (not (string-equal persp-nil-name name)))
                (propertize (propertize name 'face face))))))))
#+end_src

*** Rigpa

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package rigpa
  :disabled t

  :after (evil
          symex
          )

  :config
  (setq rigpa-mode t)

  ;; temporary workaround for https://github.com/countvajhula/rigpa/issues/9
  (remove-hook 'evil-symex-state-exit-hook #'symex-disable-editing-minor-mode)

  ;; custom config
  (setq rigpa-show-menus nil)

  ;; navigating meta modes
  (global-unset-key (kbd "s-m"))
  (global-set-key (kbd "s-m s-m") 'rigpa-flashback-to-last-tower)
  (global-set-key (kbd "C-<escape>")
                  (lambda ()
                    (interactive)
                    (when (eq rigpa--complex rigpa-meta-complex)
                      (rigpa-exit-mode-mode))
                    (rigpa-enter-tower-mode)))
  (global-set-key (kbd "M-<escape>") 'rigpa-enter-mode-mode)
  (global-set-key (kbd "s-<escape>") 'rigpa-enter-mode-mode)
  (global-set-key (kbd "M-<return>")
                  (lambda ()
                    (interactive)
                    (when (eq rigpa--complex rigpa-meta-complex)
                      (rigpa-enter-selected-level)
                      (let ((ground (rigpa--get-ground-buffer)))
                        (rigpa-exit-mode-mode)
                        (switch-to-buffer ground)))))
  (global-set-key (kbd "s-<return>")
                  (lambda ()
                    (interactive)
                    (when (eq rigpa--complex rigpa-meta-complex)
                      (rigpa-enter-selected-level)
                      (let ((ground (rigpa--get-ground-buffer)))
                        (rigpa-exit-mode-mode)
                        (switch-to-buffer ground)))))
  (global-set-key (kbd "C-<return>")
                  (lambda ()
                    (interactive)
                    (when (eq rigpa--complex rigpa-meta-tower-complex)
                      (rigpa-exit-tower-mode)
                      (rigpa-enter-mode-mode))))

  ;; indexed entry to various modes
  (global-set-key (kbd "s-n") 'evil-normal-state)
  (global-set-key (kbd "s-y")           ; symex mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "symex")))
  (global-set-key (kbd "s-;") (kbd "s-y"))
  (global-set-key (kbd "s-w")           ; window mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "window")))
  (global-set-key (kbd "s-v")           ; view mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "view")))
  (global-set-key (kbd "s-x")           ; char mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "char")))
  (global-set-key (kbd "s-a")           ; activity mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "activity")))
  (global-set-key (kbd "s-z")           ; text mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "text")))
  (global-set-key (kbd "s-g")           ; history mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "history")))
  (global-set-key (kbd "s-i")           ; system mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "system")))
  (global-set-key (kbd "s-b")           ; buffer mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "buffer")))
  (global-set-key (kbd "s-f")           ; file mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "file")))
  (global-set-key (kbd "s-t")           ; tab mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "tab")))
  (global-set-key (kbd "s-l")           ; line mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "line")))
  (global-set-key (kbd "s-e")           ; application mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "application")))
  (global-set-key (kbd "s-r")           ; word mode
                  (lambda ()
                    (interactive)
                    (rigpa-enter-mode "word"))))
#+end_src

*** vertico

#+begin_src elisp :tangle ~/.doom.d/config.el
(after! vertico
  (map! :map vertico-map
        "C-h" #'vertico-directory-delete-char
        "C-l" #'vertico-insert))
#+end_src

**** COMMENT ivy

#+begin_src elisp
(after! ivy

  (setq ivy-extra-directories '())

  ;; (map! :n "/" #'+default/search-buffer)

  (defun ivy-yank-action (x)
    (kill-new x))

  (defun ivy-copy-to-buffer-action (x)
    (with-ivy-window
      (insert x)))

  ;; Ivy actions only working when called from C-M-o (ivy-dispatching-call)
  (ivy-set-actions
   t
   '(("i" ivy-copy-to-buffer-action "insert")
     ("y" ivy-yank-action "yank"))))
#+end_src
**** TODO Support shifting the posframe around when needed

(setq vertico-posframe-poshandler #'posframe-poshandler-frame-top-center)

*** Corfu

#+begin_src elisp :tangle ~/.doom.d/packages.el
(package! corfu :recipe (:files ("*.el" "extensions/*.el")))
(package! cape)
(package! dabbrev)
(when (modulep! :os tty)
  (package! corfu-terminal))
(when (modulep! +icons)
  (package! kind-icon))
(when (modulep! +orderless)
  (package! orderless))
(package! corfu-doc-terminal
  :recipe (:type git :repo "https://codeberg.org/akib/emacs-corfu-doc-terminal.git"))
#+end_src

#+begin_src elisp :tangle ~/.doom.d/config.el
(defvar +corfu-auto-delay 0.3
   "How long after point stands still will completion be called automatically,
 in seconds.

 Setting `corfu-auto-delay' directly may not work, as it needs to be set *before*
 enabling `corfu-mode'.")
 (defvar +corfu-auto-prefix 2
   "How many characters should be typed before auto-complete starts to kick in.

 Setting `corfu-auto-prefix' directly may not work, as it needs to be set
 ,*before* enabling `corfu-mode'.")
 (defvar +corfu-want-multi-component t
   "Enables multiple component search, with pieces separated by spaces.

 This allows search of non-contiguous unordered bits, for instance by typing
 \"tear rip\" to match \"rip-and-tear\". Notice the space, it does not break
 completion in this case.")
 (defvar +corfu-icon-height 0.9
   "The height applied to the icons (it is passed to both svg-lib and kind-icon).

 It may need tweaking for the completions to not become cropped at the end.
 Note that changes are applied only after a cache reset, via
 `kind-icon-reset-cache'.")

 (defvar +corfu-ispell-completion-modes '(org-mode markdown-mode text-mode)
   "Modes to enable ispell completion in.

 For completion in comments, see `+corfu-ispell-in-comments-and-strings'.")
 (defvar +corfu-ispell-in-comments-and-strings t
   "Enable completion with ispell inside comments when in a `prog-mode'
 derivative.")

 ;;
 ;;; Packages
 (use-package! corfu
   :hook (doom-first-buffer . global-corfu-mode)
   :init
   ;; Auto-completion settings, must be set before calling `global-corfu-mode'.
   (setq corfu-auto nil
         corfu-auto-delay +corfu-auto-delay
         corfu-auto-prefix +corfu-auto-prefix
         corfu-excluded-modes '(erc-mode
                                circe-mode
                                help-mode
                                gud-mode
                                vterm-mode))

   :config
   (when (and (modulep! :tools lsp) (not (modulep! :tools lsp +eglot)))
     (add-hook 'lsp-mode-hook (defun doom--add-lsp-capf ()
                                (add-to-list 'completion-at-point-functions (cape-capf-buster #'lsp-completion-at-point)))
               ;; Below is so that context specific completions in cape come first.
               :depth 1))
   (add-to-list 'completion-styles 'partial-completion t)
   (add-to-list 'completion-styles 'initials t)
   (setq corfu-cycle t
         corfu-separator (when +corfu-want-multi-component ?\s)
         corfu-preselect t
         corfu-count 16
         corfu-max-width 120
         corfu-preview-current 'insert
         corfu-quit-at-boundary (if +corfu-want-multi-component 'separator t)
         corfu-quit-no-match (if +corfu-want-multi-component 'separator t)
         ;; In the case of +tng, TAB should be smart regarding completion;
         ;; However, it should otherwise behave like normal, whatever normal was.
         tab-always-indent (if (modulep! +tng) 'complete tab-always-indent))
   ;; Only done with :tools vertico active due to orderless. Alternatively, we
   ;; could set it up here if it's not there.
   (when (and +corfu-want-multi-component (modulep! :completion vertico))
     (cond ((modulep! :tools lsp +eglot) (add-to-list 'completion-category-overrides '(eglot (styles orderless))))
           ((modulep! :tools lsp) (add-hook 'lsp-completion-mode-hook
                                            (defun doom--use-orderless-lsp-capf ()
                                              (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
                                                    '(orderless)))))))
   (map! (:unless (modulep! +tng)
           :desc "complete" "C-SPC" #'completion-at-point)
         (:map 'corfu-map
               (:when +corfu-want-multi-component
                 :desc "insert separator" "C-SPC" #'corfu-insert-separator)
               (:when (modulep! :completion vertico)
                 :desc "move to minibuffer" "s-<down>" #'corfu-move-to-minibuffer
                 (:when (modulep! :editor evil)
                   :desc "move to minibuffer" "s-j" #'corfu-move-to-minibuffer))
               (:when (modulep! +tng)
                 :desc "next" [tab] #'corfu-next
                 :desc "previous" [backtab] #'corfu-previous
                 :desc "next" "TAB" #'corfu-next
                 :desc "previous" "S-TAB" #'corfu-previous))))

 ;; Taken from corfu's README.
 ;; TODO: extend this to other completion front-ends, mainly helm and ido, since
 ;; ivy is being considered for removal.
 (when (modulep! :completion vertico)
   (defun corfu-move-to-minibuffer ()
     (interactive)
     (let ((completion-extra-properties corfu--extra)
           completion-cycle-threshold completion-cycling)
       (apply #'consult-completion-in-region completion-in-region--data))))

 (use-package! cape
   :after corfu
   :commands (cape-dabbrev
              cape-file
              cape-history
              cape-keyword
              cape-tex
              cape-sgml
              cape-rfc1345
              cape-abbrev
              cape-ispell
              cape-dict
              cape-symbol
              cape-line)
   :init
   (add-to-list 'completion-at-point-functions #'cape-file)
   (when +corfu-ispell-in-comments-and-strings
     (defalias 'corfu--ispell-in-comments-and-strings
       (cape-super-capf (cape-capf-inside-comment #'cape-ispell)
                        (cape-capf-inside-string #'cape-ispell)))
     (add-hook 'prog-mode-hook
               (lambda ()
                 (add-to-list 'completion-at-point-functions #'corfu--ispell-in-comments-and-strings))))
   (dolist (sym +corfu-ispell-completion-modes)
     (add-hook (intern (concat (symbol-name sym) "-hook"))
               (lambda ()
                 (add-to-list 'completion-at-point-functions #'cape-ispell))))
   (add-hook! '(TeX-mode-hook LaTeX-mode-hook org-mode-hook)
     (lambda ()
       (add-to-list 'completion-at-point-functions #'cape-tex t))
     :depth 2)
   (add-hook! '(html-mode-hook +web-react-mode-hook typescript-tsx-mode-hook org-mode-hook markdown-mode-hook)
     (lambda ()
       (add-to-list 'completion-at-point-functions #'cape-sgml t))
     :depth 2)
   (add-to-list 'completion-at-point-functions #'cape-dabbrev)
   (add-to-list 'completion-at-point-functions #'cape-keyword)
   :config
   ;; Enhances speed on large projects, for which many buffers may be open.
   (setq cape-dabbrev-check-other-buffers nil))

 (use-package! kind-icon
   :when (modulep! +icons)
   :commands kind-icon-margin-formatter
   :init
   (add-hook 'corfu-margin-formatters #'kind-icon-margin-formatter)
   :config
   (setq kind-icon-default-face 'corfu-default
         kind-icon-blend-background t
         kind-icon-blend-frac 0.2)
   (plist-put kind-icon-default-style :height +corfu-icon-height)
   (plist-put svg-lib-style-default :height +corfu-icon-height))

 (use-package! corfu-terminal
   :when (and (modulep! :os tty) (not (display-graphic-p)))
   :hook (corfu-mode . corfu-terminal-mode))

 (use-package! dabbrev
   :config
   (setq dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))

 (setq read-extended-command-predicate
       #'command-completion-default-include-p)

 ;;
 ;;; Extensions
 (use-package! corfu-history
   :after savehist
   :hook (corfu-mode . corfu-history-mode)
   :config
   (add-to-list 'savehist-additional-variables 'corfu-history))
 (use-package! corfu-popupinfo
   :hook (corfu-mode . corfu-popupinfo-mode)
   :config
   (setq corfu-popupinfo-delay '(0.5 . 1.0))
   (map! (:map 'corfu-map
          :desc "scroll info up" "C-<up>" #'corfu-popupinfo-scroll-down
          :desc "scroll info down" "C-<down>" #'corfu-popupinfo-scroll-up
          :desc "scroll info up" "C-S-p" #'corfu-popupinfo-scroll-down
          :desc "scroll info down" "C-S-n" #'corfu-popupinfo-scroll-up
          :desc "toggle info" "C-h" #'corfu-popupinfo-toggle)
         (:map 'corfu-popupinfo-map
          :when (modulep! :editor evil)
          ;; Reversed because popupinfo assumes opposite of what feels intuitive
          ;; with evil.
          :desc "scroll info up" "C-S-k" #'corfu-popupinfo-scroll-down
          :desc "scroll info down" "C-S-j" #'corfu-popupinfo-scroll-up)))


;; (use-package! corfu
;;   :custom
;;   (corfu-separator ?\s)
;;   (corfu-auto t)
;;   (corfu-auto-delay 0.1)
;;   (corfu-auto-prefix 3)
;;   (corfu-preview-current nil) ;; Disable current candidate preview
;;   (corfu-on-exact-match nil)
;;   (corfu-quit-no-match 'separator)
;;   (corfu-cycle t)
;;   (completion-cycle-threshold 1)
;;   (tab-always-indent 'complete)
;;   (corfu-max-width 80)
;;   (corfu-preselect-first t)
;;   ;; :hook
;;   ;; (doom-first-buffer . global-corfu-mode)
;;   :init
;;   (global-corfu-mode)
;;   :config
;;   (when (modulep! +minibuffer)
;;     (add-hook 'minibuffer-setup-hook #'+corfu--enable-in-minibuffer))

;;   ;; Reset lsp-completion provider
;;   (add-hook 'doom-init-modules-hook
;;             (lambda ()
;;               (after! lsp-mode
;;                 (setq lsp-completion-provider :none))))

;;   ;; Set orderless filtering for LSP-mode completions
;;   ;; TODO: expose a Doom variable to control this part
;;   (add-hook 'lsp-completion-mode-hook
;;             (lambda ()
;;               (setf (alist-get 'lsp-capf completion-category-defaults) '((styles . (orderless flex))))))

;;   (map! :map corfu-map
;;         "C-SPC" #'corfu-insert-separator
;;         "C-n" #'corfu-next
;;         "C-p" #'corfu-previous
;;         (:prefix "C-x"
;;                  "C-k" #'cape-dict
;;                  "s" #'cape-ispell
;;                  "C-n" #'cape-keyword
;;                  "C-f" #'cape-file))
;;   (after! evil
;;     (advice-add 'corfu--setup :after 'evil-normalize-keymaps)
;;     (advice-add 'corfu--teardown :after 'evil-normalize-keymaps)
;;     (evil-make-overriding-map corfu-map))

;;   (defadvice! +corfu--org-return (orig) :around '+org/return
;;     (if (and (modulep! :completion corfu)
;;              corfu-mode
;;              (>= corfu--index 0))
;;         (corfu-insert)
;;       (funcall orig))))

;; (use-package! corfu-doc
;;   :hook (corfu-mode . corfu-doc-mode)
;;   :custom
;;   (corfu-doc-delay 0)
;;   :bind (:map corfu-map
;;               ("M-n" . corfu-doc-scroll-down)
;;               ("M-p" . corfu-doc-scroll-up)
;;               ("M-d" . corfu-doc-toggle)))

;; (use-package orderless
;;   :init
;;   (setq completion-styles '(orderless basic)
;;         completion-category-defaults nil
;;         completion-category-overrides '((file (styles . (partial-completion)))))
;;   ;; Tune the global completion style settings to your liking!
;;   ;; This affects the minibuffer and non-lsp completion at point.
;;   ;; (setq completion-styles '(orderless partial-completion basic)
;;   ;;       completion-category-defaults nil
;;   ;;       completion-category-overrides nil)
;;   )

;; (use-package lsp-mode
;;   :init
;;   (when (modulep! :completion corfu)
;;     (setq lsp-completion-provider :none)
;;     (add-hook 'lsp-mode-hook #'lsp-completion-mode))

;;   ;; (lsp-completion-provider :none) ;; we use Corfu!

;;   ;; :init
;;   ;; (defun my/orderless-dispatch-flex-first (_pattern index _total)
;;   ;;   (and (eq index 0) 'orderless-flex))

;;   ;; (defun my/lsp-mode-setup-completion ()
;;   ;;   (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
;;   ;;         '(orderless)))

;;   ;; ;; Optionally configure the first word as flex filtered.
;;   ;; (add-hook 'orderless-style-dispatchers #'my/orderless-dispatch-flex-first nil 'local)

;;   ;; ;; Optionally configure the cape-capf-buster.
;;   ;; (setq-local completion-at-point-functions (list (cape-capf-buster #'lsp-completion-at-point)))

;;   ;; :hook
;;   ;; (lsp-completion-mode . my/lsp-mode-setup-completion)
;;   )

;; (use-package! kind-icon
;;   :after corfu
;;   :when (modulep! +icons)
;;   :custom
;;   (kind-icon-default-face 'corfu-default)
;;   :config
;;   (setq kind-icon-use-icons t
;;         svg-lib-icons-dir (expand-file-name "svg-lib" doom-cache-dir)
;;         kind-icon-mapping
;;         '((array "a" :icon "code-brackets" :face font-lock-variable-name-face)
;;           (boolean "b" :icon "circle-half-full" :face font-lock-builtin-face)
;;           (class "c" :icon "view-grid-plus-outline" :face font-lock-type-face)
;;           (color "#" :icon "palette" :face success)
;;           (constant "co" :icon "pause-circle" :face font-lock-constant-face)
;;           (constructor "cn" :icon "table-column-plus-after" :face font-lock-function-name-face)
;;           (enum "e" :icon "format-list-bulleted-square" :face font-lock-builtin-face)
;;           (enum-member "em" :icon "format-list-checks" :face font-lock-builtin-face)
;;           (event "ev" :icon "lightning-bolt-outline" :face font-lock-warning-face)
;;           (field "fd" :icon "application-braces-outline" :face font-lock-variable-name-face)
;;           (file "f" :icon "file" :face font-lock-string-face)
;;           (folder "d" :icon "folder" :face font-lock-doc-face)
;;           (function "f" :icon "sigma" :face font-lock-function-name-face)
;;           (interface "if" :icon "video-input-component" :face font-lock-type-face)
;;           (keyword "kw" :icon "image-filter-center-focus" :face font-lock-keyword-face)
;;           (macro "mc" :icon "lambda" :face font-lock-keyword-face)
;;           (method "m" :icon "sigma" :face font-lock-function-name-face)
;;           (module "{" :icon "view-module" :face font-lock-preprocessor-face)
;;           (numeric "nu" :icon "numeric" :face font-lock-builtin-face)
;;           (operator "op" :icon "plus-circle-outline" :face font-lock-comment-delimiter-face)
;;           (param "pa" :icon "cog" :face default)
;;           (property "pr" :icon "tune-vertical" :face font-lock-variable-name-face)
;;           (reference "rf" :icon "bookmark-box-multiple" :face font-lock-variable-name-face)
;;           (snippet "S" :icon "text-short" :face font-lock-string-face)
;;           (string "s" :icon "sticker-text-outline" :face font-lock-string-face)
;;           (struct "%" :icon "code-braces" :face font-lock-variable-name-face)
;;           (t "." :icon "crosshairs-question" :face shadow)
;;           (text "tx" :icon "script-text-outline" :face shadow)
;;           (type-parameter "tp" :icon "format-list-bulleted-type" :face font-lock-type-face)
;;           (unit "u" :icon "ruler-square" :face shadow)
;;           (value "v" :icon "numeric-1-box-multiple-outline" :face font-lock-builtin-face)
;;           (variable "va" :icon "adjust" :face font-lock-variable-name-face)))
;;   (add-hook 'doom-load-theme-hook #'kind-icon-reset-cache)
;;   (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))


;; (use-package! cape
;;   :defer t
;;   :init
;;   (map!
;;    [remap dabbrev-expand] 'cape-dabbrev)
;;   (add-hook! 'latex-mode-hook (defun +corfu--latex-set-capfs ()
;;                                 (add-to-list 'completion-at-point-functions #'cape-tex)))
;;   (when (modulep! :checkers spell)
;;     (add-to-list 'completion-at-point-functions #'cape-dict)
;;     (add-to-list 'completion-at-point-functions #'cape-ispell))
;;   (add-to-list 'completion-at-point-functions #'cape-file)
;;   (add-to-list 'completion-at-point-functions #'cape-keyword t)
;;   (add-to-list 'completion-at-point-functions #'cape-dabbrev t))


;; (use-package! corfu-history
;;   :after corfu
;;   :hook (corfu-mode . (lambda ()
;;                         (corfu-history-mode 1)
;;                         (savehist-mode 1)
;;                         (add-to-list 'savehist-additional-variables 'corfu-history))))

;; (use-package! corfu-quick
;;   :after corfu
;;   :bind (:map corfu-map
;;               ("M-q" . corfu-quick-complete)
;;               ("C-q" . corfu-quick-insert)))

;; (when (modulep! :editor evil +everywhere)
;;   (setq evil-collection-corfu-key-themes '(default magic-return)))

;; ;; (setq company-search-regexp-function #'company-search-words-in-any-order-regexp)
;; ;; (setq company-frontends '(company-pseudo-tooltip-frontend company-echo-metadata-frontend company-preview-frontend))

;; ;; Configure Tempel
;; (use-package tempel
;;   ;; Require trigger prefix before template name when completing.
;;   ;; :custom
;;   ;; (tempel-trigger-prefix "<")

;;   :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
;;          ("M-*" . tempel-insert)
;;          )

;;   :init

;;   ;; Setup completion at point
;;   (defun tempel-setup-capf ()
;;     ;; Add the Tempel Capf to `completion-at-point-functions'.
;;     ;; `tempel-expand' only triggers on exact matches. Alternatively use
;;     ;; `tempel-complete' if you want to see all matches, but then you
;;     ;; should also configure `tempel-trigger-prefix', such that Tempel
;;     ;; does not trigger too often when you don't expect it. NOTE: We add
;;     ;; `tempel-expand' *before* the main programming mode Capf, such
;;     ;; that it will be tried first.
;;     (setq-local completion-at-point-functions
;;                 (cons #'tempel-expand
;;                       completion-at-point-functions)))

;;   (add-hook 'prog-mode-hook 'tempel-setup-capf)
;;   (add-hook 'text-mode-hook 'tempel-setup-capf)

;;   ;; Optionally make the Tempel templates available to Abbrev,
;;   ;; either locally or globally. `expand-abbrev' is bound to C-x '.
;;   ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
;;   ;; (global-tempel-abbrev-mode)
;;   )
;; (use-package tempel-clojure)



#+end_src

**** Templates

#+begin_src elisp :tangle ~/.config/emacs/.local/cache/templates

fundamental-mode ;; Available everywhere

(today (format-time-string "%Y-%m-%d"))

prog-mode

(fixme (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "FIXME ")
(todo (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "TODO ")
(bug (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "BUG ")
(hack (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "HACK ")

latex-mode

(begin "\\begin{" (s env) "}" r> n> "\\end{" (s env) "}")
(frac "\\frac{" p "}{" q "}")
(enumerate "\\begin{enumerate}\n\\item " r> n> "\\end{enumerate}")
(itemize "\\begin{itemize}\n\\item " r> n> "\\end{itemize}")

lisp-mode emacs-lisp-mode ;; Specify multiple modes

(lambda "(lambda (" p ")" n> r> ")")

emacs-lisp-mode

(autoload ";;;###autoload")
(pt "(point)")
(lambda "(lambda (" p ")" n> r> ")")
(var "(defvar " p "\n  \"" p "\")")
(local "(defvar-local " p "\n  \"" p "\")")
(const "(defconst " p "\n  \"" p "\")")
(custom "(defcustom " p "\n  \"" p "\"" n> ":type '" p ")")
(face "(defface " p " '((t :inherit " p "))\n  \"" p "\")")
(group "(defgroup " p " nil\n  \"" p "\"" n> ":group '" p n> ":prefix \"" p "-\")")
(macro "(defmacro " p " (" p ")\n  \"" p "\"" n> r> ")")
(alias "(defalias '" p " '" p ")")
(fun "(defun " p " (" p ")\n  \"" p "\"" n> r> ")")
(iflet "(if-let (" p ")" n> r> ")")
(whenlet "(when-let (" p ")" n> r> ")")
(iflet* "(if-let* (" p ")" n> r> ")")
(whenlet* "(when-let* (" p ")" n> r> ")")
(andlet* "(and-let* (" p ")" n> r> ")")
(cond "(cond" n "(" q "))" >)
(pcase "(pcase " (p "scrutinee") n "(" q "))" >)
(let "(let (" p ")" n> r> ")")
(let* "(let* (" p ")" n> r> ")")
(rec "(letrec (" p ")" n> r> ")")
(dotimes "(dotimes (" p ")" n> r> ")")
(dolist "(dolist (" p ")" n> r> ")")
(loop "(cl-loop for " p " in " p " do" n> r> ")")
(command "(defun " p " (" p ")\n  \"" p "\"" n> "(interactive" p ")" n> r> ")")
(advice "(defun " (p "adv" name) " (&rest app)" n> p n> "(apply app))" n>
        "(advice-add #'" (p "fun") " " (p ":around") " #'" (s name) ")")
(provide "(provide '" (file-name-base (or (buffer-file-name) (buffer-name))) ")" n
         ";;; " (file-name-nondirectory (or (buffer-file-name) (buffer-name))) " ends here" n)

eshell-mode

(for "for " (p "i") " in " p " { " q " }")
(while "while { " p " } { " q " }")
(until "until { " p " } { " q " }")
(if "if { " p " } { " q " }")
(ife "if { " p " } { " p " } { " q " }")
(unl "unless { " p " } { " q " }")
(unle "unless { " p " } { " p " } { " q " }")

text-mode

(cut "--8<---------------cut here---------------start------------->8---" n r n
     "--8<---------------cut here---------------end--------------->8---" n)
(asciibox "+-" (make-string (length str) ?-) "-+" n
          "| " (s str)                       " |" n
          "+-" (make-string (length str) ?-) "-+" n)
(rot13 (p "plain text" text) n "----" n (rot13 text))
(calc (p "taylor(sin(x),x=0,3)" formula) n "----" n (format "%s" (calc-eval formula)))

rst-mode

(title (make-string (length title) ?=) n (p "Title: " title) n (make-string (length title) ?=) n)

java-mode

(class "public class " (p (file-name-base (or (buffer-file-name) (buffer-name)))) " {" n> r> n "}")

c-mode :when (re-search-backward "^\\S-*$" (line-beginning-position) 'noerror)

(inc "#include <" (p (concat (file-name-base (or (buffer-file-name) (buffer-name))) ".h")) ">")
(incc "#include \"" (p (concat (file-name-base (or (buffer-file-name) (buffer-name))) ".h")) "\"")

org-mode

(title "#+title: " p n "#+author: Daniel Mendler" n "#+language: en" n n)
(quote "#+begin_quote" n> r> n> "#+end_quote")
(example "#+begin_example" n> r> n> "#+end_example")
(center "#+begin_center" n> r> n> "#+end_center")
(comment "#+begin_comment" n> r> n> "#+end_comment")
(verse "#+begin_verse" n> r> n> "#+end_verse")
(src "#+begin_src " p n> r> n> "#+end_src" :post (org-edit-src-code))
(elisp "#+begin_src elisp" n> r> n "#+end_src" :post (org-edit-src-code))

;; Local Variables:
;; mode: lisp-data
;; outline-regexp: "[a-z]"
;; End:

#+end_src

*** dired

#+begin_src elisp :tangle ~/.doom.d/packages.el
(package! dired+
  :recipe (:type git :host github :repo "emacsmirror/dired-plus"))
#+end_src

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package dired+)
#+end_src

**** git-annex for dired

#+begin_src elisp :noweb-ref packages
(package! git-annex)
#+end_src

#+begin_src elisp :noweb-ref doom-config
(use-package! git-annex
  :after (dired diredfl)
  :config

  ;; (git-annex-dired-do-to-files "lock" "Annex: locked %d file(s)")
  ;; (git-annex-dired-do-to-files "unlock" "Annex: unlocked %d file(s)")
  ;; (define-key git-annex-dired-map "l" 'git-annex-dired-lock-files)
  ;; (define-key git-annex-dired-map "u" 'git-annex-dired-unlock-files)
  ;; (define-key git-annex-dired-map "t" 'jmm/dired-git-annex-tag)
  ;; (bind-keys :map git-annex-dired-map
  ;;            ("*")
  ;;            ("* u" . jmm/dired-mark-git-annex-unavailable-files))
  ;; git-annex.el kinda clobbers dired-marked-face and dired-flagged-face

  (add-to-list 'diredfl-font-lock-keywords-1
               (list " -> .*\\.git/annex/"
                     '("\\(.+\\)\\( -> .+\\)" (dired-move-to-filename) nil
                       (1 git-annex-dired-annexed-unavailable)
                       (2 git-annex-dired-annexed-invisible))))
  (add-to-list 'diredfl-font-lock-keywords-1
               (list 'git-annex-lookup-file
                     '("\\(.+\\)\\( -> .+\\)" (dired-move-to-filename) nil
                       (1 git-annex-dired-annexed-available)
                       (2 git-annex-dired-annexed-invisible)))))
#+end_src

#+begin_src elisp :noweb-ref faces
`(git-annex-dired-annexed-unavailable :foreground ,(doom-color 'red))
`(git-annex-dired-annexed-available :foreground ,(doom-color 'green))
#+end_src

*** Aggressive indent

Can turn this on once I've worked to fix at least the multiple undo points
#+begin_src elisp :tangle ~/.doom.d/config.el
;; (use-package! aggressive-indent
;;   :config (add-hook! emacs-lisp-mode
;;             (aggressive-indent-mode 1)))
#+end_src

*** back-button

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package! back-button
  :config (back-button-mode 1))
#+end_src

*** yequake

#+begin_src elisp :noweb-ref packages
(package! yequake)
#+end_src

#+begin_src elisp :noweb-ref doom-config :noweb-prefix no
(use-package! yequake
  :config
  (setq yequake-frames '(<<yequake-frames>>))
  <<yequake-config>>)
#+end_src

**** Emacs command launcher

#+begin_src emacs-lisp :noweb-ref yequake-config
(progn

  (setq >items '("foo"
                 "bar"))

  (defun >builder (input)
    (pcase-let ((`(,arg . ,_) (consult--command-split input)))
      (cons (list "commands")
            (cdr (consult--default-regexp-compiler arg 'basic t)))))

  (defun >formatter (lines)
    lines)

  (defun >consult (&optional initial)
    (interactive)
    ;; (consult--read
    ;;     (consult--async-command #'consult--man-builder
    ;;       (consult--async-transform consult--man-format)
    ;;       (consult--async-highlight #'consult--man-builder))
    ;;     :prompt "Manual entry: "
    ;;     :require-match t
    ;;     :category 'consult-man
    ;;     :lookup (apply-partially #'consult--lookup-prop 'consult-man)
    ;;     :initial (consult--async-split-initial initial)
    ;;     :add-history (consult--async-split-thingatpt 'symbol)
    ;;     :history '(:input consult--man-history))
    (when-let ((search-result (consult--read
                               ;; (consult--outline-candidates)
                               >items
                               ;; (consult--async-command #'>builder
                               ;;   (consult--async-transform >formatter)
                               ;;   (consult--async-highlight #'>builder))
                               ;; :prompt "Dash: "
                               ;; :require-match t
                               ;; :group #'consult-dash--group
                               ;; :lookup #'consult--lookup-cdr
                               ;; :category 'consult-dash-result
                               ;; :annotate #'consult-dash--annotate
                               ;; :initial (consult--async-split-initial initial)
                               ;; :add-history (consult--async-split-thingatpt 'symbol)
                               ;; :history '(:input consult-dash--history)
                               )))))

  (nconc yequake-frames
        '(("org-capture"
           (buffer-fns . (
                          ;; posframe--fn

                          ;; yequake-test
                          ;; mx--fn
                          >consult))
           ;; (buffer-fns . (miniframe--fn))
           ;; (buffer-fns . (mx--fn))
           ;; (buffer-fns . (consult--fn))
           (width . 0.75)
           (height . 0.5)
           (alpha . 0.95)
           (frame-parameters . ((undecorated . t)
                                (skip-taskbar . t)
                                (sticky . t)
                                (minibuffer . only)
                                )))))

  (defun >make-frame ()
    (let ((frame (make-frame '(;; (minibuffer . only)
                               ;; (minibuffer-exit . t)
                               (undecorated . t)
                               (skip-taskbar . t)
                               (sticky . t)))))
      (select-frame-set-input-focus frame)
      (>consult)))

  (defun >custom-frame-test ()
    (interactive)
    (>make-frame))

  (defun >yequake-test ()
    (interactive)
    (yequake-toggle "org-capture")))

(comment
 (map! :leader "e" #'>custom-frame-test)
 (map! :leader "e" #'>yequake-test)
 (map! :leader "e" #'>consult)
 )
#+end_src

*** magit

"a git porcelain for Emacs"

#+begin_src elisp :noweb-ref doom-init-tools
magit
#+end_src

#+begin_src elisp :noweb-ref packages
;; (package! magit-delta)
#+end_src

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package! magit
  :init
  (setq auth-sources '("~/.authinfo"))

  :config

  (use-package! magit-todos-mode
    :disabled t
    :after magit
    :config (magit-todos-mode))

  (use-package! magit-delta
    :disabled t
    :after magit
    :config
    (setq magit-delta-default-dark-theme "OneHalfDark"
          magit-delta-default-light-theme "OneHalfLight")
    (magit-delta-mode))

  <<magit-config>>)
#+end_src

**** magit-annex

#+begin_src elisp :noweb-ref packages
(package! magit-annex)
#+end_src

#+begin_src elisp :noweb-ref magit-config
(use-package! magit-annex)
#+end_src

*** LSP

#+begin_src elisp :tangle ~/.doom.d/config.el
(after! lsp-mode
  (after! lsp-ui-mode
    (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
    (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references))
  (setq lsp-ui-doc-enable nil)
  (setq lsp-ui-doc-show-with-cursor nil)
  (setq lsp-ui-doc-show-with-mouse nil)
  (setq lsp-ui-sideline-show-code-actions nil)
  (setq lsp-ui-peek-always-show t)
  (setq lsp-ui-sideline-show-hover t))
#+end_src

*** Workspaces

"tab emulation, persistence & separate workspaces"

#+begin_src elisp :noweb-ref doom-ui
workspaces
#+end_src

**** persp-mode
:PROPERTIES:
:header-args+: :noweb-ref persp-mode-config
:END:

persp-mode functionality is disabled by Doom for buffers that Doom considers 'unreal'. This allows us to make certain buffers 'real'.
#+begin_src elisp
(defun >real-buffer-p (buffer)
  (or
   <<real-buffer>>))

(push #'>real-buffer-p doom-real-buffer-functions)
#+end_src

***** Package

#+begin_src elisp :noweb-ref doom-config
(use-package! persp-mode
  :config
  <<persp-mode-config>>)
#+end_src

***** TODO COMMENT persp-mode configs to check out

#+begin_src elisp
(with-eval-after-load "persp-mode-autoload"
  (with-eval-after-load "dired"
    (persp-def-auto-persp "dired"
                          :parameters '((dont-save-to-file . t))
                          :mode 'dired-mode
                          :dyn-env '(after-switch-to-buffer-functions ;; prevent recursion
                                     (persp-add-buffer-on-find-file nil)
                                     persp-add-buffer-on-after-change-major-mode)
                          :hooks '(after-switch-to-buffer-functions)
                          :switch 'window)))

(defun my/roam-buffer (_buffer state)
  (let ((name (buffer-file-name)))
    (when (and name (s-contains-p "/org-roam/" name))
      (if (null state)
          't
        state))))

(with-eval-after-load 'org-roam
  ;; (setq org-roam-db-location (expand-file-name "~/.org-roam.sqlite"))
  (persp-def-auto-persp "org-roam"
                        :parameters '((dont-save-to-file . t))
                        :predicate 'my/roam-buffer
                        :dyn-env '(after-switch-to-buffer-functions ;; prevent recursion
                                   (persp-add-buffer-on-find-file nil)
                                   persp-add-buffer-on-after-change-major-mode)
                        :hooks '(after-switch-to-buffer-functions)
                        :switch 'frame))
#+end_src

*** YASnippet

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package! yasnippet
  :hook ((<<yasnippet-fixed-indent-modes>>) . >yasnippet-fixed-indent-for-modes-hook)

  :config

  (defun >yasnippet-fixed-indent-for-modes-hook ()
    (setq-local yas-indent-line 'fixed))

  ;; TODO this doesn't work when tangling with ~-Q~
  (defun >tangle-dir (sub-path)
    "Expand the SUB-PATH into the directory given by the tangle-dir
property if that property exists, else use the
`default-directory'."
    (expand-file-name sub-path
                      (or (org-entry-get (point) "tangle-dir" 'inherit)
                          (default-directory)))))
#+end_src

#+begin_src elisp :noweb-ref org-post-tangle-environment-hook
(yas-recompile-all)
(yas-reload-all t)
#+end_src

**** TODO could I turn this into a new header?
Something like:

:tangle-rel test

...instead of

:tangle (>tangle-dir "test")

*** EmacsLisp

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package! emacs-lisp-mode
  :defer t
  :general
  (:mode 'emacs-lisp-mode
         "C-c C-c" #'eval-defun
         "C-c C-k" #'+eval/buffer))
#+end_src

**** Snippets
:PROPERTIES:
:header-args+: :comments no
:END:

#+begin_src snippet :tangle ~/.doom.d/snippets/emacs-lisp/test
# name: test
# key: test
# --
a test snippet
#+end_src

*** Scheme/Racket

#+begin_src elisp :tangle ~/.doom.d/packages.el
(package! racket-mode)
(package! ob-racket
  :recipe (:type git :host github :repo "hasu/emacs-ob-racket"
           :files ("*.el" "*.rkt")))
(package! sicp)
#+end_src

#+begin_src elisp :tangle ~/.doom.d/config.el
(use-package! racket-mode
  :general
  (:keymaps 'racket-mode-map
   "C-c C-c" #'racket-send-definition)

  :config
  (use-package! geiser
    :config
    (setq geiser-default-implementation 'racket)))
#+end_src

**** Unused non-racket config

#+begin_src elisp
(defun mit-scheme ()
  (interactive)
  (run-scheme "/Applications/scheme.app/Contents/Resources/mit-scheme"))

(defvar-local prev-scheme-file nil)

(defun >scheme-load-file ()
  "Load `buffer-file-name' into current inferior Scheme process
and switch to REPL"
  (interactive)
  (evil-normal-state) ;; comment line if not using evil mode
  (save-buffer)
  (comint-send-string (scheme-proc) (concat "(load \""
                                           (buffer-file-name)
                                           "\")\n"))
  (switch-to-scheme-interp))

(add-hook 'scheme-mode-hook (lambda ()
                              (local-set-key (kbd "C-h C-j")
                                             '>scheme-load-file)))

(defun switch-to-scheme-interp ()
  (let ((initial-buffer (current-buffer)))
    (switch-to-buffer-other-window "*scheme*")
      (setq prev-scheme-file initial-buffer)))

(defun switch-to-scheme-file ()
  (interactive)
  (if prev-scheme-file
      (switch-to-buffer-other-window prev-scheme-file)
    (message "No previous buffer.")))

(add-hook 'inferior-scheme-mode-hook
          (lambda () (local-set-key (kbd "C-h C-j")
                                    'switch-to-scheme-file)))
#+end_src

*** Clojure
:PROPERTIES:
:header-args+: :noweb-ref clojure
:END:

#+begin_src elisp :noweb-ref no :tangle ~/.doom.d/config.el
(use-package! cider
  :config
  <<clojure>>)
#+end_src

**** Settings

#+begin_src elisp
(setq cider-clojure-cli-global-options "-A:debug-tools")
(setq cider-shadow-cljs-global-options "-A:debug-tools")
(setq cider-save-file-on-load t)
(setq clojure-toplevel-inside-comment-form t)
(setq org-babel-clojure-backend 'cider)
(setq lsp-lens-enable t)
(setq lsp-enable-symbol-highlighting t)

(defun cider-buffer-p (buffer)
  (string-match-p "^\\*cider-" (buffer-name buffer)))

(push #'cider-buffer-p doom-real-buffer-functions)

(advice-add 'cider-pprint-eval-last-sexp :around 'evil-collection-cider-last-sexp)

(add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
(add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion)
#+end_src

**** cider-interactive-eval-clj

#+begin_src elisp
(defun cider-interactive-eval-clj (form &optional callback bounds additional-params)
  "Evaluate FORM and dispatch the response to CALLBACK.
If the code to be evaluated comes from a buffer, it is preferred to use a
nil FORM, and specify the code via the BOUNDS argument instead.

This function is the main entry point in CIDER's interactive evaluation
API.  Most other interactive eval functions should rely on this function.
If CALLBACK is nil use `cider-interactive-eval-handler'.
BOUNDS, if non-nil, is a list of two numbers marking the start and end
positions of FORM in its buffer.
ADDITIONAL-PARAMS is a map to be merged into the request message.

If `cider-interactive-eval-override' is a function, call it with the same
arguments and only proceed with evaluation if it returns nil."
  (let ((form  (or form (apply #'buffer-substring-no-properties bounds)))
        (start (car-safe bounds))
        (end   (car-safe (cdr-safe bounds))))
    (when (and start end)
      (remove-overlays start end 'cider-temporary t))
    (unless (and cider-interactive-eval-override
                 (functionp cider-interactive-eval-override)
                 (funcall cider-interactive-eval-override form callback bounds))
      (cider-map-repls :clj
        (lambda (connection)
          (cider--prep-interactive-eval form connection)
          (cider-nrepl-request:eval
           form
           (or callback (cider-interactive-eval-handler nil bounds))
           ;; always eval ns forms in the user namespace
           ;; otherwise trying to eval ns form for the first time will produce an error
           (if (cider-ns-form-p form) "user" (cider-current-ns))
           (when start (line-number-at-pos start))
           (when start (cider-column-number-at-pos start))
           (seq-mapcat #'identity additional-params)
           connection))))))
#+end_src

**** Mode hooks

#+begin_src elisp
(defun >define-clojure-mode-hooks (hook-function)
  (message "bar")
  (add-hook!
   '(clojure-mode-hook
     clojurec-mode-hook
     clojurescript-mode-hook)
   hook-function))
#+end_src

**** COMMENT >clojure-def-and-name-regex

#+begin_src elisp :tangle ~/.doom.d/config.el
;; Not used
;; (defconst >clojure-def-and-name-regex
;;   (rx
;;    (seq bol
;;         (* blank) "(" (* blank)
;;         (group
;;          (or
;;           "specification"
;;           (and "def" (* (syntax word))))))))
#+end_src

**** Font lock

#+begin_src elisp
(rx-define >clojure-defining-macro-forms
  (or (seq ">def" (optional "n"))
      "defsc"
      "defmutation"
      "defrouter"
      "defresolver"
      "defstyled"
      "defpage"
      "deffragment"))

(defun >defining-forms-font-lock ()
  (font-lock-add-keywords
   nil
   `((,(rx "("
           (* (syntax whitespace))
           (group >clojure-defining-macro-forms)
           (+ (syntax whitespace))
           (group (+ (or (syntax word) (syntax symbol)))))
      (1 font-lock-keyword-face)
      (2 font-lock-function-name-face)))))

(>define-clojure-mode-hooks #'>defining-forms-font-lock)
#+end_src

**** Aggressive indent

#+begin_src elisp
(after! aggressive-indent
  (add-hook! clojure-mode
    (aggressive-indent-mode 1)))
#+end_src

**** cider report mode

#+begin_src elisp
(defhydra >cider-report-hydra ()
  "zoom"
  ("g" text-scale-increase "in")
  ("l" text-scale-decrease "out"))

(general-define-key
 :states 'normal
 :keymaps 'cider-popup-buffer-mode-map
 "q" 'cider-popup-buffer-quit)
 #+end_src

**** COMMENT Eval commands
Three ways to eval a string:

Evals in environment but doesn't print
#+begin_src elisp
(cider-nrepl-sync-request:eval "(form)")
#+end_src

Evals in environment and prints
#+begin_src elisp
(cider-interactive-eval-clj "(form)")
#+end_src

Inserts literal form into repl and eval (second arg is `t`)
#+begin_src elisp
(cider-insert-in-repl "(form)" t)
#+end_src

#+name: cider-load-debug-tools
#+begin_src clojure
(require '[com.gfredericks.debug-repl :refer [break! unbreak! unbreak!!]])
(require '[hashp.core])
(use 'hyperfiddle.rcf)

(hyperfiddle.rcf/enable!)
#+end_src

#+begin_src elisp :noweb-prefix no :tangle ~/.doom.d/config.el
(defun >cider-reset ()
  (interactive)
  (projectile-save-project-buffers)
  (cider-interactive-eval-clj "(do (in-ns 'user) (restart-system))"))

(defun >cider-reset-all ()
  (interactive)
  (projectile-save-project-buffers)
  (cider-interactive-eval-clj "(do (in-ns 'user) (restart-all-system))"))

(setq >cider-repl-name-rx (rx (seq bol "*cider-repl " (1+ not-newline) "*")))

(defun >kill-cider-repls ()
  (interactive)
  (kill-matching-buffers >cider-repl-name-rx nil t))

(defun >cider-load-reveal-tap-log ()
  (interactive)
  (cider-interactive-eval
   (format "%s" '((requiring-resolve 'vlaaad.reveal/tap-log)))))

(defun >cider-clear-reveal ()
  (interactive)
  (cider-interactive-eval
   (format "%s" '(do (require 'vlaaad.reveal)
                     (vlaaad.reveal/submit-command! (vlaaad.reveal/clear-output))))))

(defun >cider-start-system ()
  (interactive)
  (>kill-cider-repls)
  (cider-connect-clj)
  (cider-insert-in-repl "(start-system)" t)
  (cider-connect-sibling-clj '())
  (cider-repl-switch-to-other)
  (cider-insert-in-repl "(start-client)" t)
  (>cider-load-reveal-tap-log))

(defmacro >cider-interactive-eval (&rest body)
  `(cider-interactive-eval ,(format "%s" `(do ,@body))))

(defun >cider-load-debug-tools ()
  (interactive)
  (>cider-interactive-eval <<cider-load-debug-tools>>))

(map! (:localleader
       (:map (clojure-mode-map clojurescript-mode-map clojurec-mode-map)
             (:prefix ("r" . "repl")
                      "r" #'>cider-reset
                      "R" #'>cider-reset-all
                      "s" #'>cider-start-system
                      "t" #'>cider-load-reveal-tap-log
                      "c" #'>cider-clear-reveal))))
#+end_src

**** Indentation

#+begin_src elisp
(define-clojure-indent
 ;; Fulcro
 (>defn :defn)
 (defmutation [1 :form :form [1]])
 ;; (pc/defmutation [2 :form :form [1]])

 ;; Fulcro-spec
 (specification [1])
 (component [1])
 (behavior [1])
 (when-mocking '(0))
 (assertions [0])

 (thrown-with-data? [1])
 (not-thrown-with-data? [1])

 ;; Datomic
 (not-join 1)

 ;; JRA
 (system/let [1])
 (clet [1])
 (sp/collected? 1)
 (sp/cond-path :defn)
 (sp/if-path :defn)
 (sp/recursive-path :defn)
 (load-marker-utils/capture-load-marker-states 1)

 (swap!-> [1])

 (comment :defn)

 (m/search 1)

 ;; compojure
 (context 2)
 (POST 2)
 (GET 2)
 (PUT 2))
#+end_src

**** Testing

#+begin_src elisp
(defvar kaocha-windows-rx (rx bol (* any) "kaocha" (* any)))

(setq display-buffer-alist '((kaocha-windows-rx (display-buffer-pop-up-frame display-buffer-reuse-window display-buffer-same-window))))

(setq cider-test-defining-forms '("deftest" "defspec" "specification"))

(defun tdd-test ()
  "Thin wrapper around `cider-test-run-tests'."
  (when (cider-connected-p)
    (let ((cider-auto-select-test-report-buffer nil)
          (cider-test-show-report-on-success nil))
      (cider-test-run-ns-tests nil 'soft))))

(defun >kaocha-runner--show-details-window (original-buffer min-height)
  "Show details from the test run with a MIN-HEIGHT, but switch back to ORIGINAL-BUFFER afterwards."
  (let ((window (get-buffer-window kaocha-runner--out-buffer t)))
    (when (not window)
      (let ((window (split-window-vertically -4)))
        (select-window window)
        (switch-to-buffer kaocha-runner--out-buffer)
        (set-window-dedicated-p window t)))))

(defun >kaocha-runner--run-tests (testable-sym &optional run-all? background? original-buffer)
  "Run kaocha tests.

If RUN-ALL? is t, all tests are run, otherwise attempt a run with the provided
TESTABLEY-SYM. In practice TESTABLEY-SYM can be a test id, an ns or an ns/test-fn.

If BACKGROUND? is t, we don't message when the tests start running.

Given an ORIGINAL-BUFFER, use that instead of (current-buffer) when switching back."
  (interactive)
  (kaocha-runner--clear-buffer kaocha-runner--out-buffer)
  (kaocha-runner--clear-buffer kaocha-runner--err-buffer)
  (message "%s" (format kaocha-runner-repl-invocation-template
           (if run-all?
               (format "(kaocha.repl/run-all %s)" kaocha-runner-extra-configuration)
             (format
              "(kaocha.repl/run %s %s)"
              testable-sym
              kaocha-runner-extra-configuration))))
  (kaocha-runner--eval-clojure-code
   (format kaocha-runner-repl-invocation-template
           (if run-all?
               (format "(kaocha.repl/run-all %s)" kaocha-runner-extra-configuration)
             (format
              "(kaocha.repl/run %s %s)"
              testable-sym
              kaocha-runner-extra-configuration)))
   (let ((original-buffer (or original-buffer (current-buffer)))
         (done? nil)
         (any-errors? nil)
         (shown-details? nil)
         (the-value nil)
         (start-time (float-time)))
     (unless background?
       (if run-all?
           (message "Running all tests ...")
         (message "[%s] Running tests ..." testable-sym)))
     (lambda (response)
       (nrepl-dbind-response response (value out err status)
         (when out
           (kaocha-runner--insert kaocha-runner--out-buffer out)
           (when (let ((case-fold-search nil))
                   (string-match-p kaocha-runner--fail-re out))
             (setq any-errors? t))
           (when (and (< kaocha-runner-long-running-seconds
                         (- (float-time) start-time))
                      (not shown-details?))
             (setq shown-details? t)
             (kaocha-runner--show-details-window original-buffer kaocha-runner-ongoing-tests-win-min-height)))
         (when err
           (kaocha-runner--insert kaocha-runner--err-buffer err))
         (when value
           (setq the-value value))
         (when (and status (member "done" status))
           (setq done? t))
         (when done?
           (if the-value
               (kaocha-runner--show-report the-value (unless run-all? testable-sym))
             (unless (get-buffer-window kaocha-runner--err-buffer 'visible)
               (message "Kaocha run failed. See error window for details.")
               (switch-to-buffer-other-window kaocha-runner--err-buffer))))
         (when done?
           (if any-errors?
               (>kaocha-runner--show-details-window original-buffer kaocha-runner-failure-win-min-height))))))))

(defvar >test-runner 'kaocha)

(defun >execute-test (ns test-var code-buffer)
  (cond ((eq >test-runner 'kaocha)
         (>kaocha-runner--run-tests
          (kaocha-runner--testable-sym ns test-var (eq major-mode 'clojurescript-mode))
          nil
          t
          code-buffer))
        ((eq >test-runner 'cider)
         (progn
           (cider-test-update-last-test ns (list test-var))
           (cider-test-execute ns (list test-var))))))

(defvar >last-executed-test nil)

(defun >run-test ()
  "Run Clojure test at point.

Supports the fulcro-spec `specification' macro"
  (interactive)
  (let* ((ns  (clojure-find-ns))
         (code-buffer (current-buffer)))
    (when ns
      (cider-interactive-eval
       (concat "(clojure.core/let [{:keys [name test]} (clojure.core/meta "
               (cider-defun-at-point)
               ")] (clojure.core/when test name))")
       (nrepl-make-response-handler
        code-buffer
        (lambda (_buffer test-var)
          (message "%s" ns)
          (if (not (string= "nil" test-var))
              (progn
                (setq >last-executed-test (list ns test-var))
                (>execute-test ns test-var code-buffer))
            (when >last-executed-test
              (>execute-test
               (car >last-executed-test)
               (cadr >last-executed-test)
               code-buffer))))
        nil
        nil
        (lambda (_buffer)))))))

(define-minor-mode tdd-mode
  "Run all tests whenever a file is loaded."
  nil nil nil
  :global t
  (if tdd-mode
      (progn
        (advice-add 'cider-eval-defun-at-point :after #'>run-test)
        (add-hook 'cider-file-loaded-hook #'tdd-test))
    (progn
      (advice-remove 'cider-eval-defun-at-point #'>run-test)
      (remove-hook 'cider-file-loaded-hook #'tdd-test))))

(use-package kaocha-runner
  :init
  (bind-keys :prefix-map ar-emacs-kaocha-prefix-map
             :prefix "C-c k"
             ("t" . kaocha-runner-run-test-at-point)
             ("r" . kaocha-runner-run-tests)
             ("a" . kaocha-runner-run-all-tests)
             ("w" . kaocha-runner-show-warnings)
             ("h" . kaocha-runner-hide-windows)))
#+end_src

**** Minor modes
***** pprint-eval-mode

#+begin_src elisp
(define-minor-mode pprint-eval-mode
  "When active swaps `cider-eval-defun-at-point' with `cider-pprint-eval-defun-at-point'"
  nil nil nil
  :global t
  (if pprint-eval-mode
      (map! :mode (clojure-mode clojurec-mode clojurescript-mode)
            [remap cider-eval-defun-at-point] #'cider-pprint-eval-defun-at-point
            [remap cider-eval-last-sexp] #'cider-pprint-eval-last-sexp)
    (map! :mode (clojure-mode clojurec-mode clojurescript-mode)
          [remap cider-pprint-eval-defun-at-point] #'cider-eval-defun-at-point
          [remap cider-pprint-eval-last-sexp] #'cider-eval-last-sexp)))
#+end_src

***** clear-reveal-eval-mode

#+begin_src elisp
(defun >clear-reveal-and-eval ()
  (interactive)
  (>cider-clear-reveal)
  (eval-top-level-form-and-reload-tilley))

(define-minor-mode clear-reveal-eval-mode
  nil nil nil
  :global t
  (if clear-reveal-eval-mode
      (map! :mode (clojure-mode clojurec-mode clojurescript-mode)
            [remap eval-top-level-form-and-reload-tilley] #'>clear-reveal-and-eval)
    (map! :mode (clojure-mode clojurec-mode clojurescript-mode)
          [remap >clear-reveal-and-eval] #'eval-top-level-form-and-reload-tilley)))
#+end_src

***** reload-tilley-mode

#+begin_src elisp
(defun eval-top-level-form-and-reload-tilley ()
  (interactive)
  (cider-eval-defun-at-point)
  (cider-interactive-eval-clj "(do (in-ns 'user) (refresh-pages-after-eval!))"))

(defun load-buffer-and-reload-tilley ()
  (interactive)
  (cider-load-buffer)
  (cider-interactive-eval-clj "(do (in-ns 'user) (refresh-pages-after-eval!))"))

(map! (:mode cider-mode
             "C-c C-c" #'cider-eval-defun-at-point
             "C-c C-k" #'cider-load-buffer))

(define-minor-mode reload-tilley-on-eval-mode
  nil nil nil
  :global t
  (if reload-tilley-on-eval-mode
      (map! :mode cider-mode
            [remap cider-eval-defun-at-point] #'eval-top-level-form-and-reload-tilley
            [remap cider-load-buffer] #'load-buffer-and-reload-tilley)
    (map! :mode cider-mode
          [remap eval-top-level-form-and-reload-tilley] #'cider-eval-defun-at-point
          [remap load-buffer-and-reload-tilley] #'cider-load-buffer)))
#+end_src

**** Jet

#+begin_src elisp :noweb-ref packages
(package! jet)
#+end_src

#+begin_src elisp
(use-package! jet)

(defconst special-rx
  (rx (seq "#<" (or "Fn" "Atom") "@" (1+ (in hex)) ": "
           (group (*? anything))
           ">")))

(defun >jet (beginning end)
  (interactive "r")
  (narrow-to-region beginning end)

  ;; Replace string representation of atoms with contents
  (goto-char (point-min))
  (while (re-search-forward special-rx nil t)
    (replace-match "\\1"))

  (shell-command-on-region
   (point-min)
   (point-max)
   "jet --pretty --edn-reader-opts '{:default tagged-literal}'"
   (current-buffer)
   t
   "*jet error buffer*"
   t)

  (widen))
#+end_src

**** REBL

#+begin_src elisp
;; Similar to C-x C-e, but sends to REBL
(defun rebl-eval-last-sexp ()
  (interactive)
  (let* ((bounds (cider-last-sexp 'bounds))
         (s (cider-last-sexp))
         (reblized (concat "(cognitect.rebl/inspect " s ")")))
    (cider-interactive-eval reblized nil bounds (cider--nrepl-print-request-map))))

;; Similar to C-M-x, but sends to REBL
(defun rebl-eval-defun-at-point ()
  (interactive)
  (let* ((bounds (cider-defun-at-point 'bounds))
         (s (cider-defun-at-point))
         (reblized (concat "(cognitect.rebl/inspect " s ")")))
    (cider-interactive-eval reblized nil bounds (cider--nrepl-print-request-map))))

;; C-S-x send defun to rebl
;; C-x C-r send last sexp to rebl (Normally bound to "find-file-read-only"... Who actually uses that though?)
(add-hook 'cider-mode-hook
          (lambda ()
            (local-set-key (kbd "C-S-x") #'rebl-eval-defun-at-point)
            (local-set-key (kbd "C-x C-r") #'rebl-eval-last-sexp)))
#+end_src

**** COMMENT Possible nREPL code injection

I came up with a working PoC for injections using NREPL.  Is there a more straight-forward way to accomplish this?

#+begin_src elisp
(ns repl-eval.nrepl
    (:require [clojure.pprint :refer [pprint]]
     [nrepl.server :as server]
     [nrepl.core :as nrepl]
     refactor-nrepl.middleware
     cider.nrepl))
​
(defn start
  []
  (let [server (server/start-server
                :handler (apply server/default-handler
                                (conj
                                 (map #'cider.nrepl/resolve-or-fail cider.nrepl/cider-middleware)
                                 #'refactor-nrepl.middleware/wrap-refactor)))
               port (:port server)]
    (with-open [cxn (nrepl/connect :port port)]
               (-> (nrepl/client cxn 1000)
                   (nrepl/message {:op "eval" :code "(require '[clojure.pprint :refer [pprint]])"})
                   nrepl/response-values))
    (spit ".nrepl-port" port)))
#+end_src

The injection in this case is requiring pprint.
The code is easily referenced in a deps.edn alias:

#+begin_src clojure
:inject {:extra-deps {waffletower/repl-eval {:local/root "../repl-eval/"}
                      nrepl/nrepl {:mvn/version "0.7.0"}
                      refactor-nrepl/refactor-nrepl {:mvn/version "2.5.0"}
                      cider/cider-nrepl {:mvn/version "0.25.1"}}
         :main-opts ["-m" "repl-eval.nrepl"]}
                      #+end_src

While I could refactor this to instrument variable middleware and injection forms, is there some hook I am missing here? It was much easier and cleaner to accomplish REPL initialization with leiningen.

**** LSP

#+begin_src elisp
(after! lsp-mode
  (push "\\.shadow-cljs" lsp-file-watch-ignored)
  (push "\\.clj-kondo" lsp-file-watch-ignored)
  (push "\\.lsp" lsp-file-watch-ignored)
  (push "\\.cpcache" lsp-file-watch-ignored)
  (push "resources" lsp-file-watch-ignored))

;; TODO test this
;; see https://emacs-lsp.github.io/lsp-mode/tutorials/clojure-guide/
;; (use-package! clj-refactor
;;   :after clojure-mode
;;   :config
;;   (set-lookup-handlers! 'clj-refactor-mode nil))

;; TODO test this
;; see https://emacs-lsp.github.io/lsp-mode/tutorials/clojure-guide/
;; (use-package! cider
;;   :config
;;   (set-lookup-handlers! 'cider-mode nil))
;; Newline below is required for tangling

#+end_src

**** TODO COMMENT Tempel

#+begin_src elisp :noweb-ref doom-init
(package! tempel)
(package! tempel-clojure
  :recipe (:type git
           :host github
           :files ("tempel-clojure.el" "templates")
           :repo "mpenet/tempel-clojure"))
#+end_src

*** Lispy

#+begin_src elisp :tangle ~/.doom.d/config.el
(lispyville-set-key-theme
 '(operators
   c-w
   prettify
   text-objects
   commentary
   slurp/barf-lispy
   ;; mark-special
   ))

;; (use-package! evil-lispy
;;   :config (add-hook! '(clojure-mode clojurec-mode clojurescript-mode) #'evil-lispy-mode))

;; (add-hook! 'evil-escape-inhibit-functions
;;   (defun +lispy-inhibit-evil-escape-fn ()
;;     (and lispy-mode (evil-insert-state-p))))

;; (defun >insert-hash-print (arg)
;;   (interactive "p")
;;   (if (lispy-left-p)
;;       (insert "#p ")
;;     (self-insert-command arg)))

;; (map! :map lispy-mode-map-special :i
;;       "p" #'>insert-hash-print
;;       ;; "f" #'lispy-flow
;;       ;; "d" #'lispy-different
;;       )
;; (remove-hook! 'evil-escape-inhibit-functions #'+lispy-inhibit-evil-escape-fn)
#+end_src

*** JavaScript / TypeScript

all(hope(abandon(ye(who(enter(here))))))

#+begin_src elisp :noweb-ref doom-init-lang
(javascript +lsp)
#+end_src

#+begin_src elisp
;; (require 'ts-comint)

;; (setq ts-comint-program-command "ts-node")
;; (setq ts-comint-program-arguments '("index.ts"))
;; (setq ts-comint-mode-ansi-color nil)
;; (add-hook 'typescript-mode-hook
;;           (lambda ()
;;             (local-set-key (kbd "C-x C-e") 'ts-send-last-sexp)
;;             (local-set-key (kbd "C-M-x") 'ts-send-last-sexp-and-go)
;;             (local-set-key (kbd "C-c b") 'ts-send-buffer)
;;             (local-set-key (kbd "C-c C-b") 'ts-send-buffer-and-go)
;;             (local-set-key (kbd "C-c l") 'ts-load-file-and-go)))

;; (make-comint "foo" "ts-node" nil "index.ts")
;; (make-comint "foo" "which" nil "ts-node")
;; (make-comint "foo" "ts-node" nil "--version")

(require 'nodejs-repl)
(add-hook 'js2-mode-hook
          (lambda ()
            (define-key js2-mode-map (kbd "C-c C-c") #'nodejs-repl-eval-defun)
            ;; (define-key js-mode-map (kbd "C-x C-e") 'nodejs-repl-send-last-expression)
            ;; (define-key js-mode-map (kbd "C-c C-j") 'nodejs-repl-send-line)
            ;; (define-key js-mode-map (kbd "C-c C-r") 'nodejs-repl-send-region)
            ;; (define-key js-mode-map (kbd "C-c C-c") 'nodejs-repl-send-buffer)
            ;; (define-key js-mode-map (kbd "C-c C-l") 'nodejs-repl-load-file)
            ;; (define-key js-mode-map (kbd "C-c C-z") 'nodejs-repl-switch-to-repl)
            ))

;; (defun skewer-eval-defun ()
;;   "Evaluate the JavaScript expression before the point in the
;; waiting browser."
;;   (interactive)
;;   (if js2-mode-buffer-dirty-p
;;       (js2-mode-wait-for-parse (skewer--save-point #'skewer-eval-defun))
;;     (cl-destructuring-bind (string start end) (skewer-get-defun)
;;       (skewer-flash-region start end)
;;       (skewer-eval string #'skewer-post-repl))))

;; (defun skewer-post-repl (result)
;;   "Callback for reporting results in the REPL."
;;   (let ((buffer (get-buffer "*skewer-repl*"))
;;         (output (cdr (assoc 'value result))))
;;     (when buffer
;;       (with-current-buffer buffer
;;         (comint-output-filter (skewer-repl-process)
;;                               (concat "\n" output "\n" skewer-repl-prompt))))))

;; (defun nvm-which ()
;;   (let ((output "node -e "))
;;     (split-string output "[\n]+" t)))

;; (nvm-which)

(setq nodejs-repl-command "node")
(setq nodejs-repl-arguments '("-e" "\"require('repl').start({ignoreUndefined: true})\""))
(setf ansi-color-for-comint-mode 'filter)

;;; nodejs-repl-eval.el --- Summary
;;; Commentary:
;;;
;;; Evaluation functions for the `nodejs-repl' package.  Written on a stormy
;;; night between days of node hacking.
;;;
;;; See https://gist.github.com/emallson/0eae865bc99fc9639fac
;;;
;;; Code:
(require 'js2-mode)
(require 'nodejs-repl)
(require 'dash)

;; (->> "var _ = require('lodash');
;;       _.chain(x)   // a comment here
;;       .filter('defined')
;;       .map(myfn);"
;;   (nodejs-repl--sanitize-code))
(defun nodejs-repl--sanitize-code (text)
  "Avoid conflicts with REPL special constructs: _ and .command"
  (->> text
       ;; obj EOL .fn() => obj. EOL fn() (while also removing "// comments")
       ;; If there is a chained call on a new line, move the dot to the previous line;
       ;; the repl executes lines eagerly and interprets " .something" as a REPL command
       (replace-regexp-in-string "\\(//.*\\)?\n\\(\\s-*\\)\\.\\(\\w+\\)" ".\n\\2\\3")
       ;; Replace _ with __ because underscore is a special thing in the REPL
       (replace-regexp-in-string "\\_<_\\." "__.")
       ;; Replace var _ = require ... with var __ = ...
       (replace-regexp-in-string "var\\s-+_\\s-+=" "var __ =")
       (s-replace-regexp (rx (or (seq "/*" (*? anything) "*/")
                                 (seq "//" (* not-newline) anychar)
                                  "\n"
                                 ))
                         "")))


(defun nodejs-repl-eval-region (start end)
  "Evaluate the region specified by `START' and `END'."
  (let ((proc (get-process nodejs-repl-process-name)))
    (comint-simple-send proc
                        (nodejs-repl--sanitize-code
                         (buffer-substring-no-properties start end)))))

(defun nodejs-repl-eval-node (node)
  "Evaluate `NODE', a `js2-mode' node."
  (let ((beg (js2-node-abs-pos node))
        (end (js2-node-abs-end node)))
    (nodejs-repl-eval-region beg end)))

(defun nodejs-repl--find-current-or-prev-node (pos &optional include-comments)
  "Locate the first node before `POS'.  Return a node or nil.

If `INCLUDE-COMMENTS' is set to t, then comments are considered
valid nodes.  This is stupid, don't do it."
  (let ((node (js2-node-at-point pos (not include-comments))))
    (if (or (null node)
            (js2-ast-root-p node))
        (unless (= 0 pos)
          (nodejs-repl--find-current-or-prev-node (1- pos) include-comments))
      node)))

(defun nodejs-repl-eval-function ()
  "Evaluate the current or previous function."
  (interactive)
  (let* ((fn-above-node (lambda (node)
                         (js2-mode-function-at-point (js2-node-abs-pos node))))
        (fn (funcall fn-above-node
             (nodejs-repl--find-current-or-prev-node
              (point) (lambda (node)
                        (not (null (funcall fn-above-node node))))))))
    (unless (null fn)
      (nodejs-repl-eval-node fn))))

(defun nodejs-repl-eval-first-stmt (pos)
  "Evaluate the first statement found from `POS' by `js2-mode'.

If this statement is a block statement, its first parent
statement is found.  This will be either a function declaration,
function call, or assignment statement."
  (let ((node (js2-mode-find-first-stmt (nodejs-repl--find-current-or-prev-node pos))))
    (cond
     ((js2-block-node-p node) (nodejs-repl-eval-node (js2-node-parent-stmt node)))
     ((not (null node)) (nodejs-repl-eval-node node)))))

(defun nodejs-repl-eval-dwim ()
  "Heuristic evaluation of JS code in a NodeJS repl.

Evaluates the region, if active, or the first statement found at
or prior to the point.

If the point is at the end of a line, evaluation is done from one
character prior.  In many cases, this will be a semicolon and will
change what is evaluated to the statement on the current line."
  (interactive)
  (cond
   ((use-region-p) (nodejs-repl-eval-region (region-beginning) (region-end)))
   ((= (line-end-position) (point)) (nodejs-repl-eval-first-stmt (1- (point))))
   (t (nodejs-repl-eval-first-stmt (point)))))

(defun nodejs-repl-eval-buffer (&optional buffer)
  "Evaluate the current buffer or the one given as `BUFFER'.

`BUFFER' should be a string or buffer."
  (interactive)
  (let ((buffer (or buffer (current-buffer))))
    (with-current-buffer buffer
      (nodejs-repl-eval-region (point-min) (point-max)))))

(defun nodejs-repl-eval-defun ()
  "Evaluate the JavaScript expression before the point in the
waiting browser."
  (interactive)
  (cl-destructuring-bind (string start end) (skewer-get-defun)
    (nodejs-repl-eval-region start end)))

(define-key js2-mode-map (kbd "C-c C-c") #'nodejs-repl-eval-defun)
(define-key js2-mode-map (kbd "C-c C-k") #'nodejs-repl-eval-buffer)
#+end_src
*** Haskell

"a language that's lazier than I am"

#+begin_src nix :noweb-ref system-packages
cabal-install
cabal2nix
ghc
#+end_src

#+begin_src elisp :noweb-ref doom-init-lang
(haskell +lsp +tree-sitter)
#+end_src

#+begin_src elisp :noweb-ref org-babel-languages
(haskell . t)
#+end_src

#+begin_src elisp :noweb-ref doom-config
;; (use-package! haskell-interactive-mode)
;; (use-package! haskell-process)
;; (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
;; (define-key haskell-mode-map (kbd "C-`") 'haskell-interactive-bring)
;; (define-key haskell-mode-map (kbd "C-c C-t") 'haskell-process-do-type)
;; (define-key haskell-mode-map (kbd "C-c C-i") 'haskell-process-do-info)
;; (define-key haskell-mode-map (kbd "C-c C-c") 'haskell-process-build)
;; (define-key haskell-interactive-mode-map (kbd "C-c C-c") 'haskell-process-build)
;; (define-key haskell-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
;; (define-key haskell-mode-map (kbd "C-c c") 'haskell-process-cabal)

(use-package! haskell
  :config
  (setq
   haskell-process-suggest-remove-import-lines t
   haskell-process-auto-import-loaded-modules t
   haskell-process-log t)

  (defun >haskell-interactive-mode-send-expr (expr)
    "Run the given expression."
    (let* ((session (haskell-interactive-session))
           (buffer (haskell-session-interactive-buffer session))
           (process (haskell-interactive-process)))
      (haskell-process-queue-command
       process
       (make-haskell-command
        :state (list session process expr 0)
        :go (lambda (state)
              (with-current-buffer buffer
                (insert "\n\n"))
              (setq haskell-interactive-mode-result-end
                    (point-max))
              (haskell-process-send-string (cadr state)
                                           (haskell-interactive-mode-multi-line (cl-caddr state)))
              (haskell-process-set-evaluating (cadr state) t))
        :live (lambda (state buffer)
                (unless (and (string-prefix-p ":q" (cl-caddr state))
                             (string-prefix-p (cl-caddr state) ":quit"))
                  (let* ((cursor (cl-cadddr state))
                         (next (replace-regexp-in-string
                                haskell-process-prompt-regex
                                ""
                                (substring buffer cursor))))
                    (haskell-interactive-mode-eval-result (car state) next)
                    (setf (cl-cdddr state) (list (length buffer)))
                    nil)))
        :complete
        (lambda (state response)
          (haskell-process-set-evaluating (cadr state) nil)
          (unless (haskell-interactive-mode-trigger-compile-error state response)
            (haskell-interactive-mode-expr-result state response)))))))

  (defun >haskell-process-load-or-reload (&optional toggle)
    (interactive "P")
    (if toggle
        (progn (setq haskell-reload-p (not haskell-reload-p))
               (message "%s (No action taken this time)"
                        (if haskell-reload-p
                            "Now running :reload."
                          "Now running :load <buffer-filename>.")))
      (if haskell-reload-p (haskell-process-reload) (haskell-process-load-file)))
    (let* ((session (haskell-session))
           (buffer (haskell-session-interactive-buffer session)))
      (>haskell-interactive-mode-send-expr "main")))

  (define-key interactive-haskell-mode-map (kbd "C-c C-l") #'>haskell-process-load-or-reload)
  (define-key haskell-mode-map (kbd "C-c C-z") #'haskell-interactive-switch)

  ;; (define-key haskell-mode-map (kbd "C-c C-n C-t") 'haskell-process-do-type)
  ;; (define-key haskell-mode-map (kbd "C-c C-n C-i") 'haskell-process-do-info)
  ;; (define-key haskell-mode-map (kbd "C-c C-n C-c") 'haskell-process-cabal-build)
  ;; (define-key haskell-mode-map (kbd "C-c C-n c") 'haskell-process-cabal)
  ;; (define-key haskell-cabal-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
  ;; (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
  ;; (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
  ;; (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)


  ;; --------------------------------------------------
  ;; This seems to try make the org src buffer a real file
  ;;
  ;; (defconst fn/haskell-file-extension ".hs"
  ;;   "The de facto haskell file extension.")

  ;; (defun fn/add-haskell-file-extension (name)
  ;;   "Add the extension of .hs to a file or buffer NAME."
  ;;   (if (string/ends-with name fn/haskell-file-extension)
  ;;       name (concat name fn/haskell-file-extension)))


  ;; (defvar fn/org-haskell-mode-hook (list)
  ;;   "Hook when buffer is haskellized."
  ;;   ;; :type 'hook
  ;;   )
  ;; ;; (defvar fn/org-haskell-mode-hook nil
  ;; ;;   "Hook when buffer is haskellized.")

  ;; (defun fn/haskellize-buffer-file (&optional buffer)
  ;;   "Renames an BUFFER with a .hs extension if it doesn't have one."
  ;;   (interactive)
  ;;   (with-current-buffer (or buffer (current-buffer))
  ;;     (save-buffer)
  ;;     (let ((name (buffer-name))
  ;;           (file-name (buffer-file-name)))
  ;;       (if (not (and file-name (file-exists-p file-name)))
  ;;           (error "Buffer '%s' has no backing file" name)
  ;;         (let ((haskellized-name (fn/add-haskell-file-extension name))
  ;;               (haskellized-file-name (fn/add-haskell-file-extension file-name)))
  ;;           (cond
  ;;            ((get-buffer haskellized-name)
  ;;             (error "A buffer named '%s' already exists" haskellized-name))
  ;;            ((string-equal name haskellized-name)
  ;;             (message "Buffer %s is already haskellized" haskellized-name))
  ;;            (t
  ;;             (rename-file file-name haskellized-file-name t)
  ;;             (rename-buffer haskellized-name)
  ;;             (set-visited-file-name haskellized-file-name)
  ;;             (set-buffer-modified-p nil)
  ;;             (message "Buffer %s is now haskellized" haskellized-name))))))))

  ;; (defun fn/org-haskell-buffer-p (&optional buffer)
  ;;   "Check if BUFFER is an org-haskell buffer."
  ;;   (with-current-buffer (or buffer (current-buffer))
  ;;     (and (eq major-mode 'haskell-mode)
  ;;        (fboundp 'org-src-edit-buffer-p)
  ;;        (org-src-edit-buffer-p))))

  ;; (defun fn/haskellize-org-haskell-buffer (&rest _)
  ;;   "Haskellize org haskell buffer."
  ;;   (when (fn/org-haskell-buffer-p)
  ;;     (fn/haskellize-buffer-file (current-buffer))
  ;;     (run-hooks 'fn/org-haskell-mode-hook)))

  ;; (defun fn/save-org-haskell-buffer (&rest _)
  ;;   "Save haskell buffer along with the edit buffer."
  ;;   (when (fn/org-haskell-buffer-p)
  ;;     (save-buffer)))

  ;; (defun fn/cleanup-org-haskell-buffer (orig-fun &rest args)
  ;;   "Cleanup the org-haskell buffer when exiting the edit buffer."
  ;;   (prn '--------------------------------------------------)
  ;;   (let ((org-haskell-file-name (buffer-file-name))
  ;;       (org-haskell-buffer-p (fn/org-haskell-buffer-p)))
  ;;     (prog1
  ;;         (apply orig-fun args)
  ;;       (when (and (file-exists-p org-haskell-file-name) org-haskell-buffer-p)
  ;;         (delete-file org-haskell-file-name)))))

  ;; (remove-hook 'org-src-mode-hook #'fn/haskellize-org-haskell-buffer t)

  ;; (advice-remove 'org-edit-src-save #'fn/save-org-haskell-buffer)
  ;; (advice-remove 'org-edit-src-exit #'fn/cleanup-org-haskell-buffer)

  ;; (defun fn/haskell-process-load-or-reload ()
  ;;   "Invoke reload process without switching buffers"
  ;;   (save-window-excursion
  ;;     (haskell-process-load-or-reload)))

  ;; (defun fn/haskell-reload-on-save ()
  ;;   "Reload interactive haskell process on save."
  ;;   (add-hook 'after-save-hook 'fn/haskell-process-load-or-reload t t))

  ;; (defun fn/hindent-before-save ()
  ;;   "Reformat before saving."
  ;;   (interactive)
  ;;   (add-hook 'before-save-hook 'hindent-reformat-buffer t t))

  ;; (remove-hook 'fn/org-haskell-mode-hook 'fn/haskell-process-load-or-reload)
  ;; (remove-hook 'fn/org-haskell-mode-hook 'fn/haskell-reload-on-save)
  ;; (remove-hook 'fn/org-haskell-mode-hook 'fn/hindent-before-save) ;;
  )
#+end_src

**** Snippets
:PROPERTIES:
:header-args+: :comments no
:END:

#+begin_src snippet :tangle ~/.doom.d/snippets/haskell-mode/main
# name: mainp
# key: mainp
# --
main :: IO ()
main = do
  print $
#+end_src
*** Nix

"I hereby declare 'nix geht mehr!'"

#+begin_src elisp :noweb-ref doom-init-lang
nix
#+end_src

#+begin_src elisp :noweb-ref packages
(package! ob-nix)
#+end_src

#+begin_src elisp noweb-ref doom-config
(use-package! ob-nix)
#+end_src

*** AppleScript

#+begin_src elisp :noweb-ref packages
(package! apples-mode)
(package! applescript-mode)
(package! ob-applescript)
#+end_src

#+begin_src elisp :noweb-ref doom-config
(use-package! apples-mode)
(use-package! applescript-mode)
(use-package! ob-applescript)
#+end_src

#+begin_src elisp :noweb-ref org-babel-languages
(applescript . t)
#+end_src

*** Dired/Eshell

#+begin_src elisp :tangle ~/.doom.d/config.el
(defun >buffer-mode (&optional buffer-or-name)
  "Return the major mode associated with a buffer.
If buffer-or-name is nil return current buffer's mode."
  (interactive)
  (buffer-local-value
   'major-mode
   (if buffer-or-name
       (get-buffer buffer-or-name)
     (current-buffer))))

(defun >buffer-path ()
  (file-name-directory (or  (buffer-file-name) default-directory)))

(defun >eshell ()
  (interactive)
  (unless (persp-with-name-exists-p "shell")
    (+workspace/load "shell"))
  (+workspace-switch "shell"))

(defun eshell-cwd ()
  "Set the eshell directory to the current buffer.

  Usage: M-x eshell-cwd"
  (interactive)
  (let ((path (>buffer-path)))
    (>eshell)
    (switch-to-buffer "*eshell*")
    (cd path)
    (eshell-send-input)))

(defun dired-cwd ()
  (interactive)
  (let ((path (file-name-directory (or  (buffer-file-name) default-directory))))
    (dired path)))

(defun dired-or-eshell ()
  (interactive)
  (let ((mode (>buffer-mode)))
    (cond
     ((eq 'eshell-mode mode) (+workspace/other))
     ((eq 'dired-mode mode) (eshell-cwd))
     (t (>eshell)))))

(map! :n "-" #'dired-or-eshell)
#+end_src

*** Functions
**** JRT functions

#+begin_src elisp :tangle ~/.doom.d/config.el
(defun >process-cost-line-item ()
  (interactive)
  (goto-char (point-min))
  (while (not (eobp))
    (beginning-of-line)
    (let* ((item (progn
                   (kill-region (point)
                                (- (search-forward "$") 1))
                   (string-trim (current-kill 0 t))))
           (amount (progn
                     (beginning-of-line)
                     (set-mark-command nil)
                     (goto-char (re-search-forward "$"))
                     (kill-region (region-beginning)
                                  (region-end))
                     (replace-regexp-in-string
                      "\\$\\|\\."
                      ""
                      (string-trim (current-kill 0 t))))))
      (insert "{")
      (insert ":label \"" item  "\"\n")
      (insert " :price " amount  "\n")
      (insert " :max-price " (number-to-string (* (string-to-number amount) 2))  "\n")
      (insert " :min-price 0" )
      (insert "}")
      (end-of-line 1)
      (forward-line 1))))

;; Excel file that Nick sent on 23 Jan 2022
(defun >process-cop-budgets-tool-excel ()
  (interactive)
  (goto-char (point-min))
  (let ((columns '("Custom Work"
                   "Fertilizer"
                   "Chemicals"
                   "Crop Ins."
                   "Seed"
                   "Labor"
                   "Fuel"
                   "Irrigation"
                   "Repairs"
                   "Misc."
                   "Equip Cost."
                   "Cash Rent"
                   "Interest")))
    (beginning-of-line)
    (while (not (eobp))
      (let* ((column (pop columns))
             (item (progn
                     (kill-region (line-beginning-position)
                                  (+ 2 (line-beginning-position)))
                     (kill-region (line-beginning-position)
                                  (line-end-position))
                     (string-trim (current-kill 0 t)))))
        (message "%s %s" column item)
        (insert "{")
        (insert ":label \"" column  "\"\n")
        (insert " :price " item  "\n")
        (insert " :max-price " (number-to-string (* (string-to-number item) 2))  "\n")
        (insert " :min-price 0" )
        (insert "}")
        (end-of-line 1)
        (forward-line 1)))))
#+end_src

**** Music downloads fixer

#+begin_src elisp :tangle ~/.doom.d/config.el
(defun >file-fixer--finalize ()
  (interactive)
  (evil-next-line)
  (dired-goto-next-file)
  (recenter nil))

(defun >file-fixer--remove-original-mix* ()
  (kill-region (point)
               (line-end-position))
  (insert
   (replace-regexp-in-string
    " ?-? (Original Mix)"
    ""
    (string-trim (current-kill 0 t)))))

(defun >file-fixer--next-line ()
  (interactive)
  (evil-next-line)
  (recenter nil))

(defun >file-fixer--previous-line ()
  (interactive)
  (evil-previous-line)
  (recenter nil))

(defun >file-fixer--remove-original-mix ()
  (interactive)
  (dired-goto-next-file)
  (>file-fixer--remove-original-mix*)
  (>file-fixer--finalize))

(defun >file-fixer--bandcamp-directory-fixer ()
  (interactive)
  (dired-goto-next-file)
  (kill-region (point)
               (line-end-position))
  (insert
   (replace-regexp-in-string
    (rx (seq (submatch (not " ")) "- "))
    "\\1, "
    (string-trim (current-kill 0 t))))
  (>file-fixer--finalize))

(defun >file-fixer--bandcamp-directory-fixer-remove-artist ()
  (interactive)
  (dired-goto-next-file)
  (kill-region (search-forward " - ")
               (search-forward " - "))
  (>file-fixer--bandcamp-directory-fixer))

(defun >file-fixer--bandcamp-buzzcut* ()
  (dired-goto-next-file)
  (when (= 4 (count-matches "- " (point) (line-end-position)))
    (kill-region (point)
                 (search-forward "- ")))
  (kill-region (point)
               (search-forward "- "))
  (kill-region (point)
               (search-forward "- ")))

(defun >file-fixer--bandcamp-buzzcut ()
  "Remove artist and album from each song filename"
  (interactive)
  (>file-fixer--bandcamp-buzzcut*)

  (forward-char 3)
  (insert "- ")
  (>file-fixer--remove-original-mix*)
  (>file-fixer--finalize))

(defun >file-fixer--bandcamp-buzzcut-remove-artist ()
  "Remove artist and album from each song filename"
  (interactive)
  (>file-fixer--bandcamp-buzzcut*)
  (forward-char 3)
  (kill-region (point)
               (search-forward "- "))
  (insert "- ")
  (>file-fixer--remove-original-mix*)
  (>file-fixer--finalize))

(defun >file-fixer--move-key-after-track-number ()
  "Move key after track number"
  (interactive)
  (dired-goto-next-file)
  (kill-region (point)
               (search-forward "- "))
  (search-forward "- ")
  (insert (string-trim (current-kill 0 t)))
  (insert " ")
  (>file-fixer--finalize))

(defhydra >music-filename-fixer (global-map "C-c C-m")
  "zoom"
  ("j" >file-fixer--next-line)
  ("k" >file-fixer--previous-line)
  ("u" evil-undo)
  ("z z" evil-scroll-line-to-center)
  ("d" >file-fixer--bandcamp-directory-fixer "Fix Bandcamp directory name")
  ("D" >file-fixer--bandcamp-directory-fixer-remove-artist "Fix Bandcamp directory name and remove artist")
  ("t" >file-fixer--move-key-after-track-number "Key after track number")
  ("b" >file-fixer--bandcamp-buzzcut "Fix Bandcamp filename")
  ("B" >file-fixer--bandcamp-buzzcut-remove-artist "Fix Bandcamp filename and remove artist")
  ("o" >file-fixer--remove-original-mix "Remove original mix from filename"))
#+end_src

** Lispy bindings
#+NAME: lispy-bindings
| key | function                      | column   |
|-----+-------------------------------+----------|
| <   | lispy-barf                    |          |
| A   | lispy-beginning-of-defun      |          |
| j   | lispy-down                    |          |
| Z   | lispy-edebug-stop             |          |
| B   | lispy-ediff-regions           |          |
| G   | lispy-goto-local              |          |
| h   | lispy-left                    |          |
| N   | lispy-narrow                  |          |
| y   | lispy-occur                   |          |
| o   | lispy-other-mode              |          |
| J   | lispy-outline-next            |          |
| K   | lispy-outline-prev            |          |
| P   | lispy-paste                   |          |
| l   | lispy-right                   |          |
| I   | lispy-shifttab                |          |
| >   | lispy-slurp                   |          |
| SPC | lispy-space                   |          |
| xB  | lispy-store-region-and-buffer |          |
| u   | lispy-undo                    |          |
| k   | lispy-up                      |          |
| v   | lispy-view                    |          |
| V   | lispy-visit                   |          |
| W   | lispy-widen                   |          |
| D   | pop-tag-mark                  |          |
| x   | see                           |          |
| L   | unbound                       |          |
| U   | unbound                       |          |
| X   | unbound                       |          |
| Y   | unbound                       |          |
| H   | lispy-ace-symbol-replace      | Edit     |
| c   | lispy-clone                   | Edit     |
| C   | lispy-convolute               | Edit     |
| n   | lispy-new-copy                | Edit     |
| O   | lispy-oneline                 | Edit     |
| r   | lispy-raise                   | Edit     |
| R   | lispy-raise-some              | Edit     |
| \   | lispy-splice                  | Edit     |
| S   | lispy-stringify               | Edit     |
| i   | lispy-tab                     | Edit     |
| xj  | lispy-debug-step-in           | Eval     |
| xe  | lispy-edebug                  | Eval     |
| xT  | lispy-ert                     | Eval     |
| e   | lispy-eval                    | Eval     |
| E   | lispy-eval-and-insert         | Eval     |
| xr  | lispy-eval-and-replace        | Eval     |
| p   | lispy-eval-other-window       | Eval     |
| q   | lispy-ace-paren               | Move     |
| z   | lispy-knight                  | Move     |
| s   | lispy-move-down               | Move     |
| w   | lispy-move-up                 | Move     |
| t   | lispy-teleport                | Move     |
| Q   | lispy-ace-char                | Nav      |
| -   | lispy-ace-subword             | Nav      |
| a   | lispy-ace-symbol              | Nav      |
| b   | lispy-back                    | Nav      |
| d   | lispy-different               | Nav      |
| f   | lispy-flow                    | Nav      |
| F   | lispy-follow                  | Nav      |
| g   | lispy-goto                    | Nav      |
| xb  | lispy-bind-variable           | Refactor |
| xf  | lispy-flatten                 | Refactor |
| xc  | lispy-to-cond                 | Refactor |
| xd  | lispy-to-defun                | Refactor |
| xi  | lispy-to-ifs                  | Refactor |
| xl  | lispy-to-lambda               | Refactor |
| xu  | lispy-unbind-variable         | Refactor |
| M   | lispy-multiline               | Other    |
| xh  | lispy-describe                | Other    |
| m   | lispy-mark-list               | Other    |

#+begin_src elisp :var bindings=lispy-bindings :colnames yes
(eval
 (append
  '(defhydra my/lispy-cheat-sheet (:hint nil :foreign-keys run)
     ("<f12>" nil :exit t))
  (cl-loop for x in bindings
           unless (string= "" (elt x 2))
           collect
           (list (car x)
                 (intern (elt x 1))
                 (when (string-match "lispy-\\(?:eval-\\)?\\(.+\\)"
                                     (elt x 1))
                   (match-string 1 (elt x 1)))
                 :column
                 (elt x 2)))))
(with-eval-after-load "lispy"
  (define-key lispy-mode-map (kbd "<f12>") 'my/lispy-cheat-sheet/body))
#+end_src

** config

#+begin_src elisp :tangle ~/.doom.d/config.el
<<doom-config>>
#+end_src

** init

#+begin_src elisp :tangle ~/.doom.d/init.el
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a "Module Index" link where you'll find
;;      a comprehensive list of Doom's modules and what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).

(doom! :input

       :completion
       ;; (corfu +icons +tng)
       ;company             ; the ultimate code completion backend
       (vertico +icons +childframe)
       ;ivy                 ; a search engine for love and life

       :ui
       ;;deft              ; notational velocity for Emacs
       doom                ; what makes DOOM look the way it does
       doom-dashboard      ; a nifty splash screen for Emacs
       doom-quit           ; DOOM quit-message prompts when you quit Emacs
       ;;(emoji +unicode)  ; 🙂
       hl-todo             ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       hydra
       ;;indent-guides     ; highlighted indent columns
       ;;ligatures         ; ligatures and symbols to make your code pretty again
       ;;minimap           ; show a map of the code on the side
       modeline            ; snazzy, Atom-inspired modeline, plus API
       ;;nav-flash         ; blink cursor line after big motions
       ;;neotree           ; a project drawer, like NERDTree for vim
       ophints             ; highlight the region an operation acts on
       (popup +defaults)   ; tame sudden yet inevitable temporary windows
       ;;tabs              ; a tab bar for Emacs
       ;;treemacs          ; a project drawer, like neotree but cooler
       ;;unicode           ; extended unicode support for various languages
       vc-gutter           ; vcs diff in the fringe
       vi-tilde-fringe     ; fringe tildes to mark beyond EOB
       window-select       ; TODO check +numbers visually switch windows
       zen                 ; distraction-free coding or writing
       <<doom-ui>>

       :editor
       (evil +everywhere)  ; come to the dark side, we have cookies
       file-templates      ; auto-snippets for empty files
       fold                ; (nigh) universal code folding
       ;;(format +onsave)  ; automated prettiness
       ;;god               ; run Emacs commands without modifier keys
       lispy               ; vim for lisp, for people who don't like vim
       ;;multiple-cursors    ; editing in many places at once
       ;;objed             ; text object editing for the innocent
       ;;parinfer          ; turn lisp into python, sort of
       ;;rotate-text       ; cycle region at point between text candidates
       snippets            ; my elves. They type so I don't have to
       word-wrap           ; soft wrapping with language-aware indent

       :emacs
       dired               ; making dired pretty [functional]
       electric            ; smarter, keyword-based electric-indent
       ibuffer             ; interactive buffer management
       undo                ; persistent, smarter undo for your inevitable mistakes
       vc                  ; version-control and Emacs, sitting in a tree

       :term
       eshell              ; the elisp shell that works everywhere
       ;;shell             ; simple shell REPL for Emacs
       ;;term              ; basic terminal emulator for Emacs
       vterm               ; the best terminal emulation in Emacs

       :checkers
       syntax              ; tasing you for every semicolon you forget
       (spell +aspell
              +everywhere) ; tasing you for misspelling mispelling
       grammar             ; tasing grammar mistake every you make

       :tools
       ;;ansible
       debugger            ; FIXME stepping through code, to help you add bugs
       ;;direnv
       ;;docker
       ;;editorconfig      ; let someone else argue about tabs vs spaces
       ;;ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)       ; run code, run (also, repls)
       ;;gist              ; interacting with github gists
       lookup              ; navigate your code and its documentation
       lsp
       make                ; run make tasks from Emacs
       ;;pass              ; password manager for nerds
       ;;pdf               ; pdf enhancements
       prodigy             ; FIXME managing external services & code builders
       ;;rgb               ; creating color strings
       taskrunner          ; taskrunner for all your projects
       ;;terraform         ; infrastructure as code
       ;;tmux              ; an API for interacting with tmux
       ;;upload            ; map local to remote projects via ssh/ftp
       <<doom-init-tools>>

       :os
       (:if IS-MAC macos)  ; improve compatibility with macOS
       ;;tty               ; improve the terminal Emacs experience

       :lang
       ;;agda              ; types of types of types of types...
       ;;cc                ; C/C++/Obj-C madness
       (clojure +lsp)      ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       ;;data              ; config/data formats
       ;;(dart +flutter)   ; paint ui and not much else
       ;;elixir            ; erlang done right
       ;;elm               ; care for a cup of TEA?
       emacs-lisp          ; drown in parentheses
       ;;erlang            ; an elegant language for a more civilized age
       ;;ess               ; emacs speaks statistics
       ;;faust             ; dsp, but you get to keep your soul
       ;;fsharp            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
       ;;(go +lsp)         ; the hipster dialect
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ; a language you can depend on
       ;;json              ; At least it ain't XML
       ;;(java +meghanada) ; the poster child for carpal tunnel syndrome
       ;;julia             ; a better, faster MATLAB
       ;;kotlin            ; a better, slicker Java(Script)
       ;;latex             ; writing papers in Emacs has never been so fun
       ;;lean
       ;;factor
       ;;ledger            ; an accounting system in Emacs
       ;;lua               ; one-based indices? one-based indices
       markdown            ; writing docs for people to ignore
       ;;nim               ; python + lisp at the speed of c
       ;;ocaml             ; an objective camel
       ;;php               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;purescript        ; javascript, but functional
       ;;python            ; beautiful is better than ugly
       ;;qt                ; the 'cutest' gui framework ever
       ;;raku              ; the artist formerly known as perl6
       ;;rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       ;;rust              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
       ;;scala             ; java, but good
       (scheme +racket) ; a fully conniving family of lisps
       sh                  ; she sells {ba,z,fi}sh shells on the C xor
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       (web +css)          ; the tubes
       yaml                ; JSON, but readable
       <<doom-init-lang>>

       :email
       ;;(mu4e +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)

       :app
       ;;calendar
       ;;irc               ; how neckbeards socialize
       ;;(rss +org)        ; emacs as an RSS reader
       ;;twitter           ; twitter client https://twitter.com/vnought

       :config
       ;;literate
       (default +bindings +smartparens))
#+end_src

** packages

#+begin_src elisp :tangle ~/.doom.d/packages.el
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.


;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
                                        ;(package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
                                        ;(package! another-package
                                        ;  :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
                                        ;(package! this-package
                                        ;  :recipe (:host github :repo "username/repo"
                                        ;           :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
                                        ;(package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
                                        ;(package! builtin-package :recipe (:nonrecursive t))
                                        ;(package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
                                        ;(package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
                                        ;(package! builtin-package :pin "1a2b3c4d5e")


;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
                                        ;(unpin! pinned-package)
;; ...or multiple packages
                                        ;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
                                        ;(unpin! t)
                                        ;

;; transient showcase

;; (package! transient-showcase
;;   :recipe (:type git :host github :repo "positron-solutions/transient-showcase"))

;; TODO investigate
(package! popon
  :recipe (:type git :repo "https://codeberg.org/akib/emacs-popon"))

;; (package! org-special-block-extras
;;   :recipe (:type git :host github :repo "alhassy/org-special-block-extras"))

(package! mini-frame)
(package! swift-mode)
(package! fennel-mode)
(package! aggressive-indent)
(package! back-button)
(package! auto-dim-other-buffers)
(package! evil-lispy)
(package! worf)
(package! org-download)
;; (package! writeroom-mode)
(package! key-chord)
;; (package! pcre2el)
(package! kaocha-runner)
(package! evil-motion-trainer
  :recipe (:host github :repo "martinbaillie/evil-motion-trainer"))
(package! flycheck-projectile)
<<packages>>
#+end_src

** services

*** git annex

#+begin_src elisp :tangle ~/.doom.d/config.el
(prodigy-define-tag
  :name 'annex-backup
  :command "git"
  :stop-signal 'sigkill
  :kill-process-buffer-on-stop t
  :on-output (lambda (&rest args)
               (let ((output (plist-get args :output))
                     (service (plist-get args :service)))
                 (when (s-matches? "recording state in git..." output)
                   (prodigy-set-status service 'stopped)))))
#+end_src

#+begin_src elisp :tangle ~/.doom.d/config.el
(prodigy-define-tag
  :name 'org
  :cwd "~/org")

(prodigy-define-service
  :tags '(org annex-backup)
  :name "Org: annex copy --all --to rsync"
  :args (->> "annex copy --all --to rsync"
             (s-split " ")))

(prodigy-define-service
  :tags '(org annex-backup)
  :name "Org: annex copy --all --to drive"
  :args (->> "annex copy --all --to drive"
             (s-split " ")))

(prodigy-define-service
  :name "Org add books"
  :command "git"
  :args (->> "annex add ."
             (s-split " "))
  :cwd "~/org/books"
  :tags '(annex-add))
#+end_src

#+begin_src elisp :tangle ~/.doom.d/config.el
(prodigy-define-tag
  :name 'tracks
  :cwd "~/tracks")

(prodigy-define-service
  :tags '(tracks annex-backup)
  :name "Tracks: annex copy --all --to rsync"
  :args (->> "annex copy --all --to rsync"
             (s-split " ")))

(prodigy-define-service
  :tags '(tracks annex-backup)
  :name "Tracks: annex copy --all --to drive"
  :args (->> "annex copy --all --to drive"
             (s-split " ")))

;; (prodigy-define-service
;;   :name "Org add books"
;;   :command "git"
;;   :args (->> "annex add ."
;;              (s-split " "))
;;   :cwd "~/org/books"
;;   :tags '(annex-add))
#+end_src

*** COMMENT JRA

#+begin_src elisp :tangle ~/.doom.d/config.el
(prodigy-define-service
  :name "fulcro template"
  :command "npx"
  :args '("shadow-cljs" "-A:cider-nrepl:debug-tools" "server")
  :cwd "~/src/fulcro-template"
  :tags '(work fulcro)
  :stop-signal 'sigkill
  :kill-process-buffer-on-stop t
  :on-output (lambda (&rest args)
               (let ((output (plist-get args :output))
                     (service (plist-get args :service)))
                 (when (s-matches? "shadow-cljs - nREPL server started on port 9000" output)
                   (prodigy-set-status service 'ready)))))

(prodigy-define-service
  :name "RAD demo"
  :command "npx"
  :args '("shadow-cljs" "-A:cider-nrepl:debug-tools" "server")
  :cwd "~/src/rad-demo/"
  :tags '(work fulcro)
  :stop-signal 'sigkill
  :kill-process-buffer-on-stop t
  :on-output (lambda (&rest args)
               (let ((output (plist-get args :output))
                     (service (plist-get args :service)))
                 (when (s-matches? "shadow-cljs - nREPL server started on port 9000" output)
                   (prodigy-set-status service 'ready)))))

(prodigy-define-service
  :name "JRA frontend"
  :command "npx"
  :args '("shadow-cljs" "-A:cider-nrepl:debug-tools" "server")
  :cwd "~/src/jra"
  :tags '(work fulcro)
  :stop-signal 'sigkill
  :kill-process-buffer-on-stop t
  :on-output (lambda (&rest args)
               (let ((output (plist-get args :output))
                     (service (plist-get args :service)))
                 (when (s-matches? "shadow-cljs - nREPL server started on port 9000" output)
                   (prodigy-set-status service 'ready)))))

(prodigy-define-service
  :name "JRA SOCKS proxy"
  :command "datomic"
  :command "printenv"
  :args '("client" "access" "jra-storage" "-p" "jra")
  ;; :args '("$AWS_ACCESS_KEY_ID")
  :cwd "~/src/jra/bin"
  ;; :env '(("LANG" "en_US.UTF-8")
  ;;        ("LC_ALL" "en_US.UTF-8"))
  :tags '(work fulcro)
  :stop-signal 'sigkill
  :kill-process-buffer-on-stop t)
#+end_src

*** TODO add all annexes to services and make sure everything is up to date


- [X] org/books
- [X] comics
- [ ] audio
  - [ ] Need to check desktop for lost stuff in audio-old folder
  - [ ] projects
    - [ ] need to setup size split annex attr
    - [ ] need to selvage what I can from old folder
  - [ ] application data
  - [ ] dj sets
  - [ ] plugins
    - [ ] add new misc plugins to annex
    - [ ] need to selvage what I can from old folder
  - [ ] samples
    - [ ] need to selvage what I can from old folder
  - [ ] tutorials
    - [ ] need to selvage what I can from old folder
  - [ ] patches
    - [ ] need to setup git
    - [ ] setup annex and remotes
    - [ ] need to selvage what I can from old folder
- [ ] rsync
  - [ ] delete brain dir

** .dir-locals

#+begin_src elisp
((nil . ((cider-clojure-cli-global-options . "-A:dev:test:kondo:debug-tools -J-Dtrace -J-Dghostwheel.enabled=true")
         (cider-custom-cljs-repl-init-form . "(shadow/repl :main)")
         (cider-default-cljs-repl . shadow-select)
         (cider-known-endpoints . (("host-a" "10.10.10.1" "7888")
                                   ("localhost" "9000"))))))
#+end_src

** profiles

#+begin_src elisp :tangle ~/.emacs-profiles.el
(("doom"   . ((user-emacs-directory . "~/.config/doom-emacs")))
 ("rigpa" . ((user-emacs-directory . "~/.config/rigpa-emacs")))
 ("vanilla" . ((user-emacs-directory . "~/.config/vanilla-emacs"))))
#+end_src

*** Default profile

#+NAME: env-chemacs
| CHEMACS_PROFILE | doom |

*** Commands to run profiles
:PROPERTIES:
:header-args+:sh: :shebang #!/bin/zsh
:END:

*** Test MacOS app :app-bundle:

#+begin_src swift :shebang #!/usr/bin/swift :tangle ~/bin/rigpa-emacs
import Foundation
let task = Process()
let pipe = Pipe()
task.standardOutput = pipe
task.standardError = pipe

task.executableURL = URL(fileURLWithPath: "/bin/zsh")
task.arguments = ["-c", "echo \"foo\""]
try print(task.run())
#+end_src

*** Vanilla
:PROPERTIES:
:header-args+:elisp: :tangle ~/.config/rigpa-emacs/init.el
:END:

#+begin_src elisp
(require 'package)
(package-install 'use-package)
#+end_src

** Install

#+begin_src nix :noweb-ref darwin-config
# services.emacs = {
#   enable = true;
#   package = pkgs.emacs29;
# };
#+end_src

* Karabiner

** Functionality

#+name: karabiner-shell
#+begin_src elisp var cmd=""
(let ((command (s-split " " cmd)))
  (setcar command (executable-find (car command)))
  (format "\"%s\"" (s-join " " command)))
#+end_src

#+name: karabiner-e
#+begin_src elisp var cmd=""
(let ((arg (format "'%s'" cmd))
      (e (executable-find "e")))
  (s-lex-format "\"${e} ${arg}\""))
#+end_src

** Org capture current Safari URL

#+name: org-capture-safari-tab-template
#+begin_src org
,* ${tab-title}
:PROPERTIES:
:ID: %(org-id-new)
:ROAM_REFS: ${tab-url}
:END:
%?
#+end_src

#+begin_src elisp :noweb-ref doom-config
(defun >org-capture-safari-tab-frame-body ()
  (interactive)
  (let ((org-roam-capture-templates
         '(("d" "default" entry <<src-block-value(name="org-capture-safari-tab-template")>>
            :target (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                   "#+title: ${title}\n"
                                   >org-roam-capture-get-node-path)
            :unnarrowed t))))
    (yequake-org-roam-capture nil nil :info >org-capture-current-safari-tab)))
#+end_src

#+begin_src elisp :noweb-ref yequake-frames
("org-capture-safari-tab"
 (buffer-fns . (>org-capture-safari-tab-frame-body))
 (width . 0.75)
 (height . 0.5)
 (alpha . 0.95)
 (frame-parameters . ((undecorated . t)
                      (skip-taskbar . t)
                      (sticky . t))))
#+end_src

#+begin_src elisp :noweb-ref doom-config
(defvar >org-capture-current-safari-tab)

(defun >org-capture-safari-tab-frame ()
  (interactive)
  (if-let ((>org-capture-current-safari-tab (>osa-safari-get-tab)))
      (yequake-toggle "org-capture-safari-tab")
    (message "No Safari tab to capture")))
#+end_src

#+begin_src elisp
(map! :leader "e" #'>org-capture-safari-tab)
(map! :leader "E" #'>org-capture-safari-tab-frame)
#+end_src

#+begin_src clojure :noweb-ref karabiner-rules
{:des "Right shift by itself calls >org-capture-safari-tab-fram"
 :rules [[:##right_shift :right_shift nil {:alone <<karabiner-e(cmd="(>org-capture-safari-tab-frame)")>>}]]}
#+end_src

** Config

#+begin_src clojure :tangle ~/.config/karabiner.edn
;; main contains multiple manipulator
;; each manipulator has a description and multiple rules

;; main                -> {:main [{:des "..." :rules [rule1 rule2 ...]}]}
;; manipulator         -> {:des "..." :rules [rule1 rule2 ...]}
;; manipulator's rules -> [rule1 rule2 ...]
;; {:main [{:des "a to 1, b to 2, c to insert 1 2 3"
;;          :rules [[:a :1] [:b :2] [:c [:1 :2 :3]]]}]}

;; or we can separate them into three manipulators
{:main [;; {:des "a to 1 only in chrome and safari" :rules [[:a :1 [:chrome]]]}

        {:des "caps_lock to esc when pressed alone, to ctrl as modifier"
         :rules [[:##caps_lock :left_control nil {:alone :escape}]
                 [:##left_control :caps_lock]]}

        {:des "hyper 1 to cleanup personal folder"
         :rules [[:!!1 "touch ~/Desktop/file.txt"]]}

        {:des "simultaneous j l press to F19"
         :rules [[[:j :l] "e '(prn (+ 1 1))'"]]}

        <<karabiner-rules>>]
 :applications {:chrome ["^com\\.google\\.Chrome$"]
                :safari ["^com\\.apple\\.Safari$"]}}

;; in rules [:a :1] -- [<from> <to>]
;; it means from key a to key 1
;; these keycode is just original karabiner keycode prefix with colon
;;
;; edn spec https://github.com/edn-format/edn
;; {;;;; define things
;;  ;; define devices
;;  :devices {:hhkb-bt [{:vendor_id 1278 :product_id 51966}]
;;            :hhkb [{:vendor_id 2131 :product_id 256}]}

;;  ;; define application identifiers
;;  :applications {:chrome ["^com\\.google\\.Chrome$"]
;;                 :chrome-canary [ "^com\\.google\\.Chrome\\.canary$"]
;;                 :chromes ["^com\\.google\\.Chrome$" "^com\\.google\\.Chrome\\.canary$"]}

;;  :input-sources {:squirrel {:input_mode_id "com.googlecode.rimeime.inputmethod.Squirrel"
;;                             :input_source_id "com.googlecode.rimeime.inputmethod.Squirrel.Rime"
;;                             :language "zh-Hans"}
;;                  :us {:input_mode_id ""
;;                       :input_source_id "com.apple.keylayout.US"
;;                       :language "en"}}

;;  :templates {:launch "osascript -e 'tell application \"Alfred 3\" to run trigger \"launch%s\" in workflow \"yqrashawn.workflow.launcher\" with argument \"\"'"}
;;  ;; define alias for modifers
;;  :modifiers {:11 [:left_command :left_control]
;;              :111 [:left_command :left_control :left_option]
;;              :1111 [:left_command :left_control :left_option :left_shift]
;;              :ccos [:left_command :left_control :left_option :left_shift]
;;              :11111 [:fn :left_command :left_control :left_option :left_shift]
;;              :spacebar-modifier {:mandatory [:left_command :left_control] :optional [:left_shift]}
;;              :fn&lcommand&lcontrol&loption&lshift [:fn :left_command :left_control :left_option :left_shift]}

;;  ;; define froms
;;  ;; use in <from>
;;  :froms {:1 {:key :d}
;;          ;; :2 {:key :d :modi :1}
;;          :3 {:key :d :modi :left_command}
;;          :4 {:key :d :modi [:left_command :right_shift]}
;;          :5 {:key :d :modi {:mandatory [:left_command :right_shift]}}
;;          :6 {:key :d :modi {:mandatory [:left_command :right_shift]
;;                             :optional [:caps_lock]}}
;;          :7 {:ckey :display_brightness_decrement}
;;          :8 {:ckey :display_brightness_decrement :modi :left_command}
;;          :9 {:pkey :button4 :modi :left_command}
;;          :10 {:sim [:a :b] :modi :left_command}
;;          :11 {:sim [:a :b]
;;               :simo {:interrupt true
;;                      :dorder :insensitive}
;;               :modi :left_command}}

;;  ;; define tos
;;  ;; use in <to>
;;  :tos {:macos-defin {:key :d :modifiers [:left_command :left_control]}
;;        :alf--search-help "osascript -e 'tell application \"Alfred 3\" to run trigger \"helpSearch\" in workflow \"com.tedwise.menubarsearch\" with argument \"\"'"}

;;  ;;;; helper function to generate things little bit quicker
;;  ;; quick define "layers" or "state" feature(use set_variable)
;;  ;; can use as conditions in rule list
;;  ;; {:<layer name> {:from <froms>}}
;;  :simlayers {:vi-mode {:key :d}}
;;  :simlayer-threshold 250

;;  ;; main list
;;  :main
;;  ;; [<from> <to>] or
;;  ;; [<from> <to> <conditions>] or
;;  ;; [<from> <to> <conditions> <other options>]
;;  ;; <from> can be keywords defined in froms or keycodes without `{:not-from true}`
;;  ;; <to> can be keywords defined in tos, keycodes without `{:not-to true}`, string (shell script)
;;  ;; <conditions> can be keywords defined in layers, devices, applications
;;  ;; <other options> {:other {:parameters {:to_delayed_action_delay_milliseconds 100 :basic.to_if_alone_timeout_milliseconds 500 :basic.to_if_held_down_threshold_milliseconds 250}} }
;;  [
;;   ;; {:des "a to 1" :rules [[:a :1]]}                             ;; a to 1
;;   ;; {:des "command a to control 1" :rules [:!Ca :!T1]}           ;; command a to control 1
;;   ;; {:des "my spacebar to control 1" :rules [:my-spacebar :!T1]} ;; my-spacebar to control 1
;;   ;; {:des "press b to insert 12" :rules [:b :1 :2]}              ;; key to key
;;   ;; {:des "c to example osascript" :rules [:c "osascript -e 'display dialog \"example apple script\"'"]} ;; key to shell script
;;   ;; {:des "d to 1 then example osascript" :rules [:d [:1 "osascript -e 'display dialog \"example apple script\"'"]]} ;; key to key then shell script
;;   ;; {:des "simultaneous e f to 3" :rules [[:e :f] :3]}                      ;; simultaneous key to key
;;   ;; {:des "g to 4 when variable vi-mode is 1" :rules [:g :4 :vi-mode]}      ;; vi-mode is 1
;;   ;; {:des "h to 5 when variable vi-mode is not 1" :rules [:h :5 :!vi-mode]} ;; vi-mode is 0
;;   ;; {:des "i to 6 only for device hhkb-bt" :rules [:i :6 :hhkb-bt]} ;; key to key in layer b (in layer a) specific to hhkb-bt device
;;   ;; {:des "j to 7 on hhkb-bt when variable vi-mode is 1" :rules [:j :7 [:vi-mode :hhkb-bt]]} ;; multiple condition
;;   ;; {:des "press h insert 8 then set variable some-mode to 0" :rules [:h [:8 {:set ["some-mode" 0]}]]}
;;   ] ;; h to 8 and set_variable

;;  ;; code won't read cheatsheet section
;;  ;; ! stand for mandatory
;;  ;; # stand for optional
;;  ;; C T O S for left command control optional shift
;;  ;; F for fn
;;  ;; need to prefix C T O S F with ! or #
;;  :cheatsheet {:!Ca "command a" ;; mandatory left_command
;;               :!Ta "control a" ;; mandatory left_control
;;               :!Oa "option a"
;;               :!Sa "shift a"
;;               :#Sa "shift a" ;; keycode a, optional left_shift
;;               :!CTOa "command control option a"
;;               :!Cspacebar "command space"
;;               :!Fa "fn a"
;;               :##a "keycode a optional any"
;;               :!!a "mandatory hyper(control command option shift) a "}}
#+end_src
** Spaces

#+begin_src clojure :noweb-ref karabiner-rules
{:des "Move between spaces"
 :rules [[:!CTh <<karabiner-shell(cmd="yabai -m space --focus prev")>>]
         [:!CTl <<karabiner-shell(cmd="yabai -m space --focus next")>>]]}
#+end_src

** goku

#+begin_src nix :noweb-ref system-packages
goku
#+end_src

#+begin_src elisp :noweb-ref org-post-tangle-environment-hook
(>start-process "goku")
#+end_src

** Install

#+begin_src nix :noweb-ref darwin-config
services.karabiner-elements = {
  enable = true;
};
#+end_src

** TODO errors in e evaluations are swallowed
** COMMENT Create fake notification

#+begin_src elisp :noweb-ref doom-config
(defun >foobar-notification ()
  (>osa-notify "foobar" :title "a title" :subtitle "a subtitle"))
#+end_src

#+begin_src clojure :noweb-ref karabiner-rules
{:des ""
 :rules [[:##right_shift :right_shift nil {:alone "e '(>foobar-notification)'"}]]}
#+end_src

* Clojure environment
** Inject CIDER dependencies and middleware boot task

:tangle ~/.boot/profile.boot :ns 'nil
#+BEGIN_SRC clojure
(require 'boot.repl)

(swap! boot.repl/*default-dependencies*
       concat '[[cider/cider-nrepl "0.25.0"]
                [nrepl "0.7.0"]
                [refactor-nrepl/refactor-nrepl "2.5.0"]
                [clj-commons/pomegranate "1.2.0"]])

(swap! boot.repl/*default-middleware*
       conj
       'cider.nrepl/cider-middleware
       'refactor-nrepl.middleware/wrap-refactor)


(set-env! :dependencies '[;; [spyscope "0.1.6"]
                          [mvxcvi/puget "1.1.2"]]
          :repositories #(conj % ["elit-maven" {:url "s3p://elit-maven/repo/"}])
          :wagons '[[s3-wagon-private "1.3.2"]])
   #+END_SRC

** taps
   :tangle ~/.boot/profile.boot :ns 'nil
   #+BEGIN_SRC clojure
     (require '[puget.printer :as puget])

     (intern 'clojure.core 'pp puget.printer/cprint)

     (add-tap
      (bound-fn*
       (fn [{:keys [filename value pp]}]
         (when (and pp value)
           (puget.printer/cprint value))
         (when filename
           (spit (str filename ".edn")
                 (str (with-out-str (clojure.pprint/pprint value)) "\n")
                 :append true)))))
   #+END_SRC

** Add spyscope to local projects
   :tangle ~/.boot/profile.boot :ns 'nil
   #+BEGIN_SRC clojure
     ;; (require 'spyscope.core)
     ;; (boot.core/load-data-readers!)
   #+END_SRC

** Debug macro

   (defmacro debug
   "Print debug info."
   [& variables]
   (let [datetime "2011-12-17 01:59:37"
   naked-msg (str "Debug: " datetime " in " *file* "@" (:line
   (meta &form)))]
   (if (empty? variables)
   (println naked-msg)
   `(let [kvs# (zipmap (map #(str % " =>") '~variables)
   (vector ~@variables))]
   (println (str ~naked-msg ":") kvs#)))))

** deps

#+BEGIN_SRC clojure :tangle ~/.clojure/deps.edn :ns 'nil
;; see https://github.com/seancorfield/dot-clojure
{:mvn/repos {"sonatype" {:url "https://oss.sonatype.org/content/repositories/snapshots/"}
             "cognitect-dev-tools" {:url "https://dev-tools.cognitect.com/maven/releases/"}}
 :aliases
 { ;; pull in specific versions of Clojure:
  :1.0 {:override-deps {org.clojure/clojure {:mvn/version "1.0.0"}}}
  :1.1 {:override-deps {org.clojure/clojure {:mvn/version "1.1.0"}}}
  :1.2 {:override-deps {org.clojure/clojure {:mvn/version "1.2.1"}}}
  :1.3 {:override-deps {org.clojure/clojure {:mvn/version "1.3.0"}}}
  :1.4 {:override-deps {org.clojure/clojure {:mvn/version "1.4.0"}}}
  :1.5 {:override-deps {org.clojure/clojure {:mvn/version "1.5.1"}}}
  :1.6 {:override-deps {org.clojure/clojure {:mvn/version "1.6.0"}}}
  :1.7 {:override-deps {org.clojure/clojure {:mvn/version "1.7.0"}}}
  :1.8 {:override-deps {org.clojure/clojure {:mvn/version "1.8.0"}}}
  :1.9 {:override-deps {org.clojure/clojure {:mvn/version "1.9.0"}}}
  :1.10 {:override-deps {org.clojure/clojure {:mvn/version "1.10.0"}}}
  :1.10.1 {:override-deps {org.clojure/clojure {:mvn/version "1.10.1"}}}
  :master {:override-deps {org.clojure/clojure {:mvn/version "1.11.0-master-SNAPSHOT"}}}

  ;; testing and debugging tools:
  ;; :test {:extra-paths ["test" "src/test/clojure"]
  ;;        :extra-deps {org.clojure/test.check {:mvn/version "RELEASE"}}}
  ;; - see https://github.com/cognitect-labs/test-runner
  ;; - run your tests: clj -A:test:runner
  :runner {:extra-deps {com.cognitect/test-runner
                        {:git/url "https://github.com/cognitect-labs/test-runner"
                         :sha "3cb0a9daf1cb746259dc8309b218f9211ad3b33b"}}
           :main-opts ["-m" "cognitect.test-runner"
                       "-d" "test"
                       "-d" "src/test/clojure"]}
  ;; see https://github.com/jonase/eastwood#running-eastwood-in-a-repl
  :eastwood {:extra-deps {jonase/eastwood {:mvn/version "RELEASE"}}
             :main-opts ["-m" "eastwood.lint" "{:source-paths,[\"src\"],:test-paths,[\"test\"]}"]}

  ;; - see https://github.com/clojure-expectations/expectations
  ;; - and https://github.com/clojure-expectations/clojure-test
  ;; - run your expectations: clj -A:test:expect:runner
  :expect {:extra-deps {expectations/expectations {:mvn/version "RELEASE"}
                        expectations/clojure-test {:mvn/version "RELEASE"}}}
  ;; - see https://github.com/hugoduncan/criterium/
  ;; - (require '[criterium.core :refer [bench]])
  ;; - (bench (your-expression))
  :bench {:extra-deps {criterium/criterium {:mvn/version "RELEASE"}}}
  ;; - see https://github.com/clojure-goes-fast/clj-memory-meter
  ;; - (require '[clj-memory-meter.core :as mm])
  ;; - (mm/measure (your-expression))
  :measure {:extra-deps {com.clojure-goes-fast/clj-memory-meter {:mvn/version "RELEASE"}}}
  ;; - see https://github.com/Olical/depot
  :outdated {:extra-deps {olical/depot {:mvn/version "1.8.4"}}
             :main-opts ["-m" "depot.outdated.main"]}

  ;; REPL-related tools:
  ;; - start a modern nREPL server on a random available port:
  ;; :nrepl {:extra-deps {nrepl/nrepl {:mvn/version "0.8.3"}
  ;;                      refactor-nrepl/refactor-nrepl {:mvn/version "2.5.0"}
  ;;                      cider/cider-nrepl {:mvn/version "0.25.5"}}
  ;;         :main-opts ["-m" "nrepl.cmdline"
  ;;                     "--middleware"
  ;;                     "[com.gfredericks.debug-repl/wrap-debug-repl,refactor-nrepl.middleware/wrap-refactor,cider.nrepl/cider-middleware]"]}
  ;; - start a legacy nREPL server on port 60606:
  :nrepl/old {:extra-deps {org.clojure/tools.nrepl {:mvn/version "RELEASE"}}
              :main-opts ["-e" "(require,'[clojure.tools.nrepl.server,:refer,[start-server]]),(start-server,:port,60606)"]}
  ;; - start a Socket REPL on port 50505:
  :socket {:jvm-opts ["-Dclojure.server.repl={:port,50505,:accept,clojure.core.server/repl}"]}
  ;; - start a Socket pREPL on port 40404:
  :prepl {:jvm-opts ["-Dclojure.server.repl={:port,40404,:accept,clojure.core.server/io-prepl}"]}
  ;; - see https://atom.io/packages/proto-repl
  ;; - for use with Atom/ProtoREPL: clj -A:proto:nrepl
  :proto {:extra-deps {proto-repl/proto-repl {:mvn/version "RELEASE"}}}
  ;; - see https://github.com/bhauman/rebel-readline
  ;; - start a Rebel Readline REPL:
  :rebel {:extra-deps {com.bhauman/rebel-readline {:mvn/version "RELEASE"}}
          :main-opts ["-m" "rebel-readline.main"]}
  ;; - see https://github.com/stuarthalloway/reflector
  :reflect
  {:extra-deps {com.stuarthalloway/reflector
                {:git/url "https://github.com/stuarthalloway/reflector"
                 :sha "93a0c19b4526c1180959e940202928d35e5c3cef"}}}
  ;; - see https://github.com/bbatsov/compliment
  :comp {:extra-deps {compliment/compliment {:mvn/version "RELEASE"}}}
  ;; - see https://github.com/cognitect-labs/REBL-distro
  ;; - you need to download the REBL JAR (and update the local/root below)
  ;; - you need to be using Clojure 1.10 and either
  ;; - - Oracle JDK 8/Zulu OpenJDK 8 w/JavaFX -- use :rebl-8
  ;; - - OpenJDK 11 -- use :rebl-11
  ;; - - on Windows, use the -win versions of these aliases
  ;; - - (assumes you have REBL as /Developer/REBL/latest/REBL.jar
  ;; - - on macOS/Linux and C:\Developer\REBL\latest\REBL.jar on Windows)
  :rebl-8
  {:extra-deps {org.clojure/core.async {:mvn/version "0.4.490"}
                ;; deps for file datafication (0.9.149 or later)
                org.clojure/data.csv {:mvn/version "0.1.4"}
                org.clojure/data.json {:mvn/version "0.2.3"}
                org.yaml/snakeyaml {:mvn/version "1.23"}
                com.cognitect/rebl
                ;; adjust to match your install location
                {:local/root "/Developer/REBL/latest/REBL.jar"}}
   :main-opts ["-m" "cognitect.rebl"]}
  :rebl-11
  {:extra-deps {org.clojure/core.async {:mvn/version "0.4.490"}
                ;; deps for file datafication (0.9.149 or later)
                org.clojure/data.csv {:mvn/version "0.1.4"}
                org.clojure/data.json {:mvn/version "0.2.3"}
                org.yaml/snakeyaml {:mvn/version "1.23"}
                com.cognitect/rebl
                ;; adjust to match your install location
                {:local/root "/Developer/REBL/latest/REBL.jar"}
                org.openjfx/javafx-fxml     {:mvn/version "11.0.1"}
                org.openjfx/javafx-controls {:mvn/version "11.0.1"}
                org.openjfx/javafx-graphics {:mvn/version "11.0.1"}
                org.openjfx/javafx-media    {:mvn/version "11.0.1"}
                org.openjfx/javafx-swing    {:mvn/version "11.0.1"}
                org.openjfx/javafx-base     {:mvn/version "11.0.1"}
                org.openjfx/javafx-web      {:mvn/version "11.0.1"}}
   :main-opts ["-m" "cognitect.rebl"]}
  :rebl-8-win
  {:extra-deps {org.clojure/core.async {:mvn/version "0.4.490"}
                ;; deps for file datafication (0.9.149 or later)
                org.clojure/data.csv {:mvn/version "0.1.4"}
                org.clojure/data.json {:mvn/version "0.2.3"}
                org.yaml/snakeyaml {:mvn/version "1.23"}
                com.cognitect/rebl
                ;; adjust to match your install location
                {:local/root "C:\\Developer\\REBL\\latest\\REBL.jar"}}
   :main-opts ["-m" "cognitect.rebl"]}
  :rebl-11-win
  {:extra-deps {org.clojure/core.async {:mvn/version "0.4.490"}
                ;; deps for file datafication (0.9.149 or later)
                org.clojure/data.csv {:mvn/version "0.1.4"}
                org.clojure/data.json {:mvn/version "0.2.3"}
                org.yaml/snakeyaml {:mvn/version "1.23"}
                com.cognitect/rebl
                ;; adjust to match your install location
                {:local/root "C:\\Developer\\REBL\\latest\\REBL.jar"}
                org.openjfx/javafx-fxml     {:mvn/version "11.0.1"}
                org.openjfx/javafx-controls {:mvn/version "11.0.1"}
                org.openjfx/javafx-graphics {:mvn/version "11.0.1"}
                org.openjfx/javafx-media    {:mvn/version "11.0.1"}
                org.openjfx/javafx-swing    {:mvn/version "11.0.1"}
                org.openjfx/javafx-base     {:mvn/version "11.0.1"}
                org.openjfx/javafx-web      {:mvn/version "11.0.1"}}
   :main-opts ["-m" "cognitect.rebl"]}

  :deps           ; to get access to clojure.tools.deps.alpha.repl/add-lib
  ;; - now you can add new deps to a running REPL:
  ;; (require '[clojure.tools.deps.alpha.repl :refer [add-lib]])
  ;; (add-lib 'some/library {:mvn/version "RELEASE"})
  ;; - and you can git deps too; here's how to get the master version of a lib:
  ;; (require '[clojure.tools.gitlibs :as gitlibs])
  ;; (defn load-master [lib]
  ;;   (let [git (str "https://github.com/" lib ".git")]
  ;;    (add-lib lib {:git/url git :sha (gitlibs/resolve git "master")})))
  ;; - e.g., using the GitHub path (not the usual Maven group/artifact):
  ;; (load-master 'clojure/tools.trace)
  {:extra-deps {org.clojure/tools.deps.alpha
                {:git/url "https://github.com/clojure/tools.deps.alpha"
                 :sha "148cab8f154711f8495bd632ebdc53a14dff7f09"}}}
  :spec2                               ; to get access to the latest spec-alpha2
  {:extra-deps {org.clojure/spec-alpha2
                {:git/url "https://github.com/clojure/spec-alpha2"
                 :sha "9dc3344bfe6d13213bdb15ca2e7680cd8eb439e3"}}}
  ;; start the Liquid Clojure editor
  ;; - see https://github.com/mogenslund/liquid
  :liquid
  {:extra-deps {mogenslund/liquid {:mvn/version "RELEASE"}}
   :main-opts ["-m" "dk.salza.liq.core"]}

  ;; project creation from templates:
  ;; - see https://github.com/seancorfield/clj-new
  ;; - create an application project:
  ;;   - clj -A:new app myname/myapp
  ;;   - cd myapp
  ;;   - clj -m myname.myapp # run it!
  ;;   - clj -A:test:runner # run the tests!
  ;; - create a library project:
  ;;   - clj -A:new lib myname/my-cool-lib
  ;;   - cd my-cool-lib
  ;;   - clj -A:test:runner # run the tests!
  :new {:extra-deps {seancorfield/clj-new {:mvn/version "RELEASE"}}
        :main-opts ["-m" "clj-new.create"]
        :exec-fn clj-new/create
        :exec-args {:template "app"}}

  ;; uberjar building:
  ;; - see https://github.com/seancorfield/depstar for a minimalist approach:
  ;;   - clj -A:uberjar result.jar
  ;; - to run it:
  ;;   - java -cp result.jar clojure.main -m mymain.namespace
  ;; - build a library JAR:
  ;;   - clj -A:jar result-lib.jar
  :uberjar {:extra-deps {seancorfield/depstar {:mvn/version "RELEASE"}}
            :main-opts ["-m" "hf.depstar.uberjar"]}
  :jar {:extra-deps {seancorfield/depstar {:mvn/version "RELEASE"}}
        :main-opts ["-m" "hf.depstar.jar"]}

  ;; - inspired by Ruby's -pne command line option which lets you process lines of stdin bound to $_
  ;; - usage: cat file-of-numbers.txt | clj -Mpne -e '($ (-> $_ Long/parseLong inc))'
  :pne {:main-opts,["-e","(defmacro,$,[&,body],(list,'while,(list,'when-let,'[$_,(read-line)],(let,[v,(gensym)],(list,'let,(vector,v,(list*,'do,body)),(list,'println,v))),'$_)))"]}

  :repl {:main-opts ["-e" "(require,'[clojure.main,:as,m])(m/repl,:init,#(apply,require,m/repl-requires),:eval,(fn,[form],(do,(require,'[clojure.pprint,:refer,[pp]])(eval,form))))"]}

  :rebl {:extra-deps {com.cognitect/rebl          {:mvn/version "0.9.242"}
                      org.openjfx/javafx-fxml     {:mvn/version "15-ea+6"}
                      org.openjfx/javafx-controls {:mvn/version "15-ea+6"}
                      org.openjfx/javafx-swing    {:mvn/version "15-ea+6"}
                      org.openjfx/javafx-base     {:mvn/version "15-ea+6"}
                      org.openjfx/javafx-web      {:mvn/version "15-ea+6"}}
         :main-opts ["-m" "cognitect.rebl"]}

  :rebl-jdk8 {:extra-deps {com.cognitect/rebl {:mvn/version "0.9.242"}}
              :main-opts ["-m" "cognitect.rebl"]}

  :debug-tools {:extra-deps {hashp/hashp {:mvn/version "0.2.0"}
                             com.gfredericks/debug-repl {:mvn/version "0.0.11"}}}

  :cider/full-stack {:extra-deps {cider/cider-nrepl {:mvn/version "0.25.5"}
                                  nrepl/nrepl {:mvn/version "0.8.3"}
                                  refactor-nrepl/refactor-nrepl {:mvn/version "2.5.0"}}
                     :main-opts ["-m" "nrepl.cmdline"
                                 "--middleware" "[cider.nrepl/cider-middleware,refactor-nrepl.middleware/wrap-refactor,shadow.cljs.devtools.server.nrepl/middleware]"]}

  :cider/clj {:extra-deps {cider/cider-nrepl {:mvn/version "0.25.5"}
                           nrepl/nrepl {:mvn/version "0.8.3"}
                           refactor-nrepl/refactor-nrepl {:mvn/version "2.5.0"}}
              :main-opts ["-m" "nrepl.cmdline"
                          "--middleware" "[cider.nrepl/cider-middleware,refactor-nrepl.middleware/wrap-refactor]"]}

  :pathom/viz {:extra-deps {com.wsscode/pathom-viz-connector {:mvn/version "2021.07.15-1"}}}

  :local/fulcro {:override-deps {com.fulcrologic/fulcro {:local/root "../fulcro"}}}
  :local/pathom3 {:override-deps {com.wsscode/pathom3 {:local/root "../pathom3"}}}
  :local/workshop {:override-deps {com.jordanrivertechnology/workshop {:local/root "../workshop"}}}
  :local/carpenter {:override-deps {com.jordanrivertechnology/carpenter {:local/root "../carpenter"}}}
  :local/nexus {:override-deps {com.nivekuil/nexus {:local/root "../nexus"}}}
  :local/fulcro-rad-datomic-ions-adapter {:override-deps {com.jordanrivertechnology/fulcro-rad-datomic-ions-adapter {:local/root "../fulcro-rad-datomic-ions-adapter"}}}

  }}
#+END_SRC

** shadow

#+BEGIN_SRC clojure :tangle ~/.shadow-cljs/config.edn :ns 'nil
{:deps-aliases [:dev #_:local-fulcro :debug-tools]}
#+END_SRC

** datomic
#+begin_src clojure :tangle ~/.datomic/dev-local.edn
{:storage-dir "/Users/donavan/.datomic/data"}
#+end_src

** clj-kondo

#+begin_src clojure :tangle ~/.config/clj-kondo/config.edn
{:lint-as {com.fulcrologic.fulcro.components/defsc clojure.core/defn
           com.fulcrologic.fulcro.mutations/defmutation clojure.core/defn}}
#+end_src

** maven settings

:tangle ~/.m2/settings.xml
#+begin_src xml
<settings xmlns="http://maven.apache.org/SETTINGS/1.2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.2.0 http://maven.apache.org/xsd/settings-1.2.0.xsd">
  <servers>
    <server>
      <id>cognitect-dev-tools</id>
      <username>donavan@jordanriveradvisors.com</username>
      <password>{{ see onepassword }}</password>
    </server>
  </servers>
</settings>
#+end_src

* shell
** theme

#+BEGIN_SRC sh :tangle ~/.zshrc
source "$(brew --prefix antigen)/share/antigen/antigen.zsh"

autoload antigen

antigen use oh-my-zsh
antigen bundle git
antigen bundle zsh-users/zsh-completions
antigen bundle zdharma-continuum/fast-syntax-highlighting
antigen bundle zsh-users/zsh-autosuggestions
antigen bundle zsh-users/zsh-history-substring-search
antigen bundle agkozak/zsh-z

SPACESHIP_PROMPT_ORDER=(
    user          # Username section
    dir           # Current directory section
    host          # Hostname section
    git           # Git section (git_branch + git_status)
    hg            # Mercurial section (hg_branch  + hg_status)
    exec_time     # Execution time
    line_sep      # Line break
    vi_mode       # Vi-mode indicator
    jobs          # Background jobs indicator
    exit_code     # Exit code section
    char          # Prompt character
)
SPACESHIP_PROMPT_ADD_NEWLINE=false
SPACESHIP_CHAR_SYMBOL="❯"
SPACESHIP_CHAR_SUFFIX=" "
antigen theme denysdovhan/spaceship-prompt

antigen apply
#+END_SRC

** config

#+begin_src sh :tangle ~/.zshrc
echo loading zsh config
#+end_src

** Completion

*** Setup

Mostly put together from information here:
https://github.com/zsh-users/zsh-completions/blob/master/zsh-completions-howto.org
https://wikimatze.de/writing-zsh-completion-for-padrino/

Ensure completions dir exists and add it to $fpath, zsh's function path _array_ (scalar version is at $FPATH)
#+begin_src sh :tangle ~/.zshrc
mkdir -p ~/bin/completions
fpath=($HOME/bin/completions $fpath)
#+end_src

Initiate the completion framework
#+begin_src sh :tangle ~/.zshrc
autoload -U compinit
compinit
#+end_src

It seems that countless recommendations on the web to run `autoload -Uz compinit && compinit` have resulted in everyone's zsh autocomplete initialization running that. I have no idea what it does, however experimentation has shown that running "compinit" clobbers any completions you already had configured. Which totally sucks if you configure auto completion for multiple tools in your zshrc. Prevent any possible issues by aliasing compinit.
#+begin_src sh :tangle ~/.zshrc
alias compinit="echo no more compinit!"
#+end_src

*** Babashka

#+begin_src sh :tangle ~/bin/completions/_bb
#compdef bb
local -a matches
matches=(`bb tasks |tail -n +3 |cut -f1 -d ' '`)
_describe 'command' matches
#+end_src

** History

#+begin_src sh :tangle ~/.zshrc
HISTFILE=$HOME/.zsh_history
HISTSIZE=100000
SAVEHIST=$HISTSIZE

setopt hist_ignore_all_dups # remove older duplicate entries from history
setopt hist_reduce_blanks # remove superfluous blanks from history items
setopt inc_append_history # save history entries as soon as they are entered
setopt share_history # share history between different instances of the shell
setopt auto_cd # cd by typing directory name if it's not a command
# setopt correct_all # autocorrect commands
setopt auto_list # automatically list choices on ambiguous completion
setopt auto_menu # automatically use menu completion
setopt always_to_end # move cursor to end if word had one match
zstyle ':completion:*' menu select # select completions with arrow keys
zstyle ':completion:*' group-name '' # group results by category
zstyle ':completion:::::' completer _expand _complete _ignored _approximate # enable approximate matches for completion

bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down

bindkey '^l' forward-word
bindkey '^h' backward-word

# HISTFILE=~/.histfile
# HISTSIZE=1000
# SAVEHIST=1000
# # End of lines configured by zsh-newuser-install
# # The following lines were added by compinstall
# zstyle :compinstall filename '/Users/donavan/.zshrc'

# autoload -Uz compinit
# compinit
# # End of lines added by compinstall
#+end_src

** aliases

#+BEGIN_SRC sh :tangle ~/.zshrc
alias cat="bat"
alias p="prettybat"
alias vi="nvim"
#+END_SRC

** env

*** path

#+name: env-path
| PATH | $PATH:$HOME/bin           |
| PATH | $PATH:/opt/local/sbin     |
| PATH | $PATH:/Library/TeX/texbin |

*** XDG

These are the defaults but are here so I can remember them and echo them when needed

#+name: env-xdg
| XDG_CONFIG_HOME | $HOME/.config      |
| XDG_CACHE_HOME  | $HOME/.cache       |
| XDG_DATA_HOME   | $HOME/.local/share |
| XDG_STATE_HOME  | $HOME/.local/state |

*** AWS

#+name: env-aws
| AWS_DEFAULT_REGION | us-east-2 |
| AWS_REGION         | us-east-2 |
| AWS_PROFILE        | profile-foo |

*** Java

#+name: env-java
| JAVA_TOOL_OPTIONS | $JAVA_TOOL_OPTIONS -XX:-OmitStackTraceInFastThrow           |
| JAVA_TOOL_OPTIONS | $JAVA_TOOL_OPTIONS -Dapple.awt.UIElement=true               |
| JAVA_HOME         | /Library/Java/JavaVirtualMachines/zulu-11.jdk/Contents/Home |

*** zshenv and zprofile

#+name: set-env
#+begin_src elisp :var env-block='()
(cl-flet ((process-env-var (env-var)
            (seq-let (key value) env-var
              (s-lex-format "export ${key}=\"${value}\" \nlaunchctl setenv ${key} \"$${key}\"\n"))))
  (->> env-block
       (concat "env-")
       (org-babel-ref-resolve)
       (mapcar #'process-env-var)
       (s-join "\n")))
#+end_src

#+begin_src sh :tangle ~/.zshenv
# [[ -o login ]] && export PATH='/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin'
source ~/.zprofile
#+end_src

#+begin_src sh :tangle ~/.zprofile
<<set-env(env-block="path")>>
<<set-env(env-block="xdg")>>
<<set-env(env-block="aws")>>
<<set-env(env-block="java")>>
<<set-env(env-block="chemacs")>>
<<zprofile>>
#+end_src

**** TODO would be nice to be able to split up the tables that hold path env vars

This won't work because we're using ~org-babel-ref-resolve~ and it's finding the first one. If there is another identifier that we can use to collect them all and then process them we could split up the path tables per client like we do with noweb refs
#+name: env-path
| PATH | $PATH:$HOME/bin |

#+name: env-path
| PATH | $PATH:/tmp |

** COMMENT 1Password

#+begin_src sh
eval $(op signin my)
#+end_src

** functions
*** 1password aws integration

op get item 'JRA AWS' --fields "aws_access_key_id,aws_secret_access_key" | 1password-aws

#+begin_src clojurescript :shebang #!/usr/bin/env bb :tangle ~/bin/1password-aws
(require '[cheshire.core :as json])
(require '[clojure.java.io :as io])
(require '[clojure.set :refer [rename-keys]])

(defn >fn
  [value]
  (-> value
      (assoc "Version" 1)
      (rename-keys {"aws_access_key_id" "AccessKeyId"
                    "aws_secret_access_key" "SecretAccessKey"})))

;;One can do the following as well (note the last nil) without the -o arg to bb
(-> *in*
    json/parse-stream
    >fn
    (json/generate-stream (io/writer *out*) {:pretty true}))
nil

;; (-> *in*
;;     json/parse-stream
;;     >fn
;;     (json/generate-string #_(io/writer *out*) {:pretty true}))
#+end_src
*** git annex

#+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/annex-close
git annex add .
git annex lock .
git annex copy --all --to=rsync
git annex sync
#+end_src

#+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/annex-init-rsync
if [[ $1 = annex-* ]]
then
  git annex initremote rsync type=rsync rsyncurl=rsync:$1 encryption=shared
else
  echo "ARG must start with 'annex-'"
fi
#+end_src

*** Clojure

#+begin_src clojure :shebang "#!/usr/bin/env bb" :tangle ~/bin/bb-repl
(ns bb-repl
  (:require
   [babashka.deps :refer [clojure]]
   [babashka.process :refer [shell]]))

(let [deps (-> (shell {:out :string} "bb print-deps") :out read-string)
      clojure-args (list* "-Sdeps" deps *command-line-args*)]
  (if-let [proc (clojure clojure-args)]
    (-> @proc :exit (System/exit))
    (System/exit 0)))
#+end_src

*** doom

#+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/doom
~/.config/doom-emacs/bin/doom "$1"
#+end_src

*** Emacs

#+begin_src sh :shebang #!/bin/zsh :tangle ~/bin/e
/Applications/Emacs.app/Contents/MacOS/bin/emacsclient -e -n "$@"
#+end_src

#+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/spacemacs
open /Applications/Emacs-alt-icon.app -n --args --with-profile spacemacs
#+end_src

 ~/bin/emacs
#+begin_src sh :shebang "#!/bin/bash" :tangle no
open /Applications/Emacs.app --args --with-profile emacs
#+end_src

#+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/emacs-config-editor
open /Applications/Emacs-alt-icon.app -n --args --with-profile emacs
#+end_src

#+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/emacs-raw
open /Applications/Emacs.app -n --args --with-profile raw
#+end_src

*** elit
**** elit-cli

  #+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/elit
      . aws_creds
      /usr/local/bin/elit $*
  #+end_src

**** db connections

    #+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/bt-manatee
    pgcli -h localhost -p 5432 manatee postgres
    #+end_src

    #+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/bt-lionel
    pgcli -h localhost -p 5432 lionel postgres
    #+end_src

    #+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/bt-accounts
    mycli -h localhost -P 3306 -u root -p secret-password accounts
    #+end_src

**** ebtool

   #+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/ebtool
     if cd ~/src/ebtool ; then
	 . aws_creds
	 ./ebtool $*
     fi
   #+end_src

**** beethoven

   #+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/fire_up
     if cd ~/src/beethoven ; then
	 . aws_creds
	 ./fire-up.sh $*
     fi
   #+end_src

*** boot
  :tangle ~/bin/boot
  #+begin_src sh :shebang "#!/bin/bash"
    . aws_creds
    /usr/local/bin/boot $*
  #+end_src

*** gpg decrypt folder

  #+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/encrypt-folder
    read -rsp "Enter passphrase: " PASSPHRASE

    for FILE in $(find "$1" -name '*.gpg'); do
	echo "Extracting $FILE to ${FILE%.gpg}"
	echo "$PASSPHRASE" | gpg --passphrase-fd 0 --batch -d --output "${FILE%.gpg}" "$FILE"
    done
  #+end_src

*** sync movies

    #+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/sync-movies
      rsync -ahi proxy:/root/Downloads/ ~/Movies/movies\ and\ series/
    #+end_src

*** verify
    #+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/verify
sudo xattr -rd com.apple.quarantine $0
    #+end_src

*** edn pretty-print

#+begin_src clojure :shebang "#!/usr/local/bin/planck" :tangle ~/bin/edn-pp
(ns eq.core
  (:require [cljs.pprint :refer [pprint]]
            [cljs.reader :as edn]
            [planck.core :as planck :refer [*in* slurp]]
            [clojure.string :as string]))

(def in (-> *in* slurp edn/read-string))

(->> in
     (take-while identity)
     (string/join)
     (edn/read-string)
     (pprint))
#+end_src

*** JRA dev

#+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/jra
cd ~/src/yarmouk && \
    bb start --local carpenter --local workshop
#+end_src

*** audio

**** wav to aiff

#+begin_src clojure :shebang "#!/usr/bin/env bb" :tangle ~/bin/wav-to-aiff
(require '[clojure.java.shell :refer [sh]])
(require '[cheshire.core :as json])
(doseq [filename *command-line-args*]
  (let [output-filename (clojure.string/replace filename #".wav" ".aiff")
        info (-> (sh "ffprobe"
                     "-hide_banner"
                     "-loglevel" "panic"
                     "-show_streams"
                     "-of" "json"
                     filename)
                 :out
                 (json/parse-string true)
                 :streams
                 (nth 0))
        bit-depth (-> info :bits_per_sample str)
        sample-format (-> info :sample_fmt str)
        sample-rate (-> info :sample_rate str)]
    (sh "ffmpeg"
        "-hide_banner"
        "-i" filename
        "-ar" sample-rate
        "-acodec" (str "pcm_s" bit-depth "be")
        output-filename)))
#+end_src

**** split audio

#+begin_src sh :shebang "#!/bin/bash" :tangle ~/bin/split-audio
ffmpeg -i "$1" -f segment -segment_time "$2" -c copy "$1"%03d.mp3
#+end_src

** audio conversion

  #+BEGIN_SRC sh :tangle ~/.zshrc
  #find . -type f -name "*.mkv" -exec bash -c 'FILE="$1"; ffmpeg -i "${FILE}" -vn -c:a libmp3lame -y "${FILE%.mkv}.mp3";' _ '{}' \;

  #split file
  function split-audio {
      ffmpeg -i "$1" -f segment -segment_time "$2" -c copy "$1"%03d.mp3
      # ffmpeg -i "$1" -f segment -segment_time 3 -c copy out%03d.mp3
  }

  function convert-mkv-video-to-opus-audio {
      find . -type f -name "*.mkv" -exec bash -c 'FILE="$1"; ffmpeg -i "${FILE}" -c:a copy "${FILE%.mkv}.opus";' _ '{}' \;
  }

  function convert-opus-to-aac {
      find . -type f -name "*.webm" -exec bash -c 'FILE="$1"; ffmpeg -i "${FILE}" -c:a libfdk_aac -vbr 5 -cutoff 18000 "${FILE%.webm}.m4a";' _ '{}' \;
  }

  function convert-flac-to-alac {
      find . -type f -name "*.flac" -exec bash -c 'FILE="$1"; ffmpeg -i "${FILE}" -acodec alac "${FILE%.flac}.m4a";' _ '{}' \;
  }
  function TODO-not-working-raw-to-m4a {
      ffmpeg -f u16le -ar 44100 -ac 1 -i input.raw
  }
  #+END_SRC

* Yabai

#+begin_src nix :noweb-ref darwin-config
services.yabai = {
  enable = true;
  package = pkgs.yabai;
  enableScriptingAddition = true;
  # config = {
  #   focus_follows_mouse          = "autoraise";
  #   mouse_follows_focus          = "off";
  #   window_placement             = "second_child";
  #   window_opacity               = "off";
  #   window_opacity_duration      = "0.0";
  #   window_border                = "on";
  #   window_border_placement      = "inset";
  #   window_border_width          = 2;
  #   window_border_radius         = 3;
  #   active_window_border_topmost = "off";
  #   window_topmost               = "on";
  #   window_shadow                = "float";
  #   active_window_border_color   = "0xff5c7e81";
  #   normal_window_border_color   = "0xff505050";
  #   insert_window_border_color   = "0xffd75f5f";
  #   active_window_opacity        = "1.0";
  #   normal_window_opacity        = "1.0";
  #   split_ratio                  = "0.50";
  #   auto_balance                 = "on";
  #   mouse_modifier               = "fn";
  #   mouse_action1                = "move";
  #   mouse_action2                = "resize";
  #   layout                       = "bsp";
  #   top_padding                  = 36;
  #   bottom_padding               = 10;
  #   left_padding                 = 10;
  #   right_padding                = 10;
  #   window_gap                   = 10;
  # };

  # extraConfig = ''
  #       # rules
  #       yabai -m rule --add app='System Preferences' manage=off

  #       # Any other arbitrary config here
  #     '';
};
#+end_src

** SketchyBar

#+begin_src nix :noweb-ref system-packages
sketchybar
#+end_src

** App management

#+name: yabai-unmanaged-apps
| ^System Preferences$ |
| ^Finder$             |
| Steam                |

*** Rule

#+name: yabai-app-management
#+begin_src elisp :var apps=yabai-unmanaged-apps
(->> apps
     (-map (fn (`(,s))
             (s-lex-format "app='${s}'")))
     (s-join " ")
     (concat "yabai -m rule --add manage=off "))
#+end_src

** Config

#+name: yabai-config
| mouse_follows_focus         | on           | test |
| focus_follows_mouse         | autoraise    |      |
| window_origin_display       | default      |      |
| window_placement            | second_child |      |
| window_zoom_persist         | on           |      |
| window_topmost              | off          |      |
| window_shadow               | off          |      |
| window_animation_frame_rate | 120          |      |
| window_opacity_duration     | 0.0          |      |
| active_window_opacity       | 1.0          |      |
| normal_window_opacity       | 0.90         |      |
| window_opacity              | off          |      |
| insert_feedback_color       | 0xffff0000   |      |
| active_window_border_color  | 0xff00ff00   |      |
| normal_window_border_color  | 0xff0000ff   |      |
| window_border_width         | 0            |      |
| window_border_radius        | 0            |      |
| window_border_blur          | off          |      |
| window_border_hidpi         | on           |      |
| window_border               | off          |      |
| split_ratio                 | 0.50         |      |
| split_type                  | auto         |      |
| auto_balance                | off          |      |
| top_padding                 | 0            |      |
| bottom_padding              | 0            |      |
| left_padding                | 0            |      |
| right_padding               | 0            |      |
| window_gap                  | 0            |      |
| layout                      | bsp          |      |
| mouse_modifier              | fn           |      |
| mouse_action1               | move         |      |
| mouse_action2               | resize       |      |
| mouse_drop_action           | swap         |      |

#+name: yabai-config-string
#+begin_src elisp :var config=yabai-config
(->> config
     (-map (fn (`(,config-key ,config-value))
             (s-lex-format "${config-key} ${config-value}")))
     (s-join " ")
     (concat "yabai -m config "))
#+end_src

** yabairc

#+begin_src sh :shebang #!/bin/zsh :tangle ~/.config/yabai/yabairc
# for this to work you must configure sudo such that
# it will be able to run the command without password
#
# see this wiki page for information:
#  - https://github.com/koekeishiya/yabai/wiki/Installing-yabai-(latest-release)#configure-scripting-addition
yabai -m signal --add event=dock_did_restart action="sudo yabai --load-sa"
sudo yabai --load-sa

<<yabai-app-management()>>
<<yabai-config-string()>>
#+end_src

*** COMMENT Auto compile

#+begin_src elisp :noweb-ref org-post-tangle-environment-hook
(let* ((output-buffer (get-buffer-create "*Yabai reload*"))
       (proc (start-process "reload yabai" output-buffer "yabai" "--restart-service"))
       (sentinel (lambda (process signal)
                   (when (memq (process-status process) '(exit signal))
                     (message "Done")))))
  (if (process-live-p proc)
      (set-process-sentinel proc sentinel)
    (message "No process running.")))
#+end_src

* AWS

#+begin_src conf :tangle ~/.aws/config
[default]
region = us-east-2

[profile admin]
source = default
mfa_serial=arn:aws:iam::056866866838:mfa/drcostaras@daitaas.com

[profile root]
source = default
mfa_serial=arn:aws:iam::056866866838:mfa/root-account-mfa-device
#+end_src

* next

#+BEGIN_SRC
mkdir -p ~/.config/next
#+END_SRC
:tangle ~/.config/next/init.lisp
  #+BEGIN_SRC lisp
    (in-package :next)
    (define-key *global-map* (key "C-x o") #'function-example)
    ;; (add-to-default-list 'vi-normal-mode 'buffer 'default-modes)

    ;; (define-key :scheme :vi-normal
    ;;   "C-x o" 'example
    ;;   "SPACE" 'scroll-page-down)
  #+END_SRC

* Hosts file

#+BEGIN_SRC conf :tangle ~/src/hosts/myhosts
192.168.1.57 desktop
#+END_SRC

* brew

#+begin_src ruby :tangle ./Brewfile
# 'brew tap'
# tap "homebrew/cask"
# 'brew tap' with custom Git URL
# tap "user/tap-repo", "https://user@bitbucket.org/user/homebrew-tap-repo.git"
# set arguments for all 'brew install --cask' commands
# cask_args appdir: "~/Applications", require_sha: true

# 'brew install'
# brew "imagemagick"
# 'brew install --with-rmtp', 'brew services restart' on version changes
# brew "denji/nginx/nginx-full", args: ["with-rmtp"], restart_service: :changed
# 'brew install', always 'brew services restart', 'brew link', 'brew unlink mysql' (if it is installed)
# brew "mysql@5.6", restart_service: true, link: true, conflicts_with: ["mysql"]

# 'brew install --cask'
# cask "google-chrome"
# 'brew install --cask --appdir=~/my-apps/Applications'
# cask "firefox", args: { appdir: "~/my-apps/Applications" }
# 'brew install --cask' only if '/usr/libexec/java_home --failfast' fails
# cask "java" unless system "/usr/libexec/java_home --failfast"

# 'mas install'
# mas "1Password", id: 443987910

# 'whalebrew install'
# whalebrew "whalebrew/wget"

tap "railwaycat/emacsmacport"
tap "homebrew/cask-fonts"
tap "homebrew/cask-versions"

brew "adr-tools"
brew "angband"
brew "antigen"
brew "aspell"
brew "autoconf"
brew "automake"
brew "avanor"
brew "awscli"
brew "bash"
brew "bash-completion"
brew "bat"
brew "boot-clj"
brew "borkdude/brew/babashka"
brew "borkdude/brew/clj-kondo"
brew "borkdude/brew/jet"
brew "cataclysm"
brew "clojure"
brew "clojure-lsp/brew/clojure-lsp-native"
brew "cmake"
brew "coreutils"
brew "fd"
brew "ffmpeg"
brew "flac"
brew "git"
brew "git-annex"
brew "git-delta"
brew "gnu-typist"
brew "gnupg"
brew "gnutls"
brew "graphviz"
brew "htop"
brew "leiningen"
brew "makefile2graph"
brew "nmap"
brew "neovim"
brew "node"
brew "pass"
brew "pgcli"
brew "pinentry"
brew "pinentry-mac"
brew "pkg-config"
brew "postgres"
brew "prettier"
brew "pwgen"
brew "python3"
brew "rclone"
brew "ripgrep"
brew "rlwrap"
brew "shellcheck"
brew "siege"
# Doesn't work
# brew "sshfs"
brew "svn"
brew "texinfo"
brew "trash"
brew "unnethack"
brew "watch"
brew "wget"
brew "wireguard-tools"
brew "youtube-dl"

# yubikey
brew "gnupg"
brew "hopenpgp-tools"
brew "pinentry-mac"
brew "ykman"
brew "yubikey-personalization"

# cask "1password-cli"
cask "chromium"
cask "dwarf-fortress-lmp"
cask "emacs-mac"
cask "iterm2"
cask "little-snitch"
cask "menumeters"
cask "micro-snitch"
# no bottle
# cask "osxfuse"
# Already installed?
# cask "qlstephen"
cask "racket"
cask "rectangle"
cask "secretive"
cask "slack"
cask "steam"
cask "pixelsnap"
cask "vlc"
cask "yacreader"

# Fonts
cask "font-fira-code"
cask "font-source-code-pro"
cask "font-inconsolata"
#+end_src

** ffmpeg
   brew install ffmpeg \
   --with-chromaprint \
   --with-fdk-aac \
   --with-fontconfig \
   --with-freetype \
   --with-frei0r \
   --with-game-music-emu \
   --with-libass \
   --with-libbluray \
   --with-libbs2b \
   --with-libcaca \
   --with-libgsm \
   --with-libmodplug \
   --with-libsoxr \
   --with-libssh \
   --with-libvidstab \
   --with-libvorbis \
   --with-libvpx \
   --with-opencore-amr \
   --with-openh264 \
   --with-openjpeg \
   --with-openssl \
   --with-opus \
   --with-rtmpdump \
   --with-rubberband \
   --with-sdl2 \
   --with-snappy \
   --with-speex \
   --with-tesseract \
   --with-theora \
   --with-tools \
   --with-two-lame \
   --with-wavpack \
   --with-webp \
   --with-x265 \
   --with-xz \
   --with-zeromq \
   --with-zimg

** shell setup

#+begin_src sh :noweb-ref zprofile
eval "$(/opt/homebrew/bin/brew shellenv)"
#+end_src

* MacPorts

#+begin_src sh :noweb-ref zprofile
export PATH="/opt/local/bin:/opt/local/sbin:$PATH"
export MANPATH="/opt/local/share/man:$MANPATH"
#+end_src

* Nix
** COMMENT Environment

#+begin_src nix :tangle ~/.config/nix/env.nix
with import <nixpkgs> {}; [
  nix-prefetch-git

  <<nix-env-packages>>
]
#+end_src

Install the local Nix environment with ~nix-sync~

#+begin_src sh :shebang #!/bin/zsh :tangle ~/bin/nix-sync
nix-env -irf ~/.config/nix/env.nix
#+end_src

** Shell setup

#+begin_src sh :noweb-ref zprofile
if [[ -f '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh' ]]; then
  source '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
  export NIX_PATH="$XDG_STATE_HOME/nix/defexpr:$NIX_PATH"
  export NIX_PATH="$XDG_STATE_HOME/nix/defexpr/channels:$NIX_PATH"
fi
#+end_src

*** TODO state-home/nix/defexpr seems to be added twice... check this after computer restart

** nix-darwin

To build nix-darwin the first time with a custom config location
#+begin_src sh
$(nix-build '<darwin>' -A system --no-out-link)/sw/bin/darwin-rebuild switch -I "darwin-config=$XDG_CONFIG_HOME/nix/darwin/configuration.nix"
# $(nix-build '<darwin>' -A system --no-out-link)/sw/bin/darwin-rebuild switch -I "darwin-config=$XDG_CONFIG_HOME/nix/darwin/configuration.nix"
#+end_src

#+begin_src nix :tangle ~/.config/nix/env/nix-darwin/configuration.nix.backup
{ config, pkgs, ... }:

{
  nix.settings.experimental-features = "nix-command flakes";
  # TODO setup PATH
  nix.nixPath = [
    "$XDG_STATE_HOME/nix/defexpr/channels"
    "darwin=https://github.com/LnL7/nix-darwin/archive/master.tar.gz"
  ];

  launchd.user.envVariables.PATH = config.environment.systemPath;

  # List packages installed in system profile. To search by name, run:
  # $ nix-env -qaP | grep wget
  environment.systemPackages =
    with pkgs; [
      vim
      <<system-packages>>
    ];

  environment.darwinConfig = (
    builtins.trace (builtins.getEnv "XDG_CONFIG_HOME")
      "$XDG_CONFIG_HOME/nix/env/nix-darwin/configuration.nix"
  );

  # Auto upgrade nix package and the daemon service.
  services.nix-daemon.enable = true;
  # nix.package = pkgs.nix;

  # Create /etc/zshrc that loads the nix-darwin environment.
  programs.zsh.enable = true;  # default shell on catalina

  # Used for backwards compatibility, please read the changelog before changing.
  # $ darwin-rebuild changelog
  system.stateVersion = 4;

  security.pam.enableSudoTouchIdAuth = true;

  networking.hostName = "donavan-mbp-darwin";
  <<darwin-config>>
}
#+end_src
#+begin_src nix :tangle ~/.config/nix/env/nix-darwin/configuration.nix
{ self }: { pkgs, ... }: {
  # List packages installed in system profile. To search by name, run:
  # $ nix-env -qaP | grep wget
  environment.systemPackages =
    with pkgs; [
      vim
      <<system-packages>>
    ];

  # Auto upgrade nix package and the daemon service.
  services.nix-daemon.enable = true;
  # nix.package = pkgs.nix;

  # Necessary for using flakes on this system.
  nix.settings.experimental-features = "nix-command flakes";

  # Create /etc/zshrc that loads the nix-darwin environment.
  programs.zsh.enable = true;  # default shell on catalina
  # programs.fish.enable = true;

  # Set Git commit hash for darwin-version.
  system.configurationRevision = self.rev or self.dirtyRev or null;

  # Used for backwards compatibility, please read the changelog before changing.
  # $ darwin-rebuild changelog
  system.stateVersion = 4;

  # The platform the configuration will be used on.
  nixpkgs.hostPlatform = "aarch64-darwin";
}
#+end_src

*** Settings

#+begin_src nix :noweb-ref darwin-config
system.defaults.CustomUserPreferences = {
  NSGlobalDomain = {
    # Add a context menu item for showing the Web Inspector in web views
    WebKitDeveloperExtras = true;
  };
  "com.apple.finder" = {
    ShowExternalHardDrivesOnDesktop = true;
    ShowHardDrivesOnDesktop = true;
    ShowMountedServersOnDesktop = true;
    ShowRemovableMediaOnDesktop = true;
    # _FXSortFoldersFirst = true;
    # When performing a search, search the current folder by default
    FXDefaultSearchScope = "SCcf";
  };
  "com.apple.desktopservices" = {
    # Avoid creating .DS_Store files on network or USB volumes
    DSDontWriteNetworkStores = true;
    DSDontWriteUSBStores = true;
  };
  "com.apple.screensaver" = {
    # Require password immediately after sleep or screen saver begins
    askForPassword = 1;
    askForPasswordDelay = 0;
  };
  "com.apple.screencapture" = {
    location = "~/Desktop";
    type = "png";
  };
  "com.apple.Safari" = {
    # Privacy: don’t send search queries to Apple
    # UniversalSearchEnabled = false;
    # SuppressSearchSuggestions = true;
    # Press Tab to highlight each item on a web page
    WebKitTabToLinksPreferenceKey = true;
    ShowFullURLInSmartSearchField = true;
    # Prevent Safari from opening ‘safe’ files automatically after downloading
    AutoOpenSafeDownloads = false;
    ShowFavoritesBar = false;
    IncludeInternalDebugMenu = true;
    IncludeDevelopMenu = true;
    WebKitDeveloperExtrasEnabledPreferenceKey = true;
    WebContinuousSpellCheckingEnabled = true;
    # WebAutomaticSpellingCorrectionEnabled = false;
    AutoFillFromAddressBook = false;
    AutoFillCreditCardData = false;
    AutoFillMiscellaneousForms = false;
    WarnAboutFraudulentWebsites = true;
    WebKitJavaEnabled = false;
    WebKitJavaScriptCanOpenWindowsAutomatically = false;
    "com.apple.Safari.ContentPageGroupIdentifier.WebKit2TabsToLinks" = true;
    "com.apple.Safari.ContentPageGroupIdentifier.WebKit2DeveloperExtrasEnabled" = true;
    "com.apple.Safari.ContentPageGroupIdentifier.WebKit2BackspaceKeyNavigationEnabled" = false;
    "com.apple.Safari.ContentPageGroupIdentifier.WebKit2JavaEnabled" = false;
    "com.apple.Safari.ContentPageGroupIdentifier.WebKit2JavaEnabledForLocalFiles" = false;
    "com.apple.Safari.ContentPageGroupIdentifier.WebKit2JavaScriptCanOpenWindowsAutomatically" = false;
  };
  "com.apple.mail" = {
    # Disable inline attachments (just show the icons)
    DisableInlineAttachmentViewing = true;
  };
  "com.apple.AdLib" = {
    allowApplePersonalizedAdvertising = false;
  };
  "com.apple.print.PrintingPrefs" = {
    # Automatically quit printer app once the print jobs complete
    "Quit When Finished" = true;
  };
  "com.apple.SoftwareUpdate" = {
    AutomaticCheckEnabled = true;
    # Check for software updates daily, not just once per week
    ScheduleFrequency = 1;
    # Download newly available updates in background
    AutomaticDownload = 1;
    # Install System data files & security updates
    CriticalUpdateInstall = 1;
  };
  "com.apple.TimeMachine".DoNotOfferNewDisksForBackup = true;
  # Prevent Photos from opening automatically when devices are plugged in
  "com.apple.ImageCapture".disableHotPlug = true;
  # Turn on app auto-update
  "com.apple.commerce".AutoUpdate = true;
};
#+end_src

**** Auto activate settings

Following line should allow us to avoid a logout/login cycle

#+begin_src nix :noweb-ref darwing-config
system.activationScripts.postUserActivation.text = "/System/Library/PrivateFrameworks/SystemAdministration.framework/Resources/activateSettings -u";
#+end_src

*** COMMENT Auto rebuild

#+begin_src elisp :noweb-ref org-post-tangle-environment-hook
(>start-sudo-process "darwin-rebuild switch")
#+end_src

** Pinned defexpr

See [[id:63f3bd33-8510-4810-9f5e-d7618bfba029][Using Nix on macOS]] for scripts that determine the revision to use

~import <nixpkgs>~ seems to really need ~defexpr/nixpkgs~ to be a directory.

#+begin_src nix :tangle ~/.local/state/nix/defexpr/nixpkgs/default.nix
import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/7b138d80b4cc04cd9d4df6944dd914234fcc090a.tar.gz")
#+end_src

*** Updating the revision
#+begin_src sh :shebang #!/usr/bin/env nix-shell :tangle ~/bin/nix-update-revision
#!nix-shell -i bash -p bash curl jq
# shellcheck shell=bash

# Just go with the revision that works for stable darwin. Might as well for now
# unless there's an issue.

set -euo pipefail

dryrun=1

usage() {
  cat <<USAGEEOF
Usage: $0 [OPTIONS]

Options:
  -h  --help      show this help
  -n  --dry-run   do not make any changes
USAGEEOF
}

for arg in "$@"; do
  case ${arg} in
    '-n' | '--dry-run')
      dryrun=1
      ;;
    '-h' | '--help')
      usage
      exit 0
      ;;
    *)
      echo "$0: Unexpected argument: ${arg}" >&2
      usage >&2
      exit 1
      ;;
  esac
done


revision=$(curl --silent --show-error 'https://monitoring.nixos.org/prometheus/api/v1/query?query=channel_revision' \
  | jq -r '.data.result[]|select(.metric.status == "stable" and .metric.variant == "darwin").metric.revision')
nixexpr="import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/${revision}.tar.gz\")"
nixpkgsfile="$XDG_STATE_HOME/nix/defexpr/nixpkgs/default.nix"

mkdir -p "$(dirname "${nixpkgsfile}")"
if [[ -f "${nixpkgsfile}" ]] && diff -q "${nixpkgsfile}" - <<< "${nixexpr}" >/dev/null; then
  echo 'nixpkgs already up to date'
  exit 0
fi

if [[ ${dryrun} -ne 0 ]]; then
  echo "This would set nixpkgs to revision ${revision}"
else
  echo "Setting nixpkgs to revision ${revision}"
  # echo "${nixexpr}" >${nixpkgsfile}
fi

nix-diff "${revision}"
#+end_src

#+begin_src sh :shebang #!/usr/bin/env nix-shell :tangle ~/bin/nix-diff
#!nix-shell -i bash -p bash jq
# shellcheck shell=bash

# Usage: nix-diff [revision]
# where revision is the full nixpkgs revision.

set -euo pipefail

declare -A cur

query() {
  nix-env --query --json "$@" | jq -r '.[] | .pname + " " + .version'
}

query_args=()

if [[ $# -eq 1 ]]; then
  query_args=('--file' "https://github.com/NixOS/nixpkgs/archive/$1.tar.gz")
fi

while read -r name version; do
  cur[${name}]=${version}
done < <(query "${query_args[@]}")

ret=0
while read -r name version; do
  if [[ -n ${cur[${name}]:-} ]]; then
    if [[ "${version}" != "${cur[${name}]}" ]]; then
      echo -e "\033[33mM ${name} ${cur[${name}]} ➤ ${version}\033[0m"
      ret=1
    fi
    unset "cur[${name}]"
  else
    echo -e "\033[32mA ${name} ${version}\033[0m"
    ret=1
  fi
done < <(query -af "$HOME/.config/nix/env.nix")

for name in "${!cur[@]}"; do
  echo -e "\033[31mD ${name} ${cur[${name}]}\033[0m"
  ret=1
done

if [[ ${ret} -ne 0 ]]; then
  # Disable SC2016 (info): Expressions don't expand in single quotes, use double quotes for that.
  # shellcheck disable=SC2016
  echo 'Run `nix-env -irf ~/.config/nix/env.nix` to make these changes'
fi

exit "${ret}"

# vim: set sw=2 sts=2 ts=8 et ft=bash:
#+end_src

** nix.conf

#+begin_src conf :tangle ~/.config/nix/nix.conf
experimental-features = nix-command flakes
#+end_src

** Flakes

#+begin_src nix :tangle ~/.config/nix/env/flake.nix
# {
#   description = "Environment";

#   inputs = {
#     stable.url = "github:nixos/nixpkgs/nixos-21.11";
#     unstable.url = "github:nixos/nixpkgs/nixpkgs-unstable";

#     nixpkgs.follows = "unstable";

#     darwin = {
#       url = "github:lnl7/nix-darwin";
#       inputs.nixpkgs.follows = "nixpkgs";
#     };

#   };

#   outputs = {nixpkgs, darwin, ...}: {
#     darwinConfigurations = rec {
#       "Donavans-Virtual-Machine" = darwin.lib.darwinSystem {
#         system = "aarch64-darwin";
#         modules = [ ./nix-darwin/configuration.nix ];
#       };
#     };
#   };
# }
{
  description = "Example Darwin system flake";

  inputs = {
    stable.url = "github:nixos/nixpkgs/nixos-21.11";
    unstable.url = "github:nixos/nixpkgs/nixpkgs-unstable";

    nixpkgs.follows = "unstable";

    nix-darwin = {
      url = "github:lnl7/nix-darwin";
      inputs.nixpkgs.follows = "nixpkgs";
    };

  };

  outputs = { self, nix-darwin, nixpkgs, ...}:
      {
        darwinConfigurations."Donavans-Virtual-Machine" = nix-darwin.lib.darwinSystem {
          modules = [ (import ./nix-darwin/configuration.nix {self = self;}) ];
          # modules = [ configuration ];
        };

        # Expose the package set, including overlays, for convenience.
        darwinPackages = self.darwinConfigurations."Donavans-Virtual-Machine".pkgs;
      };
}
#+end_src

* ssh

#+BEGIN_SRC conf :tangle ~/.ssh/config :tangle-mode (identity #o600)
Host github github.com
User git
Hostname github.com
identityfile ~/.ssh/github-dcostaras.pub
IdentitiesOnly yes
IdentityAgent ~/Library/Containers/com.maxgoedjen.Secretive.SecretAgent/Data/socket.ssh

Host gitlab gitlab.com
User git
Hostname gitlab.com
identityfile ~/.ssh/gitlab.pub
IdentitiesOnly yes
IdentityAgent ~/Library/Containers/com.maxgoedjen.Secretive.SecretAgent/Data/socket.ssh

Host rsync rsync.net zh1784.rsync.net
Hostname zh1784.rsync.net
User zh1784
identityfile ~/.ssh/rsync.net.pub
IdentitiesOnly yes
IdentityAgent ~/Library/Containers/com.maxgoedjen.Secretive.SecretAgent/Data/socket.ssh

Host bitbucket bitbucket.org
User git
Hostname bitbucket.org
identityfile ~/.ssh/bitbucket
IdentitiesOnly yes

Host desktop
User dcost
Hostname 192.168.1.57
Identityfile ~/.ssh/desktop
IdentitiesOnly yes

Host proxy
User root
Hostname 134.209.87.117
Identityfile ~/.ssh/donavan
IdentitiesOnly yes

Host media
User media
Hostname 192.168.0.14
IdentityFile ~/.ssh/donavan
IdentitiesOnly yes
ForwardAgent yes

Host vm
User donavan
Hostname 192.168.64.3

Host * !bitbucket.org !github.com

User donavan

# ForwardAgents no
ServerAliveInterval 60

TCPKeepAlive no


ConnectionAttempts 3

Compression yes
Port 22
EscapeChar ^y

AddKeysToAgent yes
UseKeychain yes
#+END_SRC

* Git

#+begin_src gitconfig :tangle ~/.config/git/config
[user]
 name = Donavan-Ross Costaras
 email = d.costaras@gmail.com
[protocol "keybase"]
 allow = always
[github]
 user = dcostaras
#+end_src

* UTM

#+begin_src nix :noweb-ref system-packages
utm
#+end_src

** MacOS guest

#+BEGIN_SRC apples :var subject="World" :results replace
  "Hello " & subject
#+END_SRC

#+RESULTS:
: Hello World

#+begin_src apples
tell application "UTM"
    --- specify a boot ISO
    -- set iso to POSIX file "/path/to/ubuntu.iso"
    --- create a new QEMU VM for ARM64 with a single 64GiB drive
    -- set vm to make new virtual machine with properties {backend:qemu, configuration:{name:"QEMU ARM64", architecture:"aarch64", drives:{{removable:true, source:iso}, {guest size:65536}}}}
    --- note the default options for a new VM is no display, one PTTY serial port, and one shared network
    --- duplicate an existing VM and disable hypervisor in the duplicate
    -- duplicate vm with properties {configuration:{name:"Duplicate QEMU ARM64", hypervisor:false}}
    --- create an Apple VM for booting Linux (only supported on macOS 13+)
    -- make new virtual machine with properties {
    --   backend: apple,
    --   configuration: {
    --     name:"Apple Linux",
    --     drives: {
    --       {
    --         removable: true,
    --         source: iso
    --       },
    --       {
    --         guest size: 65536
    --       }
    --     }
    --   }
    -- }
    make new virtual machine with properties {¬
        backend: apple,¬
        configuration: {¬
            name: "Apple Linux",¬
            drives: {¬
                {¬
                    removable: true,¬
                    source: iso¬
                },¬
                {¬
                    guest size: 65536¬
                }¬
            }¬
        }¬
    }
end tell
#+end_src

#+begin_src apples
tell application "UTM"
    --- QEMU guest agent must be installed
    set vm to virtual machine named "macOS"
    --- run a shell command
    execute of vm at "open" with arguments {"http://example.com"}
    --- run a shell command and capture the output
    -- tell (execute of vm at "ls" with arguments {"-l", "/"} with output capturing)
    --     --- wait until execution is complete
    --     repeat
    --         set res to get result
    --         if exited of res then exit repeat
    --     end repeat
    --     --- fetch stdout as text
    --     get output text of res
    --     --- fetch stdout as base64 data
    --     get output data of res
    -- end tell
end tell
#+end_src

* TODO Quicklook plugins
Works: --------------------
  # Preview source code files with syntax highlighting (like colored .JS files)
  brew install qlcolorcode

  # Preview Markdown files
  brew install qlstephen

  # Preview JSON files with syntax highlighting
  brew install quicklook-json

  # Preview plaintext files with unknown extensions, like README, CHANGELOG, etc.
  brew install qlstephen

  # Preview the content of .IPA files
  # Installs inside /Applications folder
  brew install suspicious-package

  # Preview iOS/macOS provisioning information for .ipa and .xcarchive
  # For 'mobileprovision' files, Xcode has Quick Look plugin collision:
  # https://github.com/ealeksandrov/ProvisionQL/issues/20
  brew install provisionql

  # Preview the content of macOS apps
  # Installs inside /Applications folder
  brew install apparency

  # Preview WebP images
  brew install webpquicklook

Broken: --------------------
  # Display image size and resolution in windo titlebar of Quick Look
  # Doesn't work due to API change from Apple
  # https://github.com/Nyx0uf/qlImageSize/issues/45#issuecomment-610852166
  #brew install qlimagesize

  # Preview Adobe ASE color swatch files from Photoshop, Illustrator
  # Doesn't work in macOS Catalina
  #brew install quicklookase

  # Preview the content of Android .APK files
  # Doesn't work in macOS Catalina
  #brew install quicklookapk

  https://github.com/spiritphyz/Save-the-Environment/blob/main/User/quicklook-plugins/install-quicklook-plugins.sh
